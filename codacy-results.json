[{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/arb_bot_manager.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":210}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/health_check_old.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":100}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/health_check_old.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":55}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2012"},"filename":"clean_arb_bot/scripts/monitor_live_trades.sh","message":{"text":"Use find instead of ls to better handle non-alphanumeric filenames."},"level":"Warning","category":null,"location":{"LineLocation":{"line":6}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/health_check_old.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":74}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2126"},"filename":"clean_arb_bot/production/status_arb_bot.sh","message":{"text":"Consider using 'grep -c' instead of 'grep|wc -l'."},"level":"Info","category":null,"location":{"LineLocation":{"line":89}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2199"},"filename":"clean_arb_bot/production/health_check.sh","message":{"text":"Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @)."},"level":"Warning","category":null,"location":{"LineLocation":{"line":139}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2155"},"filename":"clean_arb_bot/production/arb_bot_manager.sh","message":{"text":"Declare and assign separately to avoid masking return values."},"level":"High","category":null,"location":{"LineLocation":{"line":154}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2009"},"filename":"clean_arb_bot/scripts/monitor_status.sh","message":{"text":"Consider using pgrep instead of grepping ps output."},"level":"Warning","category":null,"location":{"LineLocation":{"line":9}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/status_arb_bot.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":52}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/status_arb_bot.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":50}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2034"},"filename":"clean_arb_bot/production/arb_bot_manager.sh","message":{"text":"RED appears unused. Verify use (or export if used externally)."},"level":"Warning","category":null,"location":{"LineLocation":{"line":24}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2155"},"filename":"clean_arb_bot/production/autonomous_monitor.sh","message":{"text":"Declare and assign separately to avoid masking return values."},"level":"High","category":null,"location":{"LineLocation":{"line":198}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2199"},"filename":"clean_arb_bot/production/health_check_old.sh","message":{"text":"Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @)."},"level":"Warning","category":null,"location":{"LineLocation":{"line":140}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/scripts/go_live.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":28}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2034"},"filename":"clean_arb_bot/production/stop_arb_bot.sh","message":{"text":"YELLOW appears unused. Verify use (or export if used externally)."},"level":"Warning","category":null,"location":{"LineLocation":{"line":9}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/arb_bot_manager.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":160}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/arb_bot_manager.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":124}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/scripts/filter_impact.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":38}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/arb_bot_manager.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":66}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/health_check.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":92}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/health_check.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":89}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2012"},"filename":"clean_arb_bot/scripts/check_trading_status.sh","message":{"text":"Use find instead of ls to better handle non-alphanumeric filenames."},"level":"Warning","category":null,"location":{"LineLocation":{"line":5}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2155"},"filename":"clean_arb_bot/production/autonomous_monitor.sh","message":{"text":"Declare and assign separately to avoid masking return values."},"level":"High","category":null,"location":{"LineLocation":{"line":216}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/health_check.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":72}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/status_arb_bot.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":49}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2162"},"filename":"clean_arb_bot/production/status_arb_bot.sh","message":{"text":"read without -r will mangle backslashes."},"level":"Warning","category":null,"location":{"LineLocation":{"line":100}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/arb_bot_manager.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":217}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2155"},"filename":"clean_arb_bot/production/autonomous_monitor.sh","message":{"text":"Declare and assign separately to avoid masking return values."},"level":"High","category":null,"location":{"LineLocation":{"line":279}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/health_check.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":55}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2199"},"filename":"clean_arb_bot/production/health_check_old.sh","message":{"text":"Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @)."},"level":"Warning","category":null,"location":{"LineLocation":{"line":137}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2009"},"filename":"clean_arb_bot/scripts/monitor_status.sh","message":{"text":"Consider using pgrep instead of grepping ps output."},"level":"Warning","category":null,"location":{"LineLocation":{"line":11}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2034"},"filename":"clean_arb_bot/production/arb_bot_manager.sh","message":{"text":"NC appears unused. Verify use (or export if used externally)."},"level":"Warning","category":null,"location":{"LineLocation":{"line":27}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2199"},"filename":"clean_arb_bot/production/health_check.sh","message":{"text":"Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @)."},"level":"Warning","category":null,"location":{"LineLocation":{"line":142}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/arb_bot_manager.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":180}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2034"},"filename":"clean_arb_bot/production/arb_bot_manager.sh","message":{"text":"GREEN appears unused. Verify use (or export if used externally)."},"level":"Warning","category":null,"location":{"LineLocation":{"line":25}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/health_check_old.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":87}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2155"},"filename":"clean_arb_bot/production/autonomous_monitor.sh","message":{"text":"Declare and assign separately to avoid masking return values."},"level":"High","category":null,"location":{"LineLocation":{"line":187}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC1091"},"filename":"clean_arb_bot/production/autonomous_monitor.sh","message":{"text":"Not following: ./.env: openBinaryFile: does not exist (No such file or directory)"},"level":"Warning","category":null,"location":{"LineLocation":{"line":132}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2199"},"filename":"clean_arb_bot/production/health_check_old.sh","message":{"text":"Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @)."},"level":"Warning","category":null,"location":{"LineLocation":{"line":134}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2001"},"filename":"clean_arb_bot/scripts/monitor_dashboard_detailed.sh","message":{"text":"See if you can use ${variable//search/replace} instead."},"level":"Warning","category":null,"location":{"LineLocation":{"line":177}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2199"},"filename":"clean_arb_bot/production/health_check.sh","message":{"text":"Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @)."},"level":"Warning","category":null,"location":{"LineLocation":{"line":145}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2162"},"filename":"clean_arb_bot/scripts/go_live.sh","message":{"text":"read without -r will mangle backslashes."},"level":"Warning","category":null,"location":{"LineLocation":{"line":46}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/health_check.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":105}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/health_check.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":75}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/health_check_old.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":71}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2034"},"filename":"clean_arb_bot/production/arb_bot_manager.sh","message":{"text":"YELLOW appears unused. Verify use (or export if used externally)."},"level":"Warning","category":null,"location":{"LineLocation":{"line":26}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/arb_bot_manager.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":164}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2162"},"filename":"clean_arb_bot/scripts/go_live.sh","message":{"text":"read without -r will mangle backslashes."},"level":"Warning","category":null,"location":{"LineLocation":{"line":106}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/watchdog.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":72}},"sourceId":null}},{"Issue":{"patternId":{"value":"shellcheck_SC2086"},"filename":"clean_arb_bot/production/status_arb_bot.sh","message":{"text":"Double quote to prevent globbing and word splitting."},"level":"Warning","category":null,"location":{"LineLocation":{"line":51}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":264}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":62}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":128}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":208}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":365}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":342}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":205}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":115}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":207}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":347}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":274}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":256}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":167}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":212}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":125}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":333}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":209}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":130}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":269}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":252}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":204}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":205}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":132}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":114}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":343}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":263}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":356}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":136}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":206}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":201}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":210}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":209}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":275}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":334}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":270}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":201}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":331}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":135}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":129}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":169}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":349}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"claw.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":272}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":348}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":166}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":361}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":277}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":362}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":203}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":350}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":113}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":268}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":344}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"claw.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":267}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"claw.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":7}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":131}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":168}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":249}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":338}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":123}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":267}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":118}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"claw.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":268}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":339}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"claw.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":270}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"claw.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":271}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"claw.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":266}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"claw.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":9}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"claw.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":269}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":276}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":254}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":340}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":206}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":137}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":271}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":281}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":250}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":119}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":354}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":358}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":204}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":355}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":335}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":138}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":332}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":280}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":124}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":351}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":203}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":253}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":251}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":255}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":341}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":364}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":200}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":202}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":357}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":363}},"sourceId":null}},{"Issue":{"patternId":{"value":"remark-lint-no-undefined-references"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"[no-undefined-references] Found reference to undefined definition"},"level":"Warning","category":null,"location":{"LineLocation":{"line":211}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":455}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":106}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":98}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":393}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":304}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD029"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Expected: 1; Actual: 2; Style: 1/1/1"},"level":"Info","category":null,"location":{"LineLocation":{"line":161}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":95}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD033"},"filename":"clean_arb_bot/TODO.md","message":{"text":"Element: Instruction"},"level":"Info","category":null,"location":{"LineLocation":{"line":47}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":166}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":228}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":11}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":227}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":151}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"CLAUDE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":44}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":161}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":82}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Expected: 80; Actual: 147"},"level":"Info","category":null,"location":{"LineLocation":{"line":265}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD029"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 2; Actual: 3; Style: 1/2/3"},"level":"Info","category":null,"location":{"LineLocation":{"line":35}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":202}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":50}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":104}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":160}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":187}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":346}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD036"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Emphasis used instead of a heading"},"level":"Info","category":null,"location":{"LineLocation":{"line":106}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":90}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":223}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":311}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Punctuation: '!'"},"level":"Info","category":null,"location":{"LineLocation":{"line":1}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":321}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":111}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":156}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":265}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":94}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Expected: 80; Actual: 84"},"level":"Info","category":null,"location":{"LineLocation":{"line":47}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":76}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Punctuation: '!'"},"level":"Info","category":null,"location":{"LineLocation":{"line":8}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"claw.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":275}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":94}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":218}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":91}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":79}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":276}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD034"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Bare URL used"},"level":"Info","category":null,"location":{"LineLocation":{"line":442}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"claw.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":27}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":78}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":91}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":190}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":66}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":148}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":314}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":143}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":54}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/TODO.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":68}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":134}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":141}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":86}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"claw.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":138}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":250}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":56}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":118}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"claw.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":223}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":360}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":192}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":109}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":191}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/TODO.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":45}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Expected: 80; Actual: 114"},"level":"Info","category":null,"location":{"LineLocation":{"line":11}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":204}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":224}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD029"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 8; Style: 1/1/1"},"level":"Info","category":null,"location":{"LineLocation":{"line":57}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":270}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD034"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Bare URL used"},"level":"Info","category":null,"location":{"LineLocation":{"line":440}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":221}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":8}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":102}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":219}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":97}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":204}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":51}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":173}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":41}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":73}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":245}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":49}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":372}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":122}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"claw.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":207}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD033"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Element: T"},"level":"Info","category":null,"location":{"LineLocation":{"line":76}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":88}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":394}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":106}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":173}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":185}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":223}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":122}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":338}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":107}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"claw.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":51}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":175}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":85}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":235}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":123}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":239}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":206}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":161}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":67}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":380}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":291}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Expected: 80; Actual: 97"},"level":"Info","category":null,"location":{"LineLocation":{"line":262}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":209}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":28}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":37}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":155}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":130}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":244}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":390}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":30}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":205}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":225}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":160}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":149}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":214}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":35}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":384}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":134}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Expected: 80; Actual: 91"},"level":"Info","category":null,"location":{"LineLocation":{"line":29}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":208}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":114}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":55}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Expected: 80; Actual: 97"},"level":"Info","category":null,"location":{"LineLocation":{"line":99}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":446}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Expected: 80; Actual: 104"},"level":"Info","category":null,"location":{"LineLocation":{"line":164}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":98}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":280}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"claw.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":208}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":269}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":116}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":435}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":216}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":97}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":74}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":128}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":290}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Expected: 80; Actual: 101"},"level":"Info","category":null,"location":{"LineLocation":{"line":264}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 80; Actual: 90"},"level":"Info","category":null,"location":{"LineLocation":{"line":26}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":215}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":57}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":64}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":119}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":109}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":174}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":169}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":225}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":401}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"claw.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":62}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":199}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":304}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":253}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":73}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":103}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":193}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":132}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 80; Actual: 91"},"level":"Info","category":null,"location":{"LineLocation":{"line":4}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":53}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD033"},"filename":"clean_arb_bot/TODO.md","message":{"text":"Element: Instruction"},"level":"Info","category":null,"location":{"LineLocation":{"line":40}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Expected: 80; Actual: 100"},"level":"Info","category":null,"location":{"LineLocation":{"line":10}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":119}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":110}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":55}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":258}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Expected: 80; Actual: 97"},"level":"Info","category":null,"location":{"LineLocation":{"line":343}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD034"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Bare URL used"},"level":"Info","category":null,"location":{"LineLocation":{"line":63}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":191}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":181}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD034"},"filename":"CLAUDE.md","message":{"text":"Bare URL used"},"level":"Info","category":null,"location":{"LineLocation":{"line":42}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD029"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 9; Style: 1/2/3"},"level":"Info","category":null,"location":{"LineLocation":{"line":64}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":107}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":288}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"CLAUDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":16}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":93}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":317}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":67}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":169}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":179}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":264}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":167}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":45}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 80; Actual: 99"},"level":"Info","category":null,"location":{"LineLocation":{"line":107}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":119}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/TODO.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":22}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Expected: 80; Actual: 89"},"level":"Info","category":null,"location":{"LineLocation":{"line":337}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Expected: 80; Actual: 100"},"level":"Info","category":null,"location":{"LineLocation":{"line":99}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":101}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":144}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 80; Actual: 125"},"level":"Info","category":null,"location":{"LineLocation":{"line":312}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":213}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":219}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":113}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":19}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Expected: 80; Actual: 91"},"level":"Info","category":null,"location":{"LineLocation":{"line":342}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"claw.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":246}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"claw.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":245}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":252}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":183}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":67}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD029"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 3; Actual: 11; Style: 1/2/3"},"level":"Info","category":null,"location":{"LineLocation":{"line":66}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":213}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":146}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":168}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Expected: 80; Actual: 83"},"level":"Info","category":null,"location":{"LineLocation":{"line":105}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":9}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":77}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Expected: 80; Actual: 83"},"level":"Info","category":null,"location":{"LineLocation":{"line":103}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD033"},"filename":"clean_arb_bot/TODO.md","message":{"text":"Element: Instruction"},"level":"Info","category":null,"location":{"LineLocation":{"line":33}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":22}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":22}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":114}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":80}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":161}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":497}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":239}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":114}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"claw.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":224}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":32}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":175}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 80; Actual: 101"},"level":"Info","category":null,"location":{"LineLocation":{"line":310}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":257}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":478}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":239}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":61}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":201}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":224}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":17}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":178}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"claw.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":266}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":69}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":40}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":211}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":168}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":353}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":111}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":134}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":137}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":35}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":215}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD034"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Bare URL used"},"level":"Info","category":null,"location":{"LineLocation":{"line":130}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":72}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":92}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":286}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":17}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":98}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":169}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"claw.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":236}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"claw.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":185}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":26}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":409}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":324}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":212}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":210}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":162}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/TODO.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":75}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD029"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 7; Style: 1/1/1"},"level":"Info","category":null,"location":{"LineLocation":{"line":52}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":88}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"claw.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":21}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":37}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":184}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":282}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":49}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":64}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":56}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":185}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":238}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":112}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"README.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":28}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":60}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"claw.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":199}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":170}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Expected: 80; Actual: 89"},"level":"Info","category":null,"location":{"LineLocation":{"line":48}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":27}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":200}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/TODO.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":31}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":238}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":96}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":214}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":112}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":124}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"README.md","message":{"text":"Expected: 80; Actual: 109"},"level":"Info","category":null,"location":{"LineLocation":{"line":3}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"claw.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":255}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":56}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":145}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":12}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":216}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":221}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":177}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":84}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":318}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD034"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Bare URL used"},"level":"Info","category":null,"location":{"LineLocation":{"line":443}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":274}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":150}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Expected: 80; Actual: 96"},"level":"Info","category":null,"location":{"LineLocation":{"line":280}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":219}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"CLAUDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":10}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Expected: 80; Actual: 94"},"level":"Info","category":null,"location":{"LineLocation":{"line":65}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"claw.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":32}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":331}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":154}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Expected: 80; Actual: 130"},"level":"Info","category":null,"location":{"LineLocation":{"line":7}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":198}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":337}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":354}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":77}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/TODO.md","message":{"text":"Expected: 80; Actual: 89"},"level":"Info","category":null,"location":{"LineLocation":{"line":84}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Expected: 80; Actual: 102"},"level":"Info","category":null,"location":{"LineLocation":{"line":5}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"claw.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":74}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":264}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":195}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD034"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Bare URL used"},"level":"Info","category":null,"location":{"LineLocation":{"line":120}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Expected: 80; Actual: 103"},"level":"Info","category":null,"location":{"LineLocation":{"line":26}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":174}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":377}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":199}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":146}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":205}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":50}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":11}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":57}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":135}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":186}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":174}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":13}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Expected: 80; Actual: 83"},"level":"Info","category":null,"location":{"LineLocation":{"line":101}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":283}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Expected: 80; Actual: 117"},"level":"Info","category":null,"location":{"LineLocation":{"line":242}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":109}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD034"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Bare URL used"},"level":"Info","category":null,"location":{"LineLocation":{"line":214}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":121}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"claw.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":26}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":141}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":158}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":47}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":274}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":133}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":84}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":252}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":267}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":92}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":81}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":286}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":160}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD034"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Bare URL used"},"level":"Info","category":null,"location":{"LineLocation":{"line":215}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":22}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":220}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":31}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":270}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"claw.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":274}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":160}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":79}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":191}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":142}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"claw.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":20}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":101}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":159}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":179}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":149}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD034"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Bare URL used"},"level":"Info","category":null,"location":{"LineLocation":{"line":218}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/TODO.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":38}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":135}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":56}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":20}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":36}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":400}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":52}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"claw.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":173}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":104}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":320}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":116}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":31}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":226}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 80; Actual: 101"},"level":"Info","category":null,"location":{"LineLocation":{"line":194}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":54}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":44}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":173}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":385}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":153}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"CLAUDE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":9}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":167}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"claw.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":186}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Expected: 80; Actual: 93"},"level":"Info","category":null,"location":{"LineLocation":{"line":228}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":111}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 80; Actual: 89"},"level":"Info","category":null,"location":{"LineLocation":{"line":106}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":7}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":165}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":240}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":218}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":23}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD034"},"filename":"CLAUDE.md","message":{"text":"Bare URL used"},"level":"Info","category":null,"location":{"LineLocation":{"line":3}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":13}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":103}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Expected: 80; Actual: 305"},"level":"Info","category":null,"location":{"LineLocation":{"line":11}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":220}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD036"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Emphasis used instead of a heading"},"level":"Info","category":null,"location":{"LineLocation":{"line":357}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":219}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Expected: 80; Actual: 91"},"level":"Info","category":null,"location":{"LineLocation":{"line":344}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":49}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":28}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":225}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":295}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":166}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":128}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"claw.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":52}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":347}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":141}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":76}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":201}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":134}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":164}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":160}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":229}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":115}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":410}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":70}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":107}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":209}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/TODO.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":82}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":112}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":203}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":305}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD029"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 4; Actual: 12; Style: 1/2/3"},"level":"Info","category":null,"location":{"LineLocation":{"line":67}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":109}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":395}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":184}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":19}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":82}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"claw.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":137}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"claw.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":84}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":223}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"claw.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":6}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":93}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":126}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":91}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":108}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":9}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":141}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":262}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":127}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Expected: 80; Actual: 99"},"level":"Info","category":null,"location":{"LineLocation":{"line":266}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Expected: 80; Actual: 105"},"level":"Info","category":null,"location":{"LineLocation":{"line":282}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD029"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 4; Actual: 5; Style: 1/2/3"},"level":"Info","category":null,"location":{"LineLocation":{"line":43}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":146}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":122}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":212}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":150}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":256}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":18}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":233}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"claw.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":96}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Expected: 80; Actual: 91"},"level":"Info","category":null,"location":{"LineLocation":{"line":112}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":119}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":165}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":383}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":134}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 80; Actual: 175"},"level":"Info","category":null,"location":{"LineLocation":{"line":13}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":275}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":470}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":250}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":220}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"claw.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":256}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":48}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":94}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":231}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":145}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":27}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":125}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD029"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 6; Actual: 14; Style: 1/2/3"},"level":"Info","category":null,"location":{"LineLocation":{"line":69}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":274}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":112}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":117}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":177}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":161}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":220}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":282}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"CLAUDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":29}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":176}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":244}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":153}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":225}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":107}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"claw.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":235}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":43}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":115}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":150}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":57}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":193}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":140}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":203}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":59}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":125}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":16}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"claw.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":200}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":27}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":12}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":210}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":190}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":182}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":226}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":76}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":275}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":68}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":216}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":52}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":120}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":177}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":170}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":134}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":154}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":377}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Expected: 80; Actual: 139"},"level":"Info","category":null,"location":{"LineLocation":{"line":341}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":28}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":108}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":168}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD024"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Multiple headings with the same content"},"level":"Warning","category":null,"location":{"LineLocation":{"line":434}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":238}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"claw.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":15}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":256}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":12}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Expected: 80; Actual: 105"},"level":"Info","category":null,"location":{"LineLocation":{"line":85}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":110}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":16}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":265}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":27}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":215}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":68}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":79}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":278}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Expected: 80; Actual: 82"},"level":"Info","category":null,"location":{"LineLocation":{"line":102}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":20}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":39}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":250}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":106}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":89}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":209}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":232}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":378}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":70}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":263}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":89}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":176}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":207}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":84}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":144}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":223}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":80}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":18}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":94}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":322}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":195}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD029"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 5; Actual: 6; Style: 1/2/3"},"level":"Info","category":null,"location":{"LineLocation":{"line":47}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":69}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":150}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":270}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":77}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":238}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":77}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"claw.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":161}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":145}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":165}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":154}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":249}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":25}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/TODO.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":54}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":151}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":117}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Expected: 80; Actual: 88"},"level":"Info","category":null,"location":{"LineLocation":{"line":95}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":150}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"claw.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":33}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":202}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":172}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":172}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":240}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD029"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Expected: 1; Actual: 3; Style: 1/1/1"},"level":"Info","category":null,"location":{"LineLocation":{"line":169}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"claw.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":61}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":154}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":58}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":47}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":12}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":40}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":60}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD034"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Bare URL used"},"level":"Info","category":null,"location":{"LineLocation":{"line":441}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":75}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":10}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":78}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":143}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"claw.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":229}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":64}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":183}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":30}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":47}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/TODO.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":14}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":63}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":13}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":361}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":478}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":103}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":217}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":17}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":14}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":10}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":230}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":205}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"claw.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":75}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":118}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Expected: 80; Actual: 86"},"level":"Info","category":null,"location":{"LineLocation":{"line":48}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":130}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"claw.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":124}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":32}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"CLAUDE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":15}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 80; Actual: 88"},"level":"Info","category":null,"location":{"LineLocation":{"line":42}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"CLAUDE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":39}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":218}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":112}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 80; Actual: 139"},"level":"Info","category":null,"location":{"LineLocation":{"line":29}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":180}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":18}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":470}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":250}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":122}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":123}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":96}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"README.md","message":{"text":"Expected: 80; Actual: 100"},"level":"Info","category":null,"location":{"LineLocation":{"line":7}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":35}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":85}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":98}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":264}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":434}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"CLAUDE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":28}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":192}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/TODO.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":61}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":293}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":36}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":217}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":118}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":46}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":96}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":232}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":445}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":193}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":245}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":244}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":81}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"claw.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":111}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 80; Actual: 93"},"level":"Info","category":null,"location":{"LineLocation":{"line":82}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":10}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":121}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":219}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":261}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":148}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":28}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":206}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"CLAUDE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":95}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":102}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":160}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":171}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Expected: 80; Actual: 82"},"level":"Info","category":null,"location":{"LineLocation":{"line":293}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":274}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":244}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Expected: 80; Actual: 95"},"level":"Info","category":null,"location":{"LineLocation":{"line":263}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":321}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":274}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":65}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":104}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":197}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":151}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Expected: 80; Actual: 98"},"level":"Info","category":null,"location":{"LineLocation":{"line":62}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":213}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":126}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/TODO.md","message":{"text":"Expected: 80; Actual: 91"},"level":"Info","category":null,"location":{"LineLocation":{"line":19}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":131}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":86}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":234}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":149}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":251}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":204}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 80; Actual: 202"},"level":"Info","category":null,"location":{"LineLocation":{"line":232}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":179}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":106}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"CLAUDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":40}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":77}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":74}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"claw.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":125}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":218}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"claw.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":5}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":113}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":1}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":158}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":100}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":227}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":29}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":13}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD029"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 3; Actual: 4; Style: 1/2/3"},"level":"Info","category":null,"location":{"LineLocation":{"line":39}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":183}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD034"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Bare URL used"},"level":"Info","category":null,"location":{"LineLocation":{"line":213}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":371}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":208}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":198}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":159}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":440}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":185}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":143}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":51}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":232}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":103}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":202}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":246}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":26}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":69}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":185}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":208}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":286}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":145}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":118}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"CLAUDE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":21}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":312}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":79}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":11}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"CLAUDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":46}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":21}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":125}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":81}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":100}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":60}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":73}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":94}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/TODO.md","message":{"text":"Expected: 80; Actual: 106"},"level":"Info","category":null,"location":{"LineLocation":{"line":3}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":174}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":41}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":114}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":241}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":233}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":155}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"claw.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":230}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":218}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD036"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Emphasis used instead of a heading"},"level":"Info","category":null,"location":{"LineLocation":{"line":453}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"claw.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":33}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":313}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":169}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":161}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":63}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":95}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD034"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Bare URL used"},"level":"Info","category":null,"location":{"LineLocation":{"line":225}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":99}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":153}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":104}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"CLAUDE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":22}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":330}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":60}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD029"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 2; Actual: 10; Style: 1/2/3"},"level":"Info","category":null,"location":{"LineLocation":{"line":65}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":176}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Expected: 80; Actual: 173"},"level":"Info","category":null,"location":{"LineLocation":{"line":410}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":208}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":161}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":119}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":153}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":19}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":177}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":18}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":71}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":85}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":287}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD029"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 2; Style: 1/2/3"},"level":"Info","category":null,"location":{"LineLocation":{"line":31}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":129}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":83}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"claw.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":174}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":133}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD029"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 5; Actual: 13; Style: 1/2/3"},"level":"Info","category":null,"location":{"LineLocation":{"line":68}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":99}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":16}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"claw.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":160}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"claw.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":14}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":173}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Expected: 80; Actual: 107"},"level":"Info","category":null,"location":{"LineLocation":{"line":143}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/TODO.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":7}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":115}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/LOGGING_STANDARDS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":73}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":138}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":283}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD031"},"filename":"clean_arb_bot/TEST_REPORT.md","message":{"text":"Fenced code blocks should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":383}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Expected: 80; Actual: 98"},"level":"Info","category":null,"location":{"LineLocation":{"line":63}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":182}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":222}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Expected: 80; Actual: 157"},"level":"Info","category":null,"location":{"LineLocation":{"line":5}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":220}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":152}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":135}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":252}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":439}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD013"},"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","message":{"text":"Expected: 80; Actual: 101"},"level":"Info","category":null,"location":{"LineLocation":{"line":61}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":47}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD032"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Lists should be surrounded by blank lines"},"level":"Info","category":null,"location":{"LineLocation":{"line":117}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD036"},"filename":"clean_arb_bot/TODO.md","message":{"text":"Emphasis used instead of a heading"},"level":"Info","category":null,"location":{"LineLocation":{"line":91}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":56}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD026"},"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","message":{"text":"Punctuation: ':'"},"level":"Info","category":null,"location":{"LineLocation":{"line":142}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":316}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD040"},"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","message":{"text":"Fenced code blocks should have a language specified"},"level":"Info","category":null,"location":{"LineLocation":{"line":150}},"sourceId":null}},{"Issue":{"patternId":{"value":"markdownlint_MD022"},"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","message":{"text":"Expected: 1; Actual: 0; Below"},"level":"Info","category":null,"location":{"LineLocation":{"line":169}},"sourceId":null}},{"Issue":{"patternId":{"value":"Checkov_CKV_SECRET_6"},"filename":"clean_arb_bot/RECOMMENDED_CONFIG.env","message":{"text":"Base64 High Entropy String"},"level":"High","category":null,"location":{"LineLocation":{"line":15}},"sourceId":null}},{"Issue":{"patternId":{"value":"Semgrep_yaml.github-actions.security.third-party-action-not-pinned-to-commit-sha.third-party-action-not-pinned-to-commit-sha"},"filename":".github/workflows/codacy-autofix.yml","message":{"text":"An action sourced from a third-party repository on GitHub is not pinned to a full length commit SHA. Pinning an action to a full length commit SHA is currently the only way to use an action as an immutable release."},"level":"High","category":null,"location":{"LineLocation":{"line":45}},"sourceId":null}},{"Issue":{"patternId":{"value":"Semgrep_yaml.github-actions.security.third-party-action-not-pinned-to-commit-sha.third-party-action-not-pinned-to-commit-sha"},"filename":".github/workflows/codacy-autofix.yml","message":{"text":"An action sourced from a third-party repository on GitHub is not pinned to a full length commit SHA. Pinning an action to a full length commit SHA is currently the only way to use an action as an immutable release."},"level":"High","category":null,"location":{"LineLocation":{"line":30}},"sourceId":null}},{"Issue":{"patternId":{"value":"Semgrep_yaml.github-actions.security.third-party-action-not-pinned-to-commit-sha.third-party-action-not-pinned-to-commit-sha"},"filename":".github/workflows/codacy-autofix.yml","message":{"text":"An action sourced from a third-party repository on GitHub is not pinned to a full length commit SHA. Pinning an action to a full length commit SHA is currently the only way to use an action as an immutable release."},"level":"High","category":null,"location":{"LineLocation":{"line":97}},"sourceId":null}},{"Issue":{"patternId":{"value":"Semgrep_yaml.github-actions.security.third-party-action-not-pinned-to-commit-sha.third-party-action-not-pinned-to-commit-sha"},"filename":".github/workflows/codacy-analysis.yml","message":{"text":"An action sourced from a third-party repository on GitHub is not pinned to a full length commit SHA. Pinning an action to a full length commit SHA is currently the only way to use an action as an immutable release."},"level":"High","category":null,"location":{"LineLocation":{"line":68}},"sourceId":null}},{"Issue":{"patternId":{"value":"Semgrep_yaml.github-actions.security.third-party-action-not-pinned-to-commit-sha.third-party-action-not-pinned-to-commit-sha"},"filename":".github/workflows/codacy-analysis.yml","message":{"text":"An action sourced from a third-party repository on GitHub is not pinned to a full length commit SHA. Pinning an action to a full length commit SHA is currently the only way to use an action as an immutable release."},"level":"High","category":null,"location":{"LineLocation":{"line":86}},"sourceId":null}},{"Issue":{"patternId":{"value":"Semgrep_yaml.github-actions.security.third-party-action-not-pinned-to-commit-sha.third-party-action-not-pinned-to-commit-sha"},"filename":".github/workflows/codacy-analysis.yml","message":{"text":"An action sourced from a third-party repository on GitHub is not pinned to a full length commit SHA. Pinning an action to a full length commit SHA is currently the only way to use an action as an immutable release."},"level":"High","category":null,"location":{"LineLocation":{"line":27}},"sourceId":null}},{"DuplicationClone":{"cloneLines":";\n\n        // Split between base tx fee (70%) and compute fee (30%)\n        let base_tx_fee_lamports = (target_gas_lamports as f64 * 0.7) as u64;\n        let compute_fee_lamports = (target_gas_lamports as f64 * 0.3) as u64;\n\n        // Priority fee (only if not using JITO)\n        let priority_fee_lamports = if !use_jito {\n            // Scale priority fee with profit\n            if profit_sol < 0.1 {\n                50_000 // Small: standard priority\n            } else if profit_sol < 1.0 {\n                // Medium: scale from 50k to 150k\n                50_000 + ((profit_sol - 0.1) * 111_111.0) as u64\n            } else {\n                // Large: scale from 150k to 300k\n                150_000 + ((profit_sol - 1.0) * 150_000.0).min(150_000.0) as u64\n            }\n        } else {\n            0\n        };\n\n        // Use saturating_add to prevent overflow\n        let total_cost_lamports = dex_fee_lamports\n            .saturating_add(jito_tip_lamports)\n            .saturating_add(base_tx_fee_lamports)\n            .saturating_add(compute_fee_lamports)\n            .saturating_add(priority_fee_lamports);\n\n        // PRODUCTION LOGGING: Complete cost breakdown for monitoring\n        let profit_sol = expected_profit_lamports as f64 / 1e9;\n        let total_cost_sol = total_cost_lamports as f64 / 1e9;\n        let net_profit_sol = profit_sol - total_cost_sol;\n        let retention_pct = if expected_profit_lamports > 0 {\n            (net_profit_sol / profit_sol) * 100.0\n        } else {\n            0.0\n        };\n\n        debug!(\"???? Cost breakdown: Gross {:.6} SOL | Costs {:.6} SOL | Net {:.6} SOL ({:.1}% retention)\",\n               profit_sol, total_cost_sol, net_profit_sol, retention_pct);\n        debug!(\n            \"   DEX fees: {:.6} SOL, JITO tip: {:.6} SOL, Gas: {:.6} SOL, Priority: {:.6} SOL\",\n            dex_fee_lamports as f64 / 1e9,\n            jito_tip_lamports as f64 / 1e9,\n            (base_tx_fee_lamports + compute_fee_lamports) as f64 / 1e9,\n            priority_fee_lamports as f64 / 1e9\n        );\n\n        Self {\n            dex_fee_lamports,\n            jito_tip_lamports,\n            base_tx_fee_lamports,\n            compute_fee_lamports,\n            priority_fee_lamports,\n            total_cost_lamports,\n        }\n    }\n\n    /// Calculate minimum profitable gross profit\n    ///\n    /// Returns the minimum gross profit needed to cover all costs\n    /// and achieve desired net profit.\n    ///\n    /// # Arguments\n    /// * `desired_net_profit_lamports` - Target net profit after costs\n    /// * `use_jito` - Whether using JITO bundles\n    ///\n    /// # Returns\n    /// Minimum gross profit needed\n    ///\n    /// # Example\n    /// ```\n    /// // Want 0.1 SOL net profit using JITO\n    /// let min_gross = ArbitrageCosts::min_gross_profit_for_net(\n    ///     100_000_000, // 0.1 SOL desired net\n    ///     true,        // using JITO\n    /// );\n    /// // min_gross ??? 111,111,111 lamports (0.111 SOL)\n    /// // because: gross * 0.9 (after 10% tip) = 100M net\n    /// // so: gross = 100M / 0.9 = 111.11M\n    /// ```\n    pub fn min_gross_profit_for_net(desired_net_profit_lamports: u64, use_jito: bool)","nrTokens":0,"nrLines":83,"files":[{"filePath":"src/cost_calculator.rs","startLine":199,"endLine":281},{"filePath":"clean_arb_bot/src/cost_calculator.rs","startLine":195,"endLine":277}]}},{"DuplicationClone":{"cloneLines":"let pool_info = self.pool_registry\n            .get_pool(pool_short_id)\n            .ok_or_else(|| anyhow::anyhow!(\n                \"Pool {} resolved but info not cached. This shouldn't happen.\",\n                pool_short_id\n            ))?;\n\n        // Step 2: Fetch pool state from blockchain\n        let pool_state = self.fetch_pool_state(&pool_address)\n            .context(\"Failed to fetch pool state\")?;\n\n        debug!(\"??? Got pool state ({} bytes)\", pool_state.len());\n\n        // Step 3: Parse Orca Whirlpool state for critical data","nrTokens":0,"nrLines":14,"files":[{"filePath":"clean_arb_bot/src/orca.rs","startLine":111,"endLine":124},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":141,"endLine":154}]}},{"DuplicationClone":{"cloneLines":");\n\n        // Convert to base58 encoded strings\n        let encoded_transactions: Result<Vec<String>> = transactions\n            .iter()\n            .map(|tx| {\n                let serialized = bincode::serialize(tx)?;\n                Ok(bs58::encode(serialized).into_string())\n            })\n            .collect();\n\n        let encoded_transactions = encoded_transactions?;\n\n        // Create bundle","nrTokens":0,"nrLines":14,"files":[{"filePath":"clean_arb_bot/src/jito_bundle_client.rs","startLine":329,"endLine":342},{"filePath":"clean_arb_bot/src/jito_bundle_client.rs","startLine":243,"endLine":256}]}},{"DuplicationClone":{"cloneLines":")\n                            .await\n                        {\n                            Ok(addr) => addr,\n                            Err(_) => {\n                                // Try Stable if CLMM fails\n                                self.pool_registry\n                                    .resolve_pool_address(pool_short_id, &crate::types::DexType::RaydiumStable)\n                                    .await\n                                    .context(format!(\"Failed to resolve pool address for {} (tried AMM V4, CPMM, CLMM, Stable)\", pool_short_id))?\n                            }\n                        }\n                    }\n                }\n            }\n        };\n\n        debug!(\n            \"??? Resolved pool {} to address: {}\",\n            pool_short_id, pool_address\n        );\n\n        // GROK GHOST POOL SOLUTION - STEP 3: Early validation check (should be cached from arbitrage engine)\n        // This is a safety fallback - normally pools are validated before execution\n        if self.pool_registry.is_pool_valid_cached(pool_short_id).await != Some(true) {\n            // Rare case: validate on-demand if not cached\n            warn!(\n                \"?????? Pool {} not in cache, validating on-demand\",\n                pool_short_id\n            );\n            self.pool_registry\n                .validate_pools_batch(&[pool_short_id.to_string()])\n                .await?;\n\n            // Double-check after validation\n            if self.pool_registry.is_pool_valid_cached(pool_short_id).await != Some(true) {\n                return Err(anyhow::anyhow!(\n                    \"?????? Ghost pool detected: {} (failed validation)\",\n                    pool_short_id\n                ));\n            }\n        }\n\n        debug!(\"??? Pool validated (cached), proceeding to fetch state\");\n\n        // Get pool info for token mints\n        let pool_info = self.pool_registry.get_pool(pool_short_id).ok_or_else(|","nrTokens":0,"nrLines":47,"files":[{"filePath":"src/raydium.rs","startLine":109,"endLine":155},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":103,"endLine":143}]}},{"DuplicationClone":{"cloneLines":"::new(rpc_client, pool_registry).unwrap();\n\n        // Valid params\n        let valid = SwapParams {\n            amount_in: 100,\n            minimum_amount_out: 95,\n            expected_amount_out: Some(100),\n            swap_a_to_b: true,\n        };\n        assert!(builder.validate_swap_params(&valid).is_ok());\n\n        // Zero amount in\n        let zero_in = SwapParams {\n            amount_in: 0,\n            minimum_amount_out: 95,\n            expected_amount_out: Some(95),\n            swap_a_to_b: true,\n        };\n        assert!(builder.validate_swap_params(&zero_in).is_err());\n\n        // Zero minimum out\n        let zero_out = SwapParams {\n            amount_in: 100,\n            minimum_amount_out: 0,\n            expected_amount_out: Some(100),\n            swap_a_to_b: true,\n        };\n        assert!(builder.validate_swap_params(&zero_out).is_err());\n    }\n}","nrTokens":0,"nrLines":30,"files":[{"filePath":"clean_arb_bot/src/meteora.rs","startLine":489,"endLine":518},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":502,"endLine":531}]}},{"DuplicationClone":{"cloneLines":", pool_short_id);\n\n        // Get pool info\n        let pool_info = self.pool_registry\n            .get_pool(pool_short_id)\n            .ok_or_else(|| anyhow::anyhow!(\"Pool {} not found\", pool_short_id))?;\n\n        // Fetch pool state\n        let _pool_state = self.fetch_pool_state(&pool_info.full_address)?;\n\n        // Parse pool state to get current sqrt_price and liquidity","nrTokens":0,"nrLines":11,"files":[{"filePath":"clean_arb_bot/src/orca.rs","startLine":478,"endLine":488},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":431,"endLine":441}]}},{"DuplicationClone":{"cloneLines":";\nuse solana_sdk::transaction::Transaction;\nuse std::time::SystemTime;\nuse tonic::transport::{Channel, ClientTlsConfig};\nuse tonic::Request;\nuse tracing::{debug","nrTokens":0,"nrLines":6,"files":[{"filePath":"src/jito_grpc_client.rs","startLine":9,"endLine":14},{"filePath":"clean_arb_bot/src/jito_grpc_client.rs","startLine":8,"endLine":13}]}},{"DuplicationClone":{"cloneLines":"),\n        ];\n\n        for (name, program_id, fee_rate, supports_arb, min_liquidity) in configs {\n            if supports_arb {\n                dexs.insert(\n                    name.to_string(),\n                    DexInfo {\n                        name: name.to_string(),\n                        program_id: program_id.to_string(),\n                        fee_rate,\n                        supports_arbitrage: supports_arb,\n                        min_liquidity_threshold: min_liquidity,\n                    },","nrTokens":0,"nrLines":14,"files":[{"filePath":"src/dex_registry.rs","startLine":108,"endLine":121},{"filePath":"clean_arb_bot/src/dex_registry.rs","startLine":48,"endLine":59}]}},{"DuplicationClone":{"cloneLines":";\n\n/// Meteora DLMM swap instruction builder\npub struct MeteoraSwapBuilder {\n    /// RPC client for fetching pool state\n    rpc_client: Arc<SolanaRpcClient>,\n    /// Pool registry for address resolution\n    pool_registry: Arc<PoolRegistry>,\n    /// Meteora DLMM program ID\n    program_id: Pubkey,\n}\n\nimpl MeteoraSwapBuilder {\n    /// Meteora DLMM program ID on mainnet (Dynamic Liquidity Market Maker)\n    pub const PROGRAM_ID: &'static str = \"LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo\";\n\n    /// Meteora DAMM V1 program ID on mainnet (Dynamic Automated Market Maker V1)\n    pub const DAMM_V1_PROGRAM_ID: &'static str = \"Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB\";\n\n    /// Meteora DAMM V2 program ID on mainnet (Dynamic Automated Market Maker V2)\n    pub const DAMM_V2_PROGRAM_ID: &'static str = \"cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG\";\n\n    /// Create new Meteora swap builder\n    pub fn new(rpc_client: Arc<SolanaRpcClient>, pool_registry: Arc<PoolRegistry>)","nrTokens":0,"nrLines":24,"files":[{"filePath":"src/meteora.rs","startLine":13,"endLine":36},{"filePath":"clean_arb_bot/src/meteora.rs","startLine":16,"endLine":41}]}},{"DuplicationClone":{"cloneLines":")\n                            .await\n                            {\n                                Ok(Ok(uuid)) => {\n                                    info!(\"???? JITO bundle submitted via HTTP (fallback): {}\", uuid);\n                                    Ok(uuid)\n                                }\n                                Ok(Err(e)) => Err(e),\n                                Err(_) => Err(anyhow::anyhow!(\"HTTP fallback timeout\")),\n                            }\n                        }\n                    }\n                } else {\n                    // No gRPC - use HTTP only\n                    match tokio::time::timeout(\n                        Duration::from_secs(10),\n                        http_clone.submit_bundle_safe(request.transactions.clone()),","nrTokens":0,"nrLines":17,"files":[{"filePath":"src/jito_submitter.rs","startLine":190,"endLine":206},{"filePath":"clean_arb_bot/src/jito_submitter.rs","startLine":172,"endLine":187}]}},{"DuplicationClone":{"cloneLines":"// High-level swap executor coordinator\n//\n// Ties together all DEX swap components:\n// - RPC client for blockchain interaction\n// - Pool registry for address resolution\n// - Meteora swap builder for instruction generation\n// - JITO bundle client for atomic execution\n//\n// Provides simple API for arbitrage engine\n\nuse anyhow::{Context, Result};\nuse solana_sdk::{\n    compute_budget::ComputeBudgetInstruction, hash::Hash, instruction::Instruction, pubkey::Pubkey,\n    signature::Signature, signer::Signer, transaction::Transaction,\n};\nuse std::sync::Arc;\nuse tracing::{debug, info, warn};\n\nuse crate::jito_bundle_client","nrTokens":0,"nrLines":19,"files":[{"filePath":"src/swap_executor.rs","startLine":1,"endLine":19},{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":1,"endLine":24}]}},{"DuplicationClone":{"cloneLines":"};\nuse std::sync::Arc;\nuse tracing::{debug, info, warn};\n\nuse crate::pool_registry::PoolRegistry;\nuse crate::rpc_client::SolanaRpcClient;\nuse crate::types::SwapParams;\n\n/// Orca swap instruction builder (supports Whirlpools + Legacy)","nrTokens":0,"nrLines":9,"files":[{"filePath":"src/orca.rs","startLine":11,"endLine":19},{"filePath":"src/raydium.rs","startLine":16,"endLine":24}]}},{"DuplicationClone":{"cloneLines":"(\n                self.get_associated_token_address(user_pubkey, &pool_info.token_b_mint),\n                self.get_associated_token_address(user_pubkey, &pool_info.token_a_mint),\n            )\n        };\n\n        debug!(\"User token in: {}\", user_token_in);\n        debug!(\"User token out: {}\", user_token_out);\n\n        // Auto-create token accounts if they don't exist\n        let mut setup_instructions = Vec::new();\n\n        if !self.rpc_client.account_exists(&user_token_in)? {\n            info!(\"???? Creating associated token account for input token: {}\", user_token_in);\n\n            let token_mint = if swap_params.swap_a_to_b {\n                &pool_info.token_a_mint\n            } else {\n                &pool_info.token_b_mint\n            };\n\n            let create_ata_ix = spl_associated_token_account::instruction::create_associated_token_account(\n                user_pubkey,      // Payer\n                user_pubkey,      // Owner of new account\n                token_mint,       // Token mint\n                &spl_token::id(), // Token program ID\n            );\n\n            setup_instructions.push(create_ata_ix);\n            info!(\"??? ATA creation instruction added - account will be created in transaction\");\n        }\n\n        if !self.rpc_client.account_exists(&user_token_out)? {\n            info!(\"???? Creating associated token account for output token: {}\", user_token_out);\n\n            let token_mint = if swap_params.swap_a_to_b {\n                &pool_info.token_b_mint\n            } else {\n                &pool_info.token_a_mint\n            };\n\n            let create_ata_ix = spl_associated_token_account::instruction::create_associated_token_account(\n                user_pubkey,      // Payer\n                user_pubkey,      // Owner of new account\n                token_mint,       // Token mint\n                &spl_token::id(), // Token program ID\n            );\n\n            setup_instructions.push(create_ata_ix);\n            info!(\"??? ATA creation instruction added for output - account will be created in transaction\");\n        }\n\n        // Step 5: Derive tick array addresses (FIXED 2025-10-11)","nrTokens":0,"nrLines":53,"files":[{"filePath":"clean_arb_bot/src/orca.rs","startLine":179,"endLine":231},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":204,"endLine":256}]}},{"DuplicationClone":{"cloneLines":"};\n\n/// Populate pool registry with known Meteora DLMM pools\n///\n/// This function adds known pool addresses that we've seen in live trading.\n/// As we discover more pools through live data, we can add them here.\n///\n/// **CRITICAL**: You MUST populate this with actual pool addresses before live trading!\n/// The pool IDs shown in ShredStream are just 8-char prefixes, not full addresses.\npub fn populate_known_pools(pool_registry: Arc<PoolRegistry>) -> Result<()> {\n    info!(\"???? Populating pool registry with known Meteora DLMM pools...\");\n\n    // Top liquidity Meteora DLMM pools (queried from https://dlmm-api.meteora.ag/pair/all_by_groups)\n    // Updated: 2025-10-06\n\n    // 1. SOL-USDC (High Liquidity #1)\n    pool_registry.register_pool(\n        \"BGm1tav5\".to_string(),\n        PoolInfo {\n            full_address: \"BGm1tav58oGcsQJehL9WXBFXF7D27vZsKefj4xJKD5Y\".parse()?,\n            dex_type: DexType::MeteoraDammV2,\n            token_a_mint: \"So11111111111111111111111111111111111111112\".parse()?, // SOL\n            token_b_mint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".parse()?, // USDC\n            reserve_a: \"DwZz4S1Z1LBXomzmncQRVKCYhjCqSAMQ6RPKbUAadr7H\".parse()?,\n            reserve_b: \"4N22J4vW2juHocTntJNmXywSonYjkndCwahjZ2cYLDgb\".parse()?,\n        },","nrTokens":0,"nrLines":26,"files":[{"filePath":"src/pool_population.rs","startLine":15,"endLine":40},{"filePath":"clean_arb_bot/src/pool_population.rs","startLine":15,"endLine":41}]}},{"DuplicationClone":{"cloneLines":"), // 4. user_token_out\n        // Token mints (CRITICAL - these were missing!)\n        AccountMeta::new_readonly(token_x_mint, false), // 5. token_x_mint\n        AccountMeta::new_readonly(token_y_mint, false), // 6. token_y_mint\n        // Oracle\n        AccountMeta::new(oracle, false), // 7. oracle\n        // Note: host_fee_in is optional, skip for now\n\n        // Signer\n        AccountMeta::new_readonly(*user_wallet, true), // 8. user (signer)\n        // Token programs (CRITICAL - these were missing!)\n        AccountMeta::new_readonly(token_program_id(), false), // 9. token_x_program\n        AccountMeta::new_readonly(token_program_id(), false), // 10. token_y_program\n    ];\n\n    let instruction = Instruction {\n        program_id,\n        accounts,\n        data,\n    };\n\n    info!(\"??? Meteora swap instruction built successfully\");\n    Ok(instruction)\n}\n\n/// Execute Meteora swap transaction\npub async fn execute_meteora_swap(\n    rpc_client: Arc<SolanaRpcClient>,\n    pool_address: &str,\n    position_size_lamports: u64,\n    user_keypair: &Keypair,\n    slippage_tolerance: f64,\n    swap_for_y: bool,\n    cached_blockhash: Option<&crate::cached_blockhash::SharedCachedBlockhash>,\n) -> Result<String> {\n    info!(\"???? Executing Meteora swap...\");\n\n    // Build the swap instruction\n    let swap_ix = build_meteora_swap_instruction(\n        rpc_client.clone(),\n        pool_address,\n        position_size_lamports,\n        &user_keypair.pubkey(),\n        slippage_tolerance,\n        swap_for_y,\n    )\n    .await?;\n\n    // Create transaction\n    let mut transaction = Transaction::new_with_payer(&[swap_ix], Some(&user_keypair.pubkey()))","nrTokens":0,"nrLines":50,"files":[{"filePath":"src/meteora_swap.rs","startLine":148,"endLine":197},{"filePath":"clean_arb_bot/src/meteora_swap.rs","startLine":139,"endLine":193}]}},{"DuplicationClone":{"cloneLines":"};\n\n    transaction.sign(&[user_keypair], recent_blockhash);\n\n    // MANDATORY SIMULATION (Grok's safety recommendation)\n    info!(\"???? Simulating transaction...\");\n    let simulation_success = rpc_client\n        .simulate_transaction(&transaction)\n        .map_err(|e| anyhow!(\"Simulation failed: {}\", e))?;\n\n    if !simulation_success {\n        warn!(\"??? Simulation failed - transaction would revert on-chain\");\n        return Err(anyhow!(\n            \"Transaction would fail on-chain - simulation returned false\"\n        ));\n    }\n\n    info!(\"??? Simulation passed\");\n\n    // Send transaction\n    info!(\"???? Sending transaction to blockchain...\");\n    let signature = rpc_client\n        .send_transaction(&transaction)\n        .map_err(|e| anyhow!(\"Failed to send transaction: {}\", e))?;\n\n    info!(\"???? Swap executed successfully!\");\n    info!(\"   Signature: {}\", signature);\n\n    Ok(signature.to_string())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_swap_data_serialization() {\n        let data = SwapInstructionData {\n            amount_in: 1000000,\n            min_amount_out: 950000,\n        };\n\n        let serialized = data.try_to_vec().unwrap();\n        assert!(serialized.len() > 0);\n    }\n}","nrTokens":0,"nrLines":46,"files":[{"filePath":"src/meteora_swap.rs","startLine":207,"endLine":252},{"filePath":"clean_arb_bot/src/meteora_swap.rs","startLine":206,"endLine":247}]}},{"DuplicationClone":{"cloneLines":"token_b_mint: Pubkey::default(),\n                    reserve_a: Pubkey::default(),\n                    reserve_b: Pubkey::default(),\n                };\n                let _ = self.register_pool(short_id.to_string(), pool_info);\n\n                return Ok(full_address);\n            }\n            Err(e) => {\n                let","nrTokens":0,"nrLines":10,"files":[{"filePath":"clean_arb_bot/src/pool_registry.rs","startLine":293,"endLine":302},{"filePath":"clean_arb_bot/src/pool_registry.rs","startLine":222,"endLine":231}]}},{"DuplicationClone":{"cloneLines":"];\n        data.extend_from_slice(&swap_discriminator);\n\n        // Amount in (u64, 8 bytes, little-endian)\n        data.extend_from_slice(&swap_params.amount_in.to_le_bytes());\n\n        // Minimum amount out (u64, 8 bytes, little-endian)\n        data.extend_from_slice(&swap_params.minimum_amount_out.to_le_bytes());\n\n        let instruction = Instruction {\n            program_id: self.program_id,\n            accounts,\n            data,\n        };\n\n        debug!(\"Built Meteora instruction with {} accounts\"","nrTokens":0,"nrLines":16,"files":[{"filePath":"clean_arb_bot/src/meteora.rs","startLine":386,"endLine":401},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":403,"endLine":418}]}},{"DuplicationClone":{"cloneLines":")?;\n\n        Ok(transaction)\n    }\n\n    /// Build triangle transaction with JITO tip INCLUDED (SECURE METHOD)\n    ///\n    /// **CRITICAL SECURITY FIX**: This method includes the JITO tip INSIDE the same\n    /// transaction as the swap instructions, preventing uncle block unbundling.\n    ///\n    /// Per Jito docs: \"Always make sure your Jito tip transaction is in the same\n    /// transaction that is running the MEV strategy\"\n    ///\n    /// # Arguments\n    /// * `leg1` - First swap parameters\n    /// * `leg2` - Second swap parameters\n    /// * `leg3` - Third swap parameters\n    /// * `wallet` - User's wallet (signer)\n    /// * `tip_lamports` - Tip amount (minimum 1000 lamports)\n    /// * `tip_account` - Jito tip account pubkey\n    ///\n    /// # Returns\n    /// Complete signed transaction ready for JITO bundle submission\n    pub async fn build_triangle_with_tip<T: Signer>(\n        &self,\n        leg1: (&DexType, &str, &SwapParams),\n        leg2: (&DexType, &str, &SwapParams),\n        leg3: (&DexType, &str, &SwapParams),\n        wallet: &T,\n        tip_lamports: u64,\n        tip_account: &Pubkey,\n    ) -> Result<Transaction> {\n        let user_pubkey = wallet.pubkey();\n\n        // Build all three swap instructions (async for pool resolution)\n        let ix1 = self\n            .build_swap_instruction(leg1.0, leg1.1, leg1.2, &user_pubkey)\n            .await?;\n        let ix2 = self\n            .build_swap_instruction(leg2.0, leg2.1, leg2.2, &user_pubkey)\n            .await?;\n        let ix3 = self\n            .build_swap_instruction(leg3.0, leg3.1, leg3.2, &user_pubkey)\n            .await?;\n\n        info!(\"??? Built all 3 swap instructions\");\n\n        // Build JITO tip instruction\n        let tip_ix =\n            solana_sdk::system_instruction::transfer(&user_pubkey, tip_account, tip_lamports)","nrTokens":0,"nrLines":50,"files":[{"filePath":"src/swap_executor.rs","startLine":347,"endLine":396},{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":349,"endLine":394}]}},{"DuplicationClone":{"cloneLines":")?;\n\n        // Step 2: Fetch pool state from blockchain\n        let pool_state = self\n            .fetch_pool_state(&pool_address)\n            .context(\"Failed to fetch pool state\")?;\n\n        debug!(\"??? Got pool state ({} bytes)\", pool_state.len());\n\n        // Step 3: Parse Raydium CPMM pool state\n        // Raydium pool structure (simplified, based on raydium-amm program):\n        // The exact structure varies, but we need to extract:\n        // - Token vaults (coin and pc)\n        // - Pool authority (PDA)\n        // - Open orders account (if using Serum integration)\n        //\n        // For basic CPMM, we can derive the authority PDA and assume vault positions\n\n        if pool_state.len() < 300 {\n            return Err(anyhow::anyhow!(\n                \"Pool state too short ({} bytes). Expected at least 300 bytes for Raydium CPMM.\",\n                pool_state.len()\n            ));\n        }\n\n        // Parse critical addresses from pool state\n        // NOTE: These offsets are approximations based on typical Raydium pool structure\n        // In production, use the official raydium-amm crate or validated offsets\n\n        // Derive pool authority PDA\n        // Raydium uses a PDA with seeds [b\"amm authority\", pool_id]\n        let (pool_authority, _bump) = Pubkey::find_program_address(\n            &[b\"amm authority\", pool_address.as_ref()],\n            &self.program_id,\n        );\n\n        debug!(\"Pool Authority (PDA): {}\", pool_authority);\n\n        // For token vaults, we need to parse from pool state or derive\n        // In a basic implementation, we'll parse from known offsets\n        // Offset 40-72: pool_coin_token_account (32 bytes)\n        // Offset 72-104: pool_pc_token_account (32 bytes)\n        let pool_coin_vault = Pubkey::try_from(&pool_state[40..72])\n            .context(\"Failed to parse coin vault from pool state\")?;\n        let pool_pc_vault = Pubkey::try_from(&pool_state[72..104])\n            .context(\"Failed to parse pc vault from pool state\")?;\n\n        debug!(\"Pool Coin Vault: {}\", pool_coin_vault);\n        debug!(\"Pool PC Vault: {}\", pool_pc_vault);\n\n        // Step 4: Determine user token accounts\n        let (user_token_in, user_token_out) = if swap_params.swap_a_to_b {\n            // Swapping token A (coin) to token B (pc)\n            (\n                self.get_associated_token_address(user_pubkey, &pool_info.token_a_mint),\n                self.get_associated_token_address(user_pubkey, &pool_info.token_b_mint),\n            )\n        } else {\n            // Swapping token B (pc) to token A (coin)\n            (\n                self.get_associated_token_address(user_pubkey, &pool_info.token_b_mint),\n                self.get_associated_token_address(user_pubkey, &pool_info.token_a_mint),\n            )\n        };\n\n        debug!(\"User token in: {}\", user_token_in);\n        debug!(\"User token out: {}\", user_token_out);\n\n        // Auto-create token accounts if they don't exist\n        let mut setup_instructions = Vec::new();\n\n        if !self.rpc_client.account_exists(&user_token_in)? {\n            info!(\n                \"???? Creating associated token account for input token: {}\",\n                user_token_in\n            );\n\n            let token_mint = if swap_params.swap_a_to_b {\n                &pool_info.token_a_mint\n            } else {\n                &pool_info.token_b_mint\n            };\n\n            let create_ata_ix =\n                spl_associated_token_account::instruction::create_associated_token_account(\n                    user_pubkey,      // Payer\n                    user_pubkey,      // Owner of new account\n                    token_mint,       // Token mint\n                    &spl_token::id(), // Token program ID\n                );\n\n            setup_instructions.push(create_ata_ix);\n            info!(\"??? ATA creation instruction added - account will be created in transaction\");\n        }\n\n        if !self.rpc_client.account_exists(&user_token_out)? {\n            info!(\n                \"???? Creating associated token account for output token: {}\",\n                user_token_out\n            );\n\n            let token_mint = if swap_params.swap_a_to_b {\n                &pool_info.token_b_mint\n            } else {\n                &pool_info.token_a_mint\n            };\n\n            let create_ata_ix =\n                spl_associated_token_account::instruction::create_associated_token_account(\n                    user_pubkey,      // Payer\n                    user_pubkey,      // Owner of new account\n                    token_mint,       // Token mint\n                    &spl_token::id(), // Token program ID\n                );\n\n            setup_instructions.push(create_ata_ix);\n            info!(\"??? ATA creation instruction added for output - account will be created in transaction\");\n        }\n\n        // Step 5: Build Raydium CPMM swap instruction\n        let instruction = self.build_raydium_swap_ix(\n            &pool_address,\n            user_pubkey,\n            &user_token_in,\n            &user_token_out,\n            &pool_coin_vault,\n            &pool_pc_vault,\n            &pool_authority,\n            swap_params,\n        )?;\n\n        // Combine setup instructions (ATA creation) with swap instruction\n        let mut all_instructions = setup_instructions;\n        all_instructions.push(instruction);\n\n        if all_instructions.len() > 1 {\n            info!(\n                \"??? Built {} instructions ({} setup + 1 swap)\",\n                all_instructions.len(),\n                all_instructions.len() - 1\n            );\n        } else {\n            info!(\"??? Built Raydium CPMM swap instruction\");\n        }\n        info!(\"   Pool: {}\", pool_address);\n        info!(\"   Amount in: {} lamports\", swap_params.amount_in);\n        info!(\n            \"   Min amount out: {} lamports\",\n            swap_params.minimum_amount_out\n        );\n        info!(\n            \"   Direction: {}\",\n            if swap_params.swap_a_to_b {\n                \"Coin???PC\"\n            } else {\n                \"PC???Coin\"\n            }\n        );\n\n        // CRITICAL FIX: For now, we need to return a single instruction\n        // But we should log a warning if we're dropping ATA creation instructions\n        if all_instructions.len() > 1 {\n            warn!(\n                \"?????? CRITICAL: Dropping {} ATA creation instructions!\",\n                all_instructions.len() - 1\n            );\n            warn!(\"   This will cause transaction failures if ATAs don't exist\");\n            warn!(\"   TODO: Update function signature to return Vec<Instruction>\");\n        }\n\n        // Return the LAST instruction (the swap), not the first (which would be ATA creation)\n        Ok(all_instructions.into_iter().last().unwrap())\n    }\n\n    /// Fetch pool state from blockchain\n    fn fetch_pool_state(&self, pool_address: &Pubkey) -> Result<Vec<u8>> {\n        self.rpc_client\n            .get_account_data(pool_address)\n            .context(\"Failed to fetch Raydium pool state\")\n    }\n\n    /// Get associated token account address for user\n    fn get_associated_token_address(&self, wallet: &Pubkey, mint: &Pubkey) -> Pubkey {\n        spl_associated_token_account::get_associated_token_address(wallet, mint)\n    }\n\n    /// Build the actual Raydium swap instruction\n    ///\n    /// IMPORTANT: This implementation supports Raydium CPMM (simple constant product)\n    /// For AMM V4 pools with Serum integration, proper Serum accounts must be resolved\n    ///\n    /// Current Status (2025-10-11):\n    /// - ??? CPMM: Fixed discriminator, basic account structure works\n    /// - ?????? AMM V4: Serum accounts using placeholders (lines 334-357)\n    ///\n    /// For full AMM V4 support, need to:\n    /// 1. Fetch AMM state to get serum_market address\n    /// 2. Fetch Serum market state to get bids, asks, event_queue\n    /// 3. Derive vault_signer PDA from Serum market\n    ///\n    /// Reference: Raydium AMM program structure\n    fn build_raydium_swap_ix(\n        &self,\n        amm_id: &Pubkey,\n        user_authority: &Pubkey,\n        user_source_token: &Pubkey,\n        user_dest_token: &Pubkey,\n        pool_coin_token_account: &Pubkey,\n        pool_pc_token_account: &Pubkey,\n        amm_authority: &Pubkey,\n        swap_params: &SwapParams,\n    ) -> Result<Instruction> {\n        // Raydium CPMM swap instruction accounts\n        // Based on Raydium AMM v4 program structure\n        //\n        // Note: This is a simplified version for basic CPMM swaps\n        // Full integration may require additional accounts for Serum integration\n\n        // ACCOUNT STRUCTURE - Raydium AMM V4 / CPMM\n        //\n        // This is a hybrid account structure that works for CPMM (simple pools)\n        // but uses PLACEHOLDER accounts for Serum integration (AMM V4).\n        //\n        // For CPMM pools: This should work with fixed discriminator\n        // For AMM V4 pools: Needs proper Serum account resolution\n        //\n        // ?????? PLACEHOLDERS BELOW (accounts 3-4, 7-14):\n        // These are using amm_id, system_program, pool accounts as placeholders.\n        // For AMM V4 with Serum, these must be replaced with actual:\n        // - open_orders, target_orders from AMM state\n        // - serum_market, bids, asks, event_queue from Serum market\n        // - coin_vault, pc_vault, vault_signer from Serum market\n        let accounts = vec![\n            // 0. Token program\n            AccountMeta::new_readonly(spl_token::id(), false),\n            // 1. AMM ID (pool account)\n            AccountMeta::new(*amm_id, false),\n            // 2. AMM authority (PDA)\n            AccountMeta::new_readonly(*amm_authority, false),\n            // 3. AMM open orders (PLACEHOLDER: using amm_id for CPMM)\n            AccountMeta::new(*amm_id, false),\n            // 4. AMM target orders (PLACEHOLDER: using amm_id for CPMM)\n            AccountMeta::new(*amm_id, false),\n            // 5. Pool coin token account\n            AccountMeta::new(*pool_coin_token_account, false),\n            // 6. Pool pc token account\n            AccountMeta::new(*pool_pc_token_account, false),\n            // 7. Serum program ID (PLACEHOLDER: using system_program for CPMM)\n            AccountMeta::new_readonly(system_program::id(), false),\n            // 8. Serum market (PLACEHOLDER: using amm_id for CPMM)\n            AccountMeta::new(*amm_id, false),\n            // 9. Serum bids (PLACEHOLDER: using amm_id for CPMM)\n            AccountMeta::new(*amm_id, false),\n            // 10. Serum asks (PLACEHOLDER: using amm_id for CPMM)\n            AccountMeta::new(*amm_id, false),\n            // 11. Serum event queue (PLACEHOLDER: using amm_id for CPMM)\n            AccountMeta::new(*amm_id, false),\n            // 12. Serum coin vault (PLACEHOLDER: using pool coin for CPMM)\n            AccountMeta::new(*pool_coin_token_account, false),\n            // 13. Serum pc vault (PLACEHOLDER: using pool pc for CPMM)\n            AccountMeta::new(*pool_pc_token_account, false),\n            // 14. Serum vault signer (PLACEHOLDER: using amm authority for CPMM)\n            AccountMeta::new_readonly(*amm_authority, false),\n            // 15. User source token account\n            AccountMeta::new(*user_source_token, false),\n            // 16. User destination token account\n            AccountMeta::new(*user_dest_token, false),\n            // 17. User authority (signer)\n            AccountMeta::new_readonly(*user_authority, true),\n        ];\n\n        // Instruction data format for Raydium swap\n        // [discriminator: 8 bytes][amount_in: 8 bytes][min_amount_out: 8 bytes]\n        let mut data = Vec::new();\n\n        // RAYDIUM CPMM SWAP DISCRIMINATOR (FIXED 2025-10-11)\n        // Correct Anchor discriminator for \"global:swap_base_input\"\n        // Calculated: echo -n \"global:swap_base_input\" | sha256sum = 8fbe5adac41e33de...\n        //\n        // Note: Raydium CPMM uses \"swap_base_input\" (exact input amount specified)\n        // Alternative: \"swap_base_output\" = [0x37, 0xd9, 0x62, 0x56, 0xa3, 0x4a, 0xb4, 0xad]\n        //\n        // CRITICAL: This is for CPMM only. AMM V4 uses different instruction format.\n        let swap_discriminator: [u8; 8] = [0x8f, 0xbe, 0x5a, 0xda, 0xc4, 0x1e, 0x33, 0xde];\n        data.extend_from_slice(&swap_discriminator);\n\n        // Amount in (u64, 8 bytes, little-endian)\n        data.extend_from_slice(&swap_params.amount_in.to_le_bytes());\n\n        // Minimum amount out (u64, 8 bytes, little-endian)\n        data.extend_from_slice(&swap_params.minimum_amount_out.to_le_bytes());\n\n        let instruction = Instruction {\n            program_id: self.program_id,\n            accounts,\n            data,\n        };\n\n        debug!(\n            \"Built Raydium CPMM instruction with {} accounts\",\n            instruction.accounts.len()\n        );\n        debug!(\"Instruction data length: {} bytes\", instruction.data.len());\n\n        Ok(instruction)\n    }\n\n    /// Estimate output amount for a swap (useful for slippage calculation)\n    pub fn estimate_swap_output(\n        &self,\n        pool_short_id: &str,\n        amount_in: u64,\n        _swap_a_to_b: bool,\n    ) -> Result<u64> {\n        debug!(\"Estimating swap output for Raydium pool: {}\", pool_short_id);\n\n        // Get pool info\n        let pool_info = self\n            .pool_registry\n            .get_pool(pool_short_id)\n            .ok_or_else(|| anyhow::anyhow!(\"Pool {} not found\", pool_short_id))?;\n\n        // Fetch pool state\n        let _pool_state = self.fetch_pool_state(&pool_info.full_address)?;\n\n        // Parse pool reserves and calculate output using x*y=k formula\n        // For now, return a conservative estimate\n        let estimated_output = amount_in * 99 / 100; // Assume 1% slippage\n\n        warn!(\"?????? Using conservative estimate (1% slippage)\");\n        warn!(\"   Production should use actual pool reserves for CPMM calculation: (x*y=k)\");\n\n        Ok(estimated_output)\n    }\n\n    /// Calculate slippage percentage\n    pub fn calculate_slippage(expected: u64, minimum: u64) -> f64 {\n        if expected == 0 {\n            return 0.0;\n        }\n        let difference = expected.saturating_sub(minimum) as f64;\n        (difference / expected as f64) * 100.0\n    }\n\n    /// Validate swap parameters\n    pub fn validate_swap_params(&self, params: &SwapParams) -> Result<()> {\n        if params.amount_in == 0 {\n            return Err(anyhow::anyhow!(\"Amount in cannot be zero\"));\n        }\n\n        if params.minimum_amount_out == 0 {\n            return Err(anyhow::anyhow!(\"Minimum amount out cannot be zero\"));\n        }\n\n        if params.minimum_amount_out > params.amount_in * 10 {\n            return Err(anyhow::anyhow!(\n                \"Minimum amount out suspiciously high ({}x input). Check parameters.\",\n                params.minimum_amount_out / params.amount_in\n            ));\n        }\n\n        let slippage = Self::calculate_slippage(params.amount_in, params.minimum_amount_out);\n        if slippage > 50.0 {\n            warn!(\"?????? High slippage tolerance: {:.2}%\", slippage);\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_slippage_calculation() {\n        assert_eq!(RaydiumSwapBuilder::calculate_slippage(100, 95), 5.0);\n        assert_eq!(RaydiumSwapBuilder::calculate_slippage(1000, 950), 5.0);\n        assert_eq!(RaydiumSwapBuilder::calculate_slippage(100, 100), 0.0);\n    }\n\n    #[test]\n    fn test_swap_params_validation() {\n        let rpc_url = \"https://api.mainnet-beta.solana.com\".to_string();\n        let rpc_client = Arc::new(SolanaRpcClient::new(rpc_url));\n        let pool_registry = Arc::new(PoolRegistry::new(rpc_client.clone()));\n        let builder = RaydiumSwapBuilder::new(rpc_client, pool_registry).unwrap();\n\n        // Valid params\n        let valid = SwapParams {\n            amount_in: 100,\n            minimum_amount_out: 95,\n            expected_amount_out: Some(100),\n            swap_a_to_b: true,\n        };\n        assert!(builder.validate_swap_params(&valid).is_ok());\n\n        // Zero amount in\n        let zero_in = SwapParams {\n            amount_in: 0,\n            minimum_amount_out: 95,\n            expected_amount_out: Some(95),\n            swap_a_to_b: true,\n        };\n        assert!(builder.validate_swap_params(&zero_in).is_err());\n\n        // Zero minimum out\n        let zero_out = SwapParams {\n            amount_in: 100,\n            minimum_amount_out: 0,\n            expected_amount_out: Some(100),\n            swap_a_to_b: true,\n        };\n        assert!(builder.validate_swap_params(&zero_out).is_err());\n    }\n}","nrTokens":0,"nrLines":416,"files":[{"filePath":"src/raydium.rs","startLine":160,"endLine":575},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":146,"endLine":531}]}},{"DuplicationClone":{"cloneLines":",\n    ) -> Result<Transaction> {\n        let user_pubkey = wallet.pubkey();\n\n        // Build all three swap instructions (async for pool resolution)\n        let ix1 = self.build_swap_instruction(leg1.0, leg1.1, leg1.2, &user_pubkey).await?;\n        let ix2 = self.build_swap_instruction(leg2.0, leg2.1, leg2.2, &user_pubkey).await?;\n        let ix3 = self.build_swap_instruction(leg3.0, leg3.1, leg3.2, &user_pubkey).await?;\n\n        info!","nrTokens":0,"nrLines":10,"files":[{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":379,"endLine":388},{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":332,"endLine":276}]}},{"DuplicationClone":{"cloneLines":"};\nuse serde::Deserialize;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse tokio::sync::Mutex;\nuse tracing::{debug, info, warn};\n\n/// Jupiter Quote API response\n#[derive(Debug, Deserialize)]\npub struct JupiterQuoteResponse {\n    #[serde(rename = \"inputMint\")]\n    pub input_mint: String,\n\n    #[serde(rename = \"outputMint\")]\n    pub output_mint: String,\n\n    #[serde(rename = \"inAmount\")]\n    pub in_amount: String,\n\n    #[serde(rename = \"outAmount\")]\n    pub out_amount: String,\n\n    #[serde(rename = \"routePlan\")]\n    pub route_plan: Vec<RoutePlanItem>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct RoutePlanItem {\n    #[serde(rename = \"swapInfo\")]\n    pub swap_info: SwapInfo,\n}\n\n#[derive(Debug, Deserialize)]\npub struct SwapInfo {\n    #[serde(rename = \"ammKey\")]\n    pub amm_key: String,\n\n    #[serde(rename = \"label\")]\n    pub label: Option<String>,\n\n    #[serde(rename = \"inputMint\")]\n    pub input_mint: String,\n\n    #[serde(rename = \"outputMint\")]\n    pub output_mint: String,\n\n    #[serde(rename = \"inAmount\")]\n    pub in_amount: String,\n\n    #[serde(rename = \"outAmount\")]\n    pub out_amount: String,\n}\n\n/// Triangle arbitrage opportunity found via Jupiter\n#[derive(Debug, Clone)]\npub struct JupiterTriangleOpportunity {\n    pub input_amount_sol: f64,\n    pub output_amount_sol: f64,\n    pub profit_sol: f64,\n    pub profit_percentage: f64,\n    pub route_hops: usize,\n    pub route_description: String,\n}\n\n/// Rate limiter for Jupiter API\nstruct RateLimiter {\n    requests: Vec<Instant>,\n    max_requests: usize,\n    window_duration: Duration,\n}\n\nimpl RateLimiter {\n    fn new(max_requests: usize, window_seconds: u64) -> Self {\n        Self {\n            requests: Vec::new(),\n            max_requests,\n            window_duration: Duration::from_secs(window_seconds),\n        }\n    }\n\n    /// Check if we can make a request, and wait if needed\n    async fn acquire(&mut self) {\n        let now = Instant::now();\n\n        // Remove old requests outside the window\n        self.requests\n            .retain(|&t| now.duration_since(t) < self.window_duration);\n\n        // If at limit, wait until oldest request expires\n        if self.requests.len() >= self.max_requests {\n            if let Some(&oldest) = self.requests.first() {\n                let wait_time = self\n                    .window_duration\n                    .checked_sub(now.duration_since(oldest))\n                    .unwrap_or(Duration::from_millis(100));\n\n                debug!(\"??? Rate limit reached, waiting {:?}\", wait_time);\n                tokio::time::sleep(wait_time).await;\n            }\n        }\n\n        // Add current request\n        self.requests.push(Instant::now());\n    }\n}\n\n/// Jupiter Triangle Arbitrage Detector with rate limiting\npub struct JupiterTriangleDetector {\n    client: reqwest::Client,\n    api_key: Option<String>,\n    rate_limiter: Arc<Mutex<RateLimiter>>,\n    sol_mint: String,\n}\n\nimpl JupiterTriangleDetector {\n    pub fn new(api_key: Option<String>) -> Self {\n        // Rate limit: 50 requests per 10 seconds (rolling window)\n        let rate_limiter = Arc::new(Mutex::new(RateLimiter::new(50, 10)));\n\n        Self {\n            client: reqwest::Client::new(),\n            api_key,\n            rate_limiter,\n            sol_mint: \"So11111111111111111111111111111111111111112\".to_string(),\n        }\n    }\n\n    /// Find triangle arbitrage opportunities: SOL ??? ? ??? ? ??? SOL\n    /// Uses Jupiter's routing to find best multi-hop paths back to SOL\n    pub async fn find_triangle_opportunities(\n        &self,\n        capital_sol: f64,\n        config: &crate::config::Config,\n    ) -> Result<Vec<JupiterTriangleOpportunity>> {\n        let mut opportunities = Vec::new();\n\n        // Convert SOL to lamports for Jupiter API\n        let amount_lamports = (capital_sol * 1e9) as u64;\n\n        // Query Jupiter for best SOL ??? SOL route\n        // Jupiter will automatically find multi-hop paths\n        if let Some(opportunity) = self.find_sol_to_sol_route(amount_lamports, config).await? {\n            opportunities.push(opportunity);\n        }\n\n        Ok(opportunities)\n    }\n\n    /// Query Jupiter for SOL ??? SOL route (multi-hop triangle)\n    async fn find_sol_to_sol_route(\n        &self,\n        amount_lamports: u64,\n        config: &crate::config::Config,\n    ) -> Result<Option<JupiterTriangleOpportunity>> {\n        // Acquire rate limit slot\n        self.rate_limiter.lock().await.acquire().await;\n\n        // Build Jupiter Ultra API URL\n        // Using api.jup.ag/ultra endpoint (requires API key, dynamic rate limits)\n        let url = format!(\n            \"https://api.jup.ag/ultra/v1/order?inputMint={}&outputMint={}&amount={}&taker=11111111111111111111111111111111\",\n            self.sol_mint,\n            self.sol_mint,\n            amount_lamports\n        );\n\n        debug!(\"???? Querying Jupiter Ultra API for SOL???SOL triangle route\");\n\n        // Make request with API key\n        let mut request = self.client.get(&url);\n        if let Some(ref key) = self.api_key {\n            request = request.header(\"X-API-Key\", key);\n        }\n        let request = request;\n\n        match request.send().await {\n            Ok(response) => {\n                if !response.status().is_success() {\n                    let status = response.status();\n                    let text = response.text().await.unwrap_or_default();\n                    warn!(\"??? Jupiter API error {}: {}\", status, text);\n                    return Ok(None);\n                }\n\n                let quote: JupiterQuoteResponse = response.json().await?;\n\n                // Parse amounts with error context\n                let in_amount: u64 = quote.in_amount.parse().context(format!(\n                    \"Failed to parse Jupiter quote in_amount: {}\",\n                    quote.in_amount\n                ))?;\n                let out_amount: u64 = quote.out_amount.parse().context(format!(\n                    \"Failed to parse Jupiter quote out_amount: {}\",\n                    quote.out_amount\n                ))?;\n\n                let input_sol = in_amount as f64 / 1e9;\n                let output_sol = out_amount as f64 / 1e9;\n                let gross_profit = output_sol - input_sol;\n                let profit_pct = (gross_profit / input_sol) * 100.0;\n\n                // Build route description\n                let route_desc = self.build_route_description(&quote.route_plan);\n\n                // Calculate total fees (JITO tip + gas + compute)\n                let total_fees = config.calculate_total_fees(gross_profit);\n                let net_profit = gross_profit - total_fees;\n\n                // Calculate required margin (UPDATED 2025-10-11)\n                // NEW: fees + 0.5% of gross profit (user requirement)\n                let required_margin = 0.005 * gross_profit; // 0.5% of gross as safety margin\n                let min_acceptable = total_fees + required_margin;\n\n                debug!(\n                    \"???? Jupiter route: {} ??? Gross={:.6} SOL, Fees={:.6} SOL, Net={:.6} SOL ({:.2}%)\",\n                    route_desc, gross_profit, total_fees, net_profit, profit_pct\n                );\n\n                // Check if profitable with required margin\n                if net_profit >= min_acceptable {\n                    info!(\n                        \"???? Found Jupiter triangle: {} - Net profit {:.6} SOL after fees ({:.2}%)\",\n                        route_desc, net_profit, profit_pct\n                    );\n\n                    return Ok(Some(JupiterTriangleOpportunity {\n                        input_amount_sol: input_sol,\n                        output_amount_sol: output_sol,\n                        profit_sol: net_profit, // Store NET profit (after all fees)\n                        profit_percentage: profit_pct,\n                        route_hops: quote.route_plan.len(),\n                        route_description: route_desc,\n                    }));\n                }\n\n                Ok(None)\n            }\n            Err(e) => {\n                warn!(\"??? Jupiter API request failed: {}\", e);\n                Ok(None)\n            }\n        }\n    }\n\n    /// Build human-readable route description\n    fn build_route_description(&self, route_plan: &[RoutePlanItem]) -> String {\n        let mut parts = Vec::new();\n\n        for item in route_plan {\n            if let Some(ref label) = item.swap_info.label {\n                parts.push(label.clone());\n            } else {\n                parts.push(\"Unknown DEX\".to_string());\n            }\n        }\n\n        if parts.is_empty() {\n            \"SOL???SOL\".to_string()\n        } else {\n            format!(\"SOL???{}???SOL ({} hops)\", parts.join(\"???\"), parts.len())\n        }\n    }\n}","nrTokens":0,"nrLines":263,"files":[{"filePath":"src/jupiter_triangle.rs","startLine":1,"endLine":263},{"filePath":"clean_arb_bot/src/jupiter_triangle.rs","startLine":1,"endLine":257}]}},{"DuplicationClone":{"cloneLines":");\n\n        // Sign transaction\n        transaction.sign(&[wallet], recent_blockhash);\n\n        debug!(\n            \"??? Built transaction with {} instructions\",\n            instructions.len()\n        );\n\n        Ok(transaction)\n    }\n\n    /// Set compute unit price (micro-lamports per compute unit)\n    pub fn set_compute_unit_price(&mut self, price: u64) {\n        self.compute_unit_price = price;\n        debug!(\"Set compute unit price: {} micro-lamports\", price);\n    }\n\n    /// Set compute unit limit\n    pub fn set_compute_unit_limit(&mut self, limit: u32) {\n        self.compute_unit_limit = limit;\n        debug!(\"Set compute unit limit: {} CUs\", limit);\n    }\n\n    /// Estimate swap output (for slippage calculation)\n    pub fn estimate_swap_output(\n        &self,\n        dex_type: &DexType,\n        pool_short_id: &str,\n        amount_in: u64,\n        swap_a_to_b: bool,\n    ) -> Result<u64> {\n        match dex_type {\n            // Meteora variants (all use same builder)\n            DexType::MeteoraDammV1 | DexType::MeteoraDammV2 | DexType::MeteoraDlmm => self","nrTokens":0,"nrLines":36,"files":[{"filePath":"src/swap_executor.rs","startLine":670,"endLine":705},{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":636,"endLine":668}]}},{"DuplicationClone":{"cloneLines":"]\n        });\n\n        // Get current endpoint\n        let current_endpoint = {\n            let index = *self.current_endpoint_index.lock().unwrap();\n            let endpoints = self.endpoints.lock().unwrap();\n            endpoints[index].clone()\n        };\n\n        let response = timeout(\n            Duration::from_secs(5","nrTokens":0,"nrLines":12,"files":[{"filePath":"clean_arb_bot/src/jito_bundle_client.rs","startLine":732,"endLine":743},{"filePath":"clean_arb_bot/src/jito_bundle_client.rs","startLine":674,"endLine":685}]}},{"DuplicationClone":{"cloneLines":")\n            };\n\n        // FIX 3: Sanity check for impossible profits\n        // Reject if profit is negative OR impossibly high (bad price data)\n        // Filter 2: Maximum realistic profit for arbitrage\n        // UPDATED 2025-10-13: Increased to 20% for PumpSwap bonding curve pools\n        // PumpSwap has lower liquidity and uses bonding curves, so larger spreads are realistic\n        // Traditional AMMs: 0.01-2% typical, PumpSwap: 5-20% possible\n        const MAX_REALISTIC_PROFIT_PCT: f64 = 20.0;\n\n        if profit_sol <= 0.0 {\n            return None; // No profit or loss\n        }\n\n        let profit_percentage = (profit_sol / capital_sol) * 100.0;\n\n        if profit_percentage > MAX_REALISTIC_PROFIT_PCT {\n            debug!(\n                \"?????? Rejecting {}: Profit {:.2}% too high (realistic max: {}%) - likely bad data or no liquidity\",\n                &token_mint[..8], profit_percentage, MAX_REALISTIC_PROFIT_PCT\n            );\n            return None;\n        }\n\n        if profit_sol > 0.0 {\n            Some(TriangleOpportunity {\n                path: vec![\n                    \"SOL\".to_string(),\n                    token_mint[..8].to_string(),\n                    \"SOL\".to_string(),\n                ],\n                dexs: vec![buy_dex.clone(), sell_dex.clone()]","nrTokens":0,"nrLines":33,"files":[{"filePath":"src/triangle_arbitrage.rs","startLine":325,"endLine":357},{"filePath":"clean_arb_bot/src/triangle_arbitrage.rs","startLine":303,"endLine":338}]}},{"DuplicationClone":{"cloneLines":";\nuse tracing::{info, warn};\n\n// Meteora LB-CLMM program ID (mainnet)\npub const LB_CLMM_PROGRAM_ID: &str = \"LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo\";\n\n// Event authority for Meteora (standard PDA)\npub const EVENT_AUTHORITY: &str = \"6XzaKuAwqP7Nn37vwRdUqpuzNXknkBqjWq3c3h8qQXhE\";\n\n/// Swap instruction data for Meteora LB-CLMM\n#[derive(BorshSerialize, BorshDeserialize)]\nstruct SwapInstructionData {\n    /// Amount to swap in\n    amount_in: u64,\n    /// Minimum amount out (with slippage)\n    min_amount_out: u64,\n}\n\n/// Fetch token mint addresses from pool\nasync fn get_pool_token_mints(\n    rpc_client: &SolanaRpcClient,\n    pool_address: &Pubkey,\n) -> Result<(Pubkey, Pubkey)> {\n    // Fetch pool account data\n    let account_data = rpc_client\n        .get_account_data(pool_address)\n        .map_err(|e| anyhow!(\"Failed to fetch pool account: {}\", e))?;\n\n    // For Meteora LB pair, token mints are at specific offsets in account data\n    // This is a simplified version - in production, deserialize the full LbPair struct\n    if account_data.len() < 128 {\n        return Err(anyhow!(\"Invalid pool account data\"));\n    }\n\n    // Token X mint is at offset 8 (after discriminator)\n    let token_x_bytes = &account_data[8..40];\n    let token_x_mint =\n        Pubkey::try_from(token_x_bytes).map_err(|_| anyhow!(\"Invalid token X mint bytes\"))?;\n\n    // Token Y mint is at offset 40\n    let token_y_bytes = &account_data[40..72];\n    let token_y_mint =\n        Pubkey::try_from(token_y_bytes).map_err(|_| anyhow!(\"Invalid token Y mint bytes\"))?;\n\n    Ok((token_x_mint, token_y_mint))\n}\n\n/// Build Meteora swap instruction manually\npub async fn build_meteora_swap_instruction(\n    rpc_client: Arc<SolanaRpcClient>,\n    pool_address: &str,\n    position_size_lamports: u64,\n    user_wallet: &Pubkey,\n    slippage_tolerance: f64,\n    swap_for_y: bool, // true = X to Y, false = Y to X\n) -> Result<Instruction> {\n    info!(\"??????? Building Meteora swap instruction:\");\n    info!(\"   Pool: {}\", pool_address);\n    info!(\"   Amount: {} lamports\", position_size_lamports);\n    info!(\"   Slippage: {}%\", slippage_tolerance * 100.0);\n\n    let lb_pair = Pubkey::from_str(pool_address)?;\n    let program_id = Pubkey::from_str(LB_CLMM_PROGRAM_ID)?;\n\n    // Get token mints from pool\n    let (token_x_mint, token_y_mint) = get_pool_token_mints(&rpc_client, &lb_pair).await?;\n\n    info!(\"???? Pool tokens:\");\n    info!(\"   Token X: {}\", token_x_mint);\n    info!(\"   Token Y: {}\", token_y_mint);\n\n    // Get user's token accounts (ATAs)\n    let user_token_x = get_associated_token_address(user_wallet, &token_x_mint);\n    let user_token_y = get_associated_token_address(user_wallet, &token_y_mint);\n\n    // Calculate minimum amount out with slippage protection\n    let min_amount_out = (position_size_lamports as f64 * (1.0 - slippage_tolerance)) as u64;\n\n    info!(\"???? Trade parameters:\");\n    info!(\"   Input: {} lamports\", position_size_lamports);\n    info!(\"   Min output: {} lamports\", min_amount_out);\n    info!(\n        \"   Direction: {} -> {}\",\n        if swap_for_y { \"X\" } else { \"Y\" },\n        if swap_for_y { \"Y\" } else { \"X\" }\n    );\n\n    // Derive reserve PDAs (standard derivation for Meteora)\n    let (reserve_x, _) =\n        Pubkey::find_program_address(&[b\"reserve_x\", lb_pair.as_ref()], &program_id)","nrTokens":0,"nrLines":90,"files":[{"filePath":"src/meteora_swap.rs","startLine":16,"endLine":105},{"filePath":"clean_arb_bot/src/meteora_swap.rs","startLine":16,"endLine":103}]}},{"DuplicationClone":{"cloneLines":"use std::collections::HashMap;\nuse tracing::{debug, info};\n\nuse crate::shredstream_client::TokenPrice;\n\n/// Simple triangle opportunity detected from ShredStream data\n#[derive(Debug, Clone)]\npub struct SimpleTriangleOpportunity {\n    pub token_a_mint: String,\n    pub token_b_mint: String,\n    pub dex_1: String, // SOL ??? TokenA\n    pub dex_2: String, // TokenA ??? TokenB\n    pub dex_3: String, // TokenB ??? SOL\n\n    // GHOST POOL FIX: Full 44-char pool addresses from ShredStream\n    pub pool_1_address: String, // Full address for SOL ??? TokenA pool\n    pub pool_3_address: String, // Full address for TokenB ??? SOL pool\n\n    pub profit_sol: f64,\n    pub profit_percentage: f64,\n    pub input_amount_sol: f64,\n}\n\n/// Simple triangle detector using only ShredStream price data\n/// Detects: SOL ??? TokenA ??? TokenB ??? SOL\npub struct SimpleTriangleDetector {\n    sol_mint: String,\n}\n\nimpl SimpleTriangleDetector {\n    pub fn new() -> Self {\n        Self {\n            sol_mint: \"So11111111111111111111111111111111111111112\".to_string(),\n        }\n    }\n\n    /// Find triangle opportunities from ShredStream prices\n    /// Strategy: Find pairs where SOL ??? A ??? B ??? SOL is profitable\n    pub fn find_opportunities(\n        &self,\n        prices: &HashMap<String, TokenPrice>,\n        capital_sol: f64,\n        config: &crate::config::Config,\n    ) -> Vec<SimpleTriangleOpportunity> {\n        let mut opportunities = Vec::new();\n\n        // Group prices by token mint\n        let mut token_prices: HashMap<String, Vec<&TokenPrice>> = HashMap::new();\n        for price in prices.values() {\n            token_prices\n                .entry(price.token_mint.clone())\n                .or_insert_with(Vec::new)\n                .push(price);\n        }\n\n        // Filter out spam/dead tokens with too many pools\n        // Real tokens typically have 1-10 pools across DEXes\n        // Tokens with 50+ pools are likely spam, dead PumpFun tokens, or data errors\n        const MAX_POOLS_PER_TOKEN: usize = 50;\n        token_prices.retain(|token_mint, prices_list| {\n            let pool_count = prices_list.len();\n            if pool_count > MAX_POOLS_PER_TOKEN {\n                debug!(\n                    \"???? Filtering out spam token {} with {} pools (max: {})\",\n                    &token_mint[0..8.min(token_mint.len())],\n                    pool_count,\n                    MAX_POOLS_PER_TOKEN\n                );\n                false\n            } else {\n                true\n            }\n        });\n\n        // Get all tokens with SOL pairs\n        let tokens_with_sol_pairs: Vec<&String> = token_prices.keys().collect();\n\n        debug!(\n            \"???? Scanning {} tokens for triangle paths\",\n            tokens_with_sol_pairs.len()\n        );\n\n        // Try all combinations: SOL ??? TokenA ??? TokenB ??? SOL\n        for (i, token_a_mint) in tokens_with_sol_pairs.iter().enumerate() {\n            if *token_a_mint == &self.sol_mint {\n                continue;\n            }\n\n            // Check first 500 tokens (increased from 100 to find more opportunities)\n            if i >= 500 {\n                break;\n            }\n\n            let token_a_prices = &token_prices[*token_a_mint];\n\n            for token_b_mint in &tokens_with_sol_pairs {\n                if token_b_mint == token_a_mint || *token_b_mint == &self.sol_mint {\n                    continue;\n                }\n\n                let token_b_prices = &token_prices[*token_b_mint];\n\n                // Try to find a profitable path\n                if let Some(opp) = self.calculate_triangle_profit(\n                    token_a_mint,\n                    token_b_mint,\n                    token_a_prices,\n                    token_b_prices,\n                    capital_sol,\n                    config,\n                ) {\n                    opportunities.push(opp);\n\n                    // Limit to 50 opportunities (increased to see more)\n                    if opportunities.len() >= 50 {\n                        return opportunities;\n                    }\n                }\n            }\n        }\n\n        if !opportunities.is_empty() {\n            info!(\"???? Found {} triangle opportunities\", opportunities.len());\n        }\n\n        opportunities\n    }\n\n    /// Calculate profit for SOL ??? TokenA ??? TokenB ??? SOL\n    fn calculate_triangle_profit(\n        &self,\n        token_a_mint: &str,\n        token_b_mint: &str,\n        token_a_prices: &[&TokenPrice],\n        token_b_prices: &[&TokenPrice],\n        capital_sol: f64,\n        config: &crate::config::Config,\n    ) -> Option<SimpleTriangleOpportunity> {\n        // Try all combinations of DEXs\n        for price_a in token_a_prices {\n            for price_b in token_b_prices {\n                // Step 1: SOL ??? TokenA\n                let fee_1 = 0.003; // 0.3% typical DEX fee\n                let token_a_amount = (capital_sol * (1.0 - fee_1)) / price_a.price_sol;\n\n                // Step 2: TokenA ??? TokenB\n                // We need to know the TokenA/TokenB price\n                // Approximate: value_in_sol / price_b\n                let token_a_value_sol = token_a_amount * price_a.price_sol;\n                let fee_2 = 0.003;\n                let token_b_amount = (token_a_value_sol * (1.0 - fee_2)) / price_b.price_sol;\n\n                // Step 3: TokenB ??? SOL\n                let fee_3 = 0.003;\n                let sol_received = token_b_amount * price_b.price_sol * (1.0 - fee_3);\n\n                // Gross profit after DEX fees (0.9% total)\n                let gross_profit = sol_received - capital_sol;\n                let profit_pct = (gross_profit / capital_sol) * 100.0;\n\n                // Calculate total fees (JITO tip + gas + compute)\n                let total_fees = config.calculate_total_fees(gross_profit);\n\n                // Calculate net profit after ALL fees\n                let net_profit = gross_profit - total_fees;\n\n                // Calculate required margin (UPDATED 2025-10-11)\n                // NEW: total_fees + 0.5% of gross profit (user requirement)\n                // OLD: total_fees * 1.2 (20% margin - too conservative)\n                let required_margin = 0.005 * gross_profit; // 0.5% of gross as safety margin\n                let min_acceptable = total_fees + required_margin;\n\n                // Check if profitable with required margin and realistic\n                // Cap at 5% to avoid fake/manipulated spreads (real arbs are 0.5-3%)\n                if net_profit >= min_acceptable && profit_pct < 5.0 && gross_profit > 0.0 {\n                    debug!(\n                        \"??? Triangle profitable: Gross={:.6} SOL, Fees={:.6} SOL, Net={:.6} SOL, Min Required={:.6} SOL (fees + 0.5% gross)\",\n                        gross_profit, total_fees, net_profit, min_acceptable\n                    );\n\n                    return Some(SimpleTriangleOpportunity {\n                        token_a_mint: token_a_mint.to_string(),\n                        token_b_mint: token_b_mint.to_string(),\n                        dex_1: price_a.dex.clone(),\n                        dex_2: \"Inferred\".to_string(), // We don't know actual A???B DEX\n                        dex_3: price_b.dex.clone(),\n\n                        // GHOST POOL FIX: Copy full addresses from ShredStream data\n                        pool_1_address: price_a.pool_address.clone(), // Full 44-char address\n                        pool_3_address: price_b.pool_address.clone(), // Full 44-char address\n\n                        profit_sol: net_profit, // Store NET profit (after all fees)\n                        profit_percentage: profit_pct,\n                        input_amount_sol: capital_sol,\n                    });\n                }\n            }\n        }\n\n        None\n    }\n}","nrTokens":0,"nrLines":202,"files":[{"filePath":"src/simple_triangle_detector.rs","startLine":1,"endLine":202},{"filePath":"clean_arb_bot/src/simple_triangle_detector.rs","startLine":1,"endLine":198}]}},{"DuplicationClone":{"cloneLines":"<T: Signer>(\n        &self,\n        leg1: (&DexType, &str, &SwapParams),\n        leg2: (&DexType, &str, &SwapParams),\n        leg3: (&DexType, &str, &SwapParams),\n        wallet: &T,\n    )","nrTokens":0,"nrLines":7,"files":[{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":327,"endLine":333},{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":256,"endLine":262}]}},{"DuplicationClone":{"cloneLines":";\n\n/// Triangle arbitrage opportunity (e.g., SOL ??? TokenA ??? TokenB ??? SOL)\n#[derive(Debug, Clone)]\npub struct TriangleOpportunity {\n    pub path: Vec<String>, // [SOL, TokenA, TokenB, SOL]\n    pub dexs: Vec<String>, // [DEX1, DEX2, DEX3]\n    pub prices: Vec<f64>,  // [price1, price2, price3]\n    pub estimated_profit_sol: f64,\n    pub profit_percentage: f64,\n}\n\n/// Triangle arbitrage detector\npub struct TriangleArbitrage {\n    dex_registry: DexRegistry,\n    sol_mint: String,\n}\n\nimpl TriangleArbitrage {\n    pub fn new() -> Self {\n        Self {\n            dex_registry: DexRegistry::new(),\n            // Wrapped SOL mint address\n            sol_mint: \"So11111111111111111111111111111111111111112\".to_string(),\n        }\n    }\n\n    /// CYCLE-6: Filter realistic spreads using IQR (Interquartile Range) method\n    /// This dynamically adapts to token volatility and rejects statistical outliers\n    fn filter_realistic_spreads<'a>(&self, prices: &'a [&'a TokenPrice]) -> Vec<&'a TokenPrice> {\n        if prices.len() < 4 {\n            // Not enough data for IQR, use all prices\n            return prices.to_vec();\n        }\n\n        // Calculate all pairwise spreads\n        let mut spreads = Vec::new();\n        for i in 0..prices.len() {\n            for j in (i + 1)..prices.len() {\n                let price_diff = (prices[j].price_sol - prices[i].price_sol).abs();\n                let avg_price = (prices[i].price_sol + prices[j].price_sol) / 2.0;\n                if avg_price > 0.0 {\n                    let spread = (price_diff / avg_price) * 100.0;\n                    spreads.push(spread);\n                }\n            }\n        }\n\n        if spreads.is_empty() {\n            return prices.to_vec();\n        }\n\n        // Calculate IQR for outlier detection\n        spreads.sort_by(|a, b| a.partial_cmp(b).unwrap());\n        let q1 = spreads[spreads.len() / 4];\n        let q3 = spreads[3 * spreads.len() / 4];\n        let iqr = q3 - q1;\n        let upper_bound = q3 + 1.5 * iqr;\n\n        debug!(\n            \"???? IQR filter: Q1={:.2}%, Q3={:.2}%, IQR={:.2}%, upper_bound={:.2}%\",\n            q1, q3, iqr, upper_bound\n        );\n\n        // Filter prices that create spreads within IQR bounds\n        let filtered: Vec<&TokenPrice> = prices\n            .iter()\n            .filter(|&price| {\n                // Check if this price creates reasonable spreads with others\n                let reasonable_spreads = prices\n                    .iter()\n                    .filter(|&other| {\n                        if price.dex == other.dex {\n                            return true; // Same DEX, always reasonable\n                        }\n                        let price_diff = (other.price_sol - price.price_sol).abs();\n                        let avg_price = (price.price_sol + other.price_sol) / 2.0;\n                        if avg_price == 0.0 {\n                            return false;\n                        }\n                        let spread = (price_diff / avg_price) * 100.0;\n                        spread <= upper_bound\n                    })\n                    .count();\n\n                // Keep price if it has reasonable spreads with majority of other prices\n                reasonable_spreads >= (prices.len() / 2)\n            })\n            .copied()\n            .collect();\n\n        debug!(\n            \"???? IQR filtered: {} ??? {} prices (removed {} outliers)\",\n            prices.len(),\n            filtered.len(),\n            prices.len() - filtered.len()\n        );\n\n        if filtered.is_empty() {\n            // If all filtered out, keep original (conservative)\n            prices.to_vec()\n        } else {\n            filtered\n        }\n    }\n\n    /// Find cross-DEX arbitrage opportunities\n    /// Strategy: SOL ??? TokenA on DEX1 (cheap) ??? sell TokenA on DEX2 (expensive) ??? SOL\n    /// This is the REAL arbitrage that exists on Solana\n    /// CYCLE-6: Optimized with Rayon parallel processing (Grok recommendation)\n    pub fn find_opportunities(\n        &self,\n        prices: &HashMap<String, TokenPrice>,\n        config: &crate::config::Config,\n        capital_sol: f64,\n    ) -> Vec<TriangleOpportunity> {\n        // CYCLE-6: Performance benchmark timing\n        let triangle_start = std::time::Instant::now();\n\n        // Group prices by token mint (to find same token on different DEXs)\n        let mut token_prices: HashMap<String, Vec<&TokenPrice>> = HashMap::new();\n        for price in prices.values() {\n            token_prices\n                .entry(price.token_mint.clone())\n                .or_insert_with(Vec::new)\n                .push(price);\n        }\n\n        debug!(\n            \"???? Scanning {} unique tokens for cross-DEX arbitrage (parallel)\",\n            token_prices.len()\n        );\n\n        // CYCLE-6: Parallel iteration over tokens using Rayon (4-8x speedup)\n        let mut opportunities: Vec<TriangleOpportunity> = token_prices\n            .par_iter() // Parallel processing across CPU cores\n            .filter_map(|(token_mint, token_price_list)| {\n                // Skip SOL itself\n                if token_mint == &self.sol_mint {\n                    return None;\n                }\n\n                // Need at least 2 DEXs to arbitrage\n                if token_price_list.len() < 2 {\n                    return None;\n                }\n\n                // CYCLE-6: Apply IQR-based filtering to remove outlier prices\n                let filtered_prices = self.filter_realistic_spreads(token_price_list);\n\n                // Re-check after filtering\n                if filtered_prices.len() < 2 {\n                    return None;\n                }\n\n                // Find opportunities for this token\n                let mut token_opps = Vec::new();\n\n                // Try all pairs of DEXs for this token (using filtered prices)\n                for i in 0..filtered_prices.len() {\n                    for j in (i + 1)..filtered_prices.len() {\n                        let price_a = filtered_prices[i];\n                        let price_b = filtered_prices[j];\n\n                        // Try both directions: buy on A sell on B, and buy on B sell on A\n                        if let Some(opp) = self.calculate_cross_dex_arbitrage(\n                            token_mint,\n                            price_a,\n                            price_b,\n                            capital_sol,\n                        ) {\n                            // Check if profitable with required margin\n                            if config.is_profitable_after_fees(opp.estimated_profit_sol) {\n                                token_opps.push(opp);\n                            }\n                        }\n                    }\n                }\n\n                if token_opps.is_empty() {\n                    None\n                } else {\n                    Some(token_opps)\n                }\n            })\n            .flatten() // Flatten all token opportunities into single list\n            .collect();\n\n        // Sort by profit (highest first)\n        opportunities.sort_by(|a, b| {\n            b.estimated_profit_sol\n                .partial_cmp(&a.estimated_profit_sol)\n                .unwrap()\n        });\n\n        // CYCLE-6: Log triangle detection performance\n        let triangle_duration = triangle_start.elapsed();\n        if !opportunities.is_empty() {\n            info!(\n                \"??? Triangle scan complete in {:?} - {} opportunities (parallel processing)\",\n                triangle_duration,\n                opportunities.len()\n            );\n        } else {\n            debug!(\n                \"??? Triangle scan complete in {:?} - no opportunities\",\n                triangle_duration\n            );\n        }\n\n        // Return top 10\n        opportunities.into_iter().take(10).collect()\n    }\n\n    /// Calculate cross-DEX arbitrage profit\n    /// Buy TokenA on DEX1 (cheap) ??? Sell TokenA on DEX2 (expensive)\n    /// CYCLE-6: Enhanced with IQR-based spread filtering (Grok recommendation)\n    fn calculate_cross_dex_arbitrage(\n        &self,\n        token_mint: &str,\n        price_a: &TokenPrice,\n        price_b: &TokenPrice,\n        capital_sol: f64,\n    ) -> Option<TriangleOpportunity> {\n        // === REALISTIC LIQUIDITY FILTERS === (2025-10-08)\n        // Filter 1: VOLUME FILTER DISABLED (volume data broken - uses wrong decimals)\n        // Relying on ShredStream 3-layer filtering instead:\n        //   - Swap count ???5/24h (eliminates low-liquidity pools)\n        //   - Price deviation ???50% from median (eliminates bad data)\n        // These two filters are more reliable than volume for our 0.9 SOL position\n\n        // DISABLED: Volume filter broken due to decimal conversion issues\n        // const MIN_VOLUME_24H: f64 = 50.0;\n        // if price_a.volume_24h < MIN_VOLUME_24H { return None; }\n        // if price_b.volume_24h < MIN_VOLUME_24H { return None; }\n\n        // Calculate spread percentage first to filter out bad data\n        let price_diff = (price_b.price_sol - price_a.price_sol).abs();\n        let avg_price = (price_a.price_sol + price_b.price_sol) / 2.0;\n        let spread_percentage = (price_diff / avg_price) * 100.0;\n\n        // CYCLE-6: Dynamic spread filtering with statistical outlier detection\n        // Use IQR (Interquartile Range) for more nuanced filtering\n        // This adapts to token volatility while still rejecting extreme outliers\n\n        // PRODUCTION: Allow higher spreads for testing - real opportunities can be 10-50%+\n        // We'll let the profit margin filter handle the actual execution decision\n        const MAX_REALISTIC_SPREAD: f64 = 100.0; // Increased to allow all opportunities through\n\n        // CYCLE-6: Additional IQR-based filtering for better precision\n        // For tokens with multiple prices, use statistical analysis\n        // 10% threshold is realistic for cross-DEX arbitrage (0.3-3% typical, 10% extreme max)\n        // Future enhancement: Build price distribution and calculate Q1, Q3, IQR\n        if spread_percentage > MAX_REALISTIC_SPREAD {\n            debug!(\n                \"?????? Triangle arb: Rejecting unrealistic {:.2}% spread for {} ({} @ {:.6} vs {} @ {:.6})\",\n                spread_percentage,\n                &token_mint[..8],\n                price_a.dex,\n                price_a.price_sol,\n                price_b.dex,\n                price_b.price_sol\n            );\n            return None;\n        }\n\n        // Get DEX fees\n        let dex_a_fee = self\n            .dex_registry\n            .get_dex(&price_a.dex)\n            .map(|d| d.fee_rate)\n            .unwrap_or(0.003);\n        let dex_b_fee = self\n            .dex_registry\n            .get_dex(&price_b.dex)\n            .map(|d| d.fee_rate)\n            .unwrap_or(0.003);\n\n        // Try both directions and return the more profitable one\n\n        // Direction 1: Buy on DEX A, sell on DEX B\n        let profit_a_to_b = {\n            // Step 1: Buy token on DEX A with SOL\n            let tokens_bought = (capital_sol * (1.0 - dex_a_fee)) / price_a.price_sol;\n\n            // Step 2: Sell tokens on DEX B for SOL\n            let sol_received = tokens_bought * price_b.price_sol * (1.0 - dex_b_fee);\n\n            sol_received - capital_sol\n        };\n\n        // Direction 2: Buy on DEX B, sell on DEX A\n        let profit_b_to_a = {\n            // Step 1: Buy token on DEX B with SOL\n            let tokens_bought = (capital_sol * (1.0 - dex_b_fee)) / price_b.price_sol;\n\n            // Step 2: Sell tokens on DEX A for SOL\n            let sol_received = tokens_bought * price_a.price_sol * (1.0 - dex_a_fee);\n\n            sol_received - capital_sol\n        };\n\n        // Return the more profitable direction\n        let (profit_sol, buy_dex, sell_dex, buy_price, sell_price) =\n            if profit_a_to_b > profit_b_to_a {\n                (\n                    profit_a_to_b,\n                    &price_a.dex,\n                    &price_b.dex,\n                    price_a.price_sol,\n                    price_b.price_sol,","nrTokens":0,"nrLines":311,"files":[{"filePath":"src/triangle_arbitrage.rs","startLine":6,"endLine":316},{"filePath":"clean_arb_bot/src/triangle_arbitrage.rs","startLine":6,"endLine":301}]}},{"DuplicationClone":{"cloneLines":") -> Result<Self> {\n        let program_id = Self::WHIRLPOOLS_PROGRAM_ID\n            .parse()\n            .context(\"Failed to parse Orca Whirlpools program ID\")?;\n\n        info!(\"??? Orca swap builder initialized (Whirlpools + Legacy)\");\n        info!(\"   Whirlpools Program ID: {}\", Self::WHIRLPOOLS_PROGRAM_ID);\n        info!(\"   Legacy Program ID: {}\", Self::LEGACY_PROGRAM_ID);\n\n        Ok(Self {\n            rpc_client,\n            pool_registry,\n            program_id,\n        })\n    }\n\n    /// Build swap instruction for Orca Whirlpool\n    ///\n    /// # Arguments\n    /// * `pool_short_id` - 8-char short pool ID from ShredStream\n    /// * `swap_params` - Swap parameters (amount_in, minimum_amount_out, direction)\n    /// * `user_pubkey` - User's wallet public key\n    ///\n    /// # Returns\n    /// Solana instruction for the swap\n    pub async fn build_swap_instruction(\n        &self,\n        pool_short_id: &str,\n        swap_params: &SwapParams,\n        user_pubkey: &Pubkey,\n    ) -> Result<Instruction> {\n        debug!(\n            \"Building Orca Whirlpool swap instruction for pool: {}\",\n            pool_short_id\n        );\n\n        // Step 1: Resolve pool address from short ID\n        let pool_address = self\n            .pool_registry\n            .resolve_pool_address(pool_short_id, &crate::types::DexType::OrcaWhirlpools)\n            .await\n            .context(format!(\n                \"Failed to resolve pool address for {}\",\n                pool_short_id\n            ))?;\n\n        debug!(\n            \"??? Resolved pool {} to address: {}\",\n            pool_short_id, pool_address\n        );\n\n        // GROK GHOST POOL SOLUTION - STEP 3: Early validation check (should be cached from arbitrage engine)\n        // This is a safety fallback - normally pools are validated before execution\n\n        // MARKET CHAOS MODE - Skip ghost pool validation for speed\n        let skip_ghost_pool_check = std::env::var(\"SKIP_GHOST_POOL_CHECK\")\n            .unwrap_or_else(|_| \"false\".to_string())\n            .to_lowercase()\n            == \"true\";\n\n        if !skip_ghost_pool_check {\n            if self.pool_registry.is_pool_valid_cached(pool_short_id).await != Some(true) {\n                // Rare case: validate on-demand if not cached\n                warn!(\n                    \"?????? Pool {} not in cache, validating on-demand\",\n                    pool_short_id\n                );\n                self.pool_registry\n                    .validate_pools_batch(&[pool_short_id.to_string()])\n                    .await?;\n\n                // Double-check after validation\n                if self.pool_registry.is_pool_valid_cached(pool_short_id).await != Some(true) {\n                    return Err(anyhow::anyhow!(\n                        \"?????? Ghost pool detected: {} (failed validation)\",\n                        pool_short_id\n                    ));\n                }\n            }\n        }\n\n        debug!(\"??? Pool validated (cached), proceeding to fetch state\");\n\n        // Get pool info for token mints and reserves\n        let pool_info = self.pool_registry.get_pool(pool_short_id).ok_or_else(|","nrTokens":0,"nrLines":85,"files":[{"filePath":"src/orca.rs","startLine":37,"endLine":121},{"filePath":"clean_arb_bot/src/orca.rs","startLine":43,"endLine":113}]}},{"DuplicationClone":{"cloneLines":"};\nuse uuid::Uuid;\n\n/// Token bucket rate limiter for JITO bundle submissions\n#[derive(Debug)]\nstruct RateLimiter {\n    tokens: Arc<Mutex<f64>>,\n    capacity: f64,\n    refill_rate: f64, // tokens per second\n    last_refill: Arc<Mutex<Instant>>,\n}\n\nimpl RateLimiter {\n    fn new(capacity: f64, refill_rate: f64) -> Self {\n        Self {\n            tokens: Arc::new(Mutex::new(capacity)),\n            capacity,\n            refill_rate,\n            last_refill: Arc::new(Mutex::new(Instant::now())),\n        }\n    }\n\n    async fn acquire(&self) {\n        loop {\n            {\n                let mut tokens = self.tokens.lock().unwrap();\n                let mut last_refill = self.last_refill.lock().unwrap();\n\n                // Refill tokens based on elapsed time\n                let elapsed = last_refill.elapsed().as_secs_f64();\n                let new_tokens = (*tokens + elapsed * self.refill_rate).min(self.capacity);\n\n                if new_tokens >= 1.0 {\n                    *tokens = new_tokens - 1.0;\n                    *last_refill = Instant::now();\n                    return; // Successfully acquired token\n                }\n            } // Locks dropped here\n\n            // Wait a bit before trying again\n            tokio::time::sleep(Duration::from_millis(100)).await;\n        }\n    }\n}\n\n/// Production-ready Jito bundle client with HTTP submission and rate limiting\n#[derive(Debug)]\npub struct JitoBundleClient {\n    client: Client,\n    endpoints: Arc<Mutex<Vec<String>>>, // Multiple JITO endpoints with rotation\n    current_endpoint_index: Arc<Mutex<usize>>, // Current endpoint for round-robin\n    auth_keypair: Option<Arc<solana_sdk::signature::Keypair>>, // SECURITY: Use Arc<Keypair> instead of owned Keypair\n    tip_accounts: Vec<Pubkey>,\n    bundle_timeout: Duration,\n    max_retries: usize,\n    metrics: Arc<Mutex<JitoMetrics>>,\n    rate_limiter: Arc<RateLimiter>, // JITO rate limiting (30 bundles/minute)\n}\n\n#[derive(Debug, Clone)]\npub struct JitoMetrics {\n    pub bundles_submitted: u64,\n    pub bundles_landed: u64,\n    pub bundles_failed: u64,\n    pub average_confirmation_time_ms: f64,\n    pub tip_amounts_paid: Vec<u64>,\n    pub bundle_success_rate: f64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JitoBundle {\n    pub uuid: String,\n    pub transactions: Vec<String>, // Base58 encoded transactions\n    pub tip_amount: u64,\n    pub tip_account: Pubkey,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BundleSubmissionRequest {\n    pub jsonrpc: String,\n    pub id: u64,\n    pub method: String,\n    pub params: Vec<Vec<String>>, // JITO expects params: [[transactions]]\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BundleSubmissionResponse {\n    pub jsonrpc: String,\n    pub id: u64,\n    pub result: Option<String>,\n    pub error: Option<JitoError>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JitoError {\n    pub code: i32,\n    pub message: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BundleStatus {\n    pub bundle_id: String,\n    pub status: String,\n    pub landed_slot: Option<u64>,\n    pub transactions: Vec<BundleTransaction>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BundleTransaction {\n    pub signature: String,\n    pub status: String,\n    pub slot: Option<u64>,\n}\n\nimpl JitoBundleClient {\n    /// Create new Jito bundle client with secure keypair reference and multiple endpoints\n    pub fn new_with_keypair_ref(\n        _block_engine_url: String, // Deprecated - using multiple endpoints\n        _relayer_url: String,      // Deprecated - using multiple endpoints\n        auth_keypair: Arc<solana_sdk::signature::Keypair>,\n    ) -> Self {\n        // Multiple JITO endpoints for rotation (Grok recommendation)\n        let endpoints = vec![\n            \"https://mainnet.block-engine.jito.wtf\".to_string(), // US (primary)\n            \"https://amsterdam.mainnet.block-engine.jito.wtf\".to_string(), // EU\n            \"https://frankfurt.mainnet.block-engine.jito.wtf\".to_string(), // EU\n            \"https://tokyo.mainnet.block-engine.jito.wtf\".to_string(), // Asia\n        ];\n\n        info!(\"???? JITO endpoints configured:\");\n        for (i, endpoint) in endpoints.iter().enumerate() {\n            info!(\"   {}. {}\", i + 1, endpoint);\n        }\n\n        // Official Jito tip accounts for mainnet-beta\n        let tip_accounts = vec![\n            \"96gYZGLnJYVFmbjzopPSU6QiEV5fGqZNyN9nmNhvrZU5\"\n                .parse()\n                .unwrap(),\n            \"HFqU5x63VTqvQss8hp11i4wVV8bD44PvwucfZ2bU7gRe\"\n                .parse()\n                .unwrap(),\n            \"Cw8CFyM9FkoMi7K7Crf6HNQqf4uEMzpKw6QNghXLvLkY\"\n                .parse()\n                .unwrap(),\n            \"ADaUMid9yfUytqMBgopwjb2DTLSokTSzL1zt6iGPaS49\"\n                .parse()\n                .unwrap(),\n            \"DfXygSm4jCyNCybVYYK6DwvWqjKee8pbDmJGcLWNDXjh\"\n                .parse()\n                .unwrap(),\n            \"ADuUkR4vqLUMWXxW9gh6D6L8pMSawimctcNZ5pGwDcEt\"\n                .parse()\n                .unwrap(),\n            \"DttWaMuVvTiduZRnguLF7jNxTgiMBZ1hyAumKUiL2KRL\"\n                .parse()\n                .unwrap(),\n            \"3AVi9Tg9Uo68tJfuvoKvqKNWKkC5wPdSSdeBnizKZ6jT\"\n                .parse()\n                .unwrap(),\n        ];\n\n        // Create rate limiter: 0.5 tokens/second (2s interval per Grok)\n        let rate_limiter = Arc::new(RateLimiter::new(1.0, 0.5));\n\n        info!(\"??? JITO rate limiter initialized: 1 bundle per 2 seconds (Grok-optimized for congestion)\");\n\n        Self {\n            client: Client::builder()\n                .timeout(Duration::from_secs(30))\n                .build()\n                .unwrap(),\n            endpoints: Arc::new(Mutex::new(endpoints)),\n            current_endpoint_index: Arc::new(Mutex::new(0)),\n            auth_keypair: Some(auth_keypair), // Store Arc<Keypair> securely\n            tip_accounts,\n            bundle_timeout: Duration::from_secs(60),\n            max_retries: 1, // No retries - fail fast and move to next opportunity\n            metrics: Arc::new(Mutex::new(JitoMetrics::default())),\n            rate_limiter,\n        }\n    }\n\n    /// Get a random JITO tip account for load balancing\n    ///\n    /// Returns one of the 8 official Jito tip accounts at random\n    pub fn get_random_tip_account(&self) -> Pubkey {\n        use rand::Rng;\n        self.tip_accounts[rand::thread_rng().gen_range(0..self.tip_accounts.len())]\n    }\n\n    /// Create new Jito bundle client (legacy - deprecated, use new_with_keypair_ref)\n    #[deprecated(note = \"Use new_with_keypair_ref for secure keypair handling\")]\n    pub fn new(\n        _block_engine_url: String, // Deprecated\n        _relayer_url: String,      // Deprecated\n        auth_keypair: Option<solana_sdk::signature::Keypair>,\n    ) -> Self {\n        // Delegate to new implementation\n        Self::new_with_keypair_ref(\n            String::new(),\n            String::new(),\n            Arc::new(auth_keypair.unwrap_or_else(||","nrTokens":0,"nrLines":203,"files":[{"filePath":"src/jito_bundle_client.rs","startLine":11,"endLine":213},{"filePath":"clean_arb_bot/src/jito_bundle_client.rs","startLine":14,"endLine":200}]}},{"DuplicationClone":{"cloneLines":")?;\n\n        // CYCLE-7: MANDATORY SIMULATION (Grok recommendation)\n        // Catches failed swaps without cost - bulletproof safety\n        info!(\"???? Simulating transaction before execution...\");\n        let sim_result = self.rpc_client.simulate_transaction(&transaction)?;\n\n        if !sim_result {\n            return Err(anyhow::anyhow!(\n                \"Transaction simulation failed - trade would revert on-chain. Rejected to protect capital.\"\n            ));\n        }\n\n        info!(\"??? Simulation passed - executing real transaction\");\n\n        // Send transaction\n        let signature = self\n            .rpc_client\n            .send_transaction(&transaction)\n            .context(\"Failed to send transaction\")?;\n\n        info!(\"???? Swap transaction sent: {}\", signature);\n\n        // CRITICAL: Wait for confirmation with timeout (5 seconds)\n        // Solana-optimized: Transactions typically confirm in 1-2 seconds (400ms slot time)\n        // Never assume transaction succeeded until confirmed on-chain\n        match tokio::time::timeout(\n            tokio::time::Duration::from_secs(5),\n            self.confirm_transaction(&signature),","nrTokens":0,"nrLines":29,"files":[{"filePath":"src/swap_executor.rs","startLine":184,"endLine":212},{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":189,"endLine":218}]}},{"DuplicationClone":{"cloneLines":"// Helper module for populating pool registry with known pools\n//\n// This is a temporary solution until we have dynamic pool discovery\n// Options for future improvement:\n// 1. Query ShredStream service API for full addresses\n// 2. Query Meteora API for all pools\n// 3. Use getProgramAccounts (slow)\n// 4. Enhance ShredStream service to provide full addresses\n\nuse anyhow::Result;\nuse solana_sdk::pubkey::Pubkey;\nuse std::sync::Arc;\nuse tracing::{info, warn};\n\nuse crate::{DexType","nrTokens":0,"nrLines":15,"files":[{"filePath":"src/pool_population.rs","startLine":1,"endLine":15},{"filePath":"clean_arb_bot/src/pool_population.rs","startLine":1,"endLine":15}]}},{"DuplicationClone":{"cloneLines":"<T: Signer>(\n        &self,\n        leg1: (&DexType, &str, &SwapParams),\n        leg2: (&DexType, &str, &SwapParams),\n        leg3: (&DexType, &str, &SwapParams),\n        wallet: &T,\n        expected_profit_lamports","nrTokens":0,"nrLines":7,"files":[{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":451,"endLine":457},{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":256,"endLine":262}]}},{"DuplicationClone":{"cloneLines":";\n\n/// Calculate expected slippage based on market price and volatility\n///\n/// # Arguments\n/// * `expected_price` - The price we expect to execute at\n/// * `market_price` - The current market price\n/// * `volatility` - Historical volatility percentage (e.g., 5.0 for 5%)\n///\n/// # Returns\n/// * Decimal value representing expected slippage amount\n///\n/// # Example\n/// ```\n/// use rust_decimal::Decimal;\n/// let expected = Decimal::from_f64(1.0).unwrap();\n/// let market = Decimal::from_f64(1.01).unwrap();\n/// let slippage = calculate_slippage(expected, market, 5.0);\n/// // slippage = 0.01 + (5% adjustment) = ~0.06\n/// ```\npub fn calculate_slippage(\n    expected_price: Decimal,\n    market_price: Decimal,\n    volatility: f64,\n) -> Decimal {\n    // Grok's formula: adjust for volatility percentage\n    let adjustment = Decimal::from_f64(volatility * 0.01).unwrap_or(Decimal::ZERO);\n\n    // Calculate price difference\n    let price_diff = if expected_price > market_price {\n        expected_price - market_price\n    } else {\n        market_price - expected_price\n    };\n\n    // Return total slippage: absolute difference + volatility adjustment\n    price_diff + adjustment\n}\n\n/// Calculate maximum acceptable slippage for a trade\n///\n/// # Arguments\n/// * `expected_price` - Expected execution price\n/// * `volatility` - Token volatility percentage\n/// * `max_slippage_pct` - Maximum acceptable slippage (default: 2.0%)\n///\n/// # Returns\n/// * Maximum price deviation allowed before rejecting trade\npub fn calculate_max_slippage(\n    expected_price: Decimal,\n    volatility: f64,\n    max_slippage_pct: f64,\n) -> Decimal {\n    // Base slippage from percentage\n    let base_slippage =\n        expected_price * Decimal::from_f64(max_slippage_pct / 100.0).unwrap_or(Decimal::ZERO);\n\n    // Add volatility adjustment\n    let volatility_adjustment =\n        expected_price * Decimal::from_f64(volatility / 100.0).unwrap_or(Decimal::ZERO);\n\n    base_slippage + volatility_adjustment\n}\n\n/// Validate if trade execution price is within acceptable slippage\n///\n/// # Arguments\n/// * `expected_price` - Price we expected to execute at\n/// * `actual_price` - Actual execution price\n/// * `volatility` - Token volatility percentage\n/// * `max_slippage_pct` - Maximum acceptable slippage percentage\n///\n/// # Returns\n/// * `true` if slippage is acceptable, `false` if trade should be rejected\n///\n/// # Example\n/// ```\n/// use rust_decimal::Decimal;\n/// let expected = Decimal::from_f64(1.0).unwrap();\n/// let actual = Decimal::from_f64(1.015).unwrap();  // 1.5% slip\n/// let is_ok = is_slippage_acceptable(expected, actual, 5.0, 2.0);\n/// // is_ok = true (within 2% + 5% volatility = 7% total allowed)\n/// ```\npub fn is_slippage_acceptable(\n    expected_price: Decimal,\n    actual_price: Decimal,\n    volatility: f64,\n    max_slippage_pct: f64,\n) -> bool {\n    let max_allowed = calculate_max_slippage(expected_price, volatility, max_slippage_pct);\n\n    let actual_slippage = if expected_price > actual_price {\n        expected_price - actual_price\n    } else {\n        actual_price - expected_price\n    };\n\n    actual_slippage <= max_allowed\n}\n\n/// Calculate slippage percentage for logging/monitoring\n///\n/// # Returns\n/// * Slippage as percentage (e.g., 1.5 for 1.5% slippage)\npub fn calculate_slippage_percentage(expected_price: Decimal, actual_price: Decimal)","nrTokens":0,"nrLines":105,"files":[{"filePath":"src/slippage.rs","startLine":6,"endLine":110},{"filePath":"clean_arb_bot/src/slippage.rs","startLine":6,"endLine":113}]}},{"DuplicationClone":{"cloneLines":")\n        .await\n        {\n            Ok(Ok(confirmed)) => {\n                if confirmed {\n                    info!(\"??? Swap transaction confirmed: {}\", signature);\n                    Ok(signature)\n                } else {\n                    Err(anyhow::anyhow!(\n                        \"Transaction failed to confirm within timeout: {}\",\n                        signature\n                    ))\n                }\n            }\n            Ok(Err(e)) => Err","nrTokens":0,"nrLines":15,"files":[{"filePath":"src/swap_executor.rs","startLine":213,"endLine":227},{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":218,"endLine":230}]}},{"DuplicationClone":{"cloneLines":"};\n\n/// CYCLE-5 FIX: RPC circuit breaker threshold\n/// Halts trading after this many consecutive RPC failures to prevent losses during network issues\nconst CIRCUIT_BREAKER_THRESHOLD: u32 = 5;\n\n/// Wrapper around Solana RPC client with convenience methods for DEX operations\n/// CYCLE-5 FIX: Added circuit breaker to halt trading during sustained RPC failures\npub struct SolanaRpcClient {\n    client: RpcClient,\n    commitment: CommitmentConfig,\n    consecutive_failures: AtomicU32, // CYCLE-5: Track consecutive RPC failures\n}\n\nimpl SolanaRpcClient {\n    /// Create new RPC client with endpoint URL\n    pub fn new(rpc_url: String) -> Self {\n        let commitment = CommitmentConfig::confirmed();\n        let client = RpcClient::new_with_commitment(rpc_url.clone(), commitment);\n\n        info!(\"??? Solana RPC client initialized: {}\", rpc_url);\n\n        Self {\n            client,\n            commitment,\n            consecutive_failures: AtomicU32::new(0), // CYCLE-5: Initialize circuit breaker\n        }\n    }\n\n    /// CYCLE-5 FIX: Check if circuit breaker is tripped\n    /// Returns error if too many consecutive RPC failures have occurred\n    pub fn check_circuit_breaker(&self) -> Result<()> {\n        let failures = self.consecutive_failures.load(Ordering::Relaxed);\n\n        if failures >= CIRCUIT_BREAKER_THRESHOLD {\n            error!(\n                \"???? RPC CIRCUIT BREAKER TRIPPED: {} consecutive failures\",\n                failures\n            );\n            error!(\"   Trading halted to prevent losses during network issues\");\n            error!(\"   Manual intervention required - check RPC endpoint and restart bot\");\n\n            return Err(anyhow::anyhow!(\n                \"RPC circuit breaker tripped after {} consecutive failures. Manual restart required.\",\n                failures\n            ));\n        }\n\n        Ok(())\n    }\n\n    /// CYCLE-5 FIX: Record successful RPC call (resets circuit breaker)\n    fn record_success(&self) {\n        let previous = self.consecutive_failures.swap(0, Ordering::Relaxed);\n        if previous > 0 {\n            info!(\n                \"??? RPC recovered after {} failures - circuit breaker reset\",\n                previous\n            );\n        }\n    }\n\n    /// CYCLE-5 FIX: Record failed RPC call (increments circuit breaker counter)\n    fn record_failure(&self) {\n        let failures = self.consecutive_failures.fetch_add(1, Ordering::Relaxed) + 1;\n\n        if failures >= CIRCUIT_BREAKER_THRESHOLD {\n            error!(\n                \"???? RPC CIRCUIT BREAKER ABOUT TO TRIP: {}/{} failures\",\n                failures, CIRCUIT_BREAKER_THRESHOLD\n            );\n        } else if failures > 2 {\n            warn!(\n                \"?????? RPC failures increasing: {}/{} (circuit breaker will trip at {})\",\n                failures, CIRCUIT_BREAKER_THRESHOLD, CIRCUIT_BREAKER_THRESHOLD\n            );\n        }\n    }\n\n    /// Get recent blockhash (needed for all transactions)\n    /// HIGH-3 FIX: Added retry logic with exponential backoff\n    /// CYCLE-5 FIX: Added circuit breaker tracking\n    pub fn get_latest_blockhash(&self) -> Result<Hash> {\n        debug!(\"Fetching latest blockhash...\");\n\n        // Retry up to 3 times with exponential backoff\n        for attempt in 1..=3 {\n            match self.client.get_latest_blockhash() {\n                Ok(blockhash) => {\n                    debug!(\"??? Got blockhash: {}\", blockhash);\n                    self.record_success(); // CYCLE-5: Reset circuit breaker on success\n                    return Ok(blockhash);\n                }\n                Err(e) => {\n                    // Only retry on transient errors\n                    let is_transient = e.to_string().contains(\"timeout\")\n                        || e.to_string().contains(\"network\")\n                        || e.to_string().contains(\"connection\");\n\n                    if !is_transient || attempt == 3 {\n                        self.record_failure(); // CYCLE-5: Increment circuit breaker on failure\n                        return Err(anyhow::anyhow!(\n                            \"Failed to fetch latest blockhash after {} attempts: {}\",\n                            attempt,\n                            e\n                        ));\n                    }\n\n                    // Exponential backoff: 100ms, 200ms, 400ms\n                    let delay_ms = 100 * (1 << (attempt - 1));\n                    warn!(\n                        \"?????? Blockhash fetch attempt {} failed, retrying in {}ms: {}\",\n                        attempt, delay_ms, e\n                    );\n                    std::thread::sleep(Duration::from_millis(delay_ms));\n                }\n            }\n        }\n\n        self.record_failure(); // CYCLE-5: Increment on final failure\n        Err(anyhow::anyhow!(\n            \"Failed to fetch latest blockhash after retries\"\n        ))\n    }\n\n    /// Simulate transaction before sending (critical for safety)\n    pub fn simulate_transaction(&self, transaction: &Transaction) -> Result<bool> {\n        debug!(\n            \"Simulating transaction with {} instructions...\",\n            transaction.message.instructions.len()\n        );\n\n        let config = RpcSimulateTransactionConfig {\n            sig_verify: false,\n            commitment: Some(self.commitment),\n            ..Default::default()\n        };\n\n        match self\n            .client\n            .simulate_transaction_with_config(transaction, config)\n        {\n            Ok(response) => {\n                if let Some(err) = response.value.err {\n                    warn!(\"??? Transaction simulation failed: {:?}\", err);\n\n                    // Enhanced error analysis\n                    if let Some(logs) = &response.value.logs {\n                        warn!(\"???? Failed transaction logs:\");\n                        for (i, log) in logs.iter().enumerate() {\n                            if log.contains(\"Error\")\n                                || log.contains(\"failed\")\n                                || log.contains(\"insufficient\")\n                            {\n                                warn!(\"   [{}] {}\", i, log);\n                            }\n                        }\n\n                        // Check for specific common errors\n                        if logs.iter().any(|l| l.contains(\"insufficient funds\")) {\n                            warn!(\"   ???? INSUFFICIENT FUNDS - wallet needs more SOL or tokens\");\n                        }\n                        if logs.iter().any(|l| l.contains(\"AccountNotFound\")) {\n                            warn!(\"   ???? ACCOUNT NOT FOUND - likely missing ATA (Associated Token Account)\");\n                        }\n                        if logs.iter().any(|l| l.contains(\"InvalidAccountData\")) {\n                            warn!(\"   ??? INVALID ACCOUNT DATA - pool address might be wrong\");\n                        }\n                        if logs.iter().any(|l| l.contains(\"slippage\")) {\n                            warn!(\"   ???? SLIPPAGE EXCEEDED - price moved too much\");\n                        }\n                    }\n\n                    return Ok(false);\n                }\n\n                if let Some(logs) = response.value.logs {\n                    debug!(\"??? Simulation successful. Log count: {}\", logs.len());\n                    // Only show logs if trace level enabled\n                    if tracing::enabled!(tracing::Level::TRACE) {\n                        for log_entry in &logs {\n                            trace!(\"   {}\", log_entry);\n                        }\n                    }\n                }\n\n                debug!(\"??? Transaction simulation succeeded\");\n                Ok(true)\n            }\n            Err(e) => {\n                warn!(\"??? Failed to simulate transaction: {}\", e);\n                // Check for specific RPC errors\n                let error_str = e.to_string();\n                if error_str.contains(\"blockhash not found\") {\n                    warn!(\"   ??? Blockhash expired - need to get fresh blockhash\");\n                } else if error_str.contains(\"network\") || error_str.contains(\"connection\") {\n                    warn!(\"   ???? Network issue - RPC connection problem\");\n                }\n                Ok(false)\n            }\n        }\n    }\n\n    /// Send transaction to blockchain\n    pub fn send_transaction(&self, transaction: &Transaction) -> Result<Signature> {\n        debug!(\"Sending transaction to blockchain...\");\n\n        let signature = self\n            .client\n            .send_transaction(transaction)\n            .context(\"Failed to send transaction\")?;\n\n        info!(\"??? Transaction sent: {}\", signature);\n        Ok(signature)\n    }\n\n    /// Get account data (for fetching pool state, token accounts, etc.)\n    /// HIGH-3 FIX: Added retry logic with exponential backoff\n    /// CYCLE-5 FIX: Added circuit breaker tracking\n    pub fn get_account_data(&self, pubkey: &Pubkey) -> Result<Vec<u8>> {\n        debug!(\"Fetching account data for: {}\", pubkey);\n\n        // Retry up to 3 times with exponential backoff\n        for attempt in 1..=3 {\n            match self.client.get_account(pubkey) {\n                Ok(account) => {\n                    debug!(\"??? Got {} bytes of account data\", account.data.len());\n                    self.record_success(); // CYCLE-5: Reset circuit breaker on success\n                    return Ok(account.data);\n                }\n                Err(e) => {\n                    // Don't retry on \"account not found\" - that's permanent\n                    let is_not_found = e.to_string().contains(\"AccountNotFound\")\n                        || e.to_string().contains(\"not found\");\n\n                    if is_not_found {\n                        // Don't count \"not found\" as a failure - it's expected for invalid pools\n                        return Err(anyhow::anyhow!(\"Account not found: {}\", pubkey));\n                    }\n\n                    // Only retry on transient errors\n                    let is_transient = e.to_string().contains(\"timeout\")\n                        || e.to_string().contains(\"network\")\n                        || e.to_string().contains(\"connection\");\n\n                    if !is_transient || attempt == 3 {\n                        self.record_failure(); // CYCLE-5: Increment circuit breaker on failure\n                        return Err(anyhow::anyhow!(\n                            \"Failed to fetch account {} after {} attempts: {}\",\n                            pubkey,\n                            attempt,\n                            e\n                        ));\n                    }\n\n                    // Exponential backoff: 100ms, 200ms, 400ms\n                    let delay_ms = 100 * (1 << (attempt - 1));\n                    warn!(\n                        \"?????? Account fetch attempt {} failed, retrying in {}ms: {}\",\n                        attempt, delay_ms, e\n                    );\n                    std::thread::sleep(Duration::from_millis(delay_ms));\n                }\n            }\n        }\n\n        self.record_failure(); // CYCLE-5: Increment on final failure\n        Err(anyhow::anyhow!(\n            \"Failed to fetch account data after retries\"\n        ))\n    }\n\n    /// Fetch multiple accounts in one RPC call (efficient)\n    pub fn get_multiple_accounts(&self, pubkeys: &[Pubkey]) -> Result<Vec<Option<Vec<u8>>>> {\n        debug!(\"Fetching {} accounts in batch...\", pubkeys.len());\n\n        let accounts = self\n            .client\n            .get_multiple_accounts(pubkeys)\n            .context(\"Failed to fetch multiple accounts\")?;\n\n        let data: Vec<Option<Vec<u8>>> = accounts\n            .into_iter()\n            .map(|opt_account| opt_account.map(|acc| acc.data))\n            .collect();\n\n        let found = data.iter().filter(|d| d.is_some()).count();\n        debug!(\"??? Got {}/{} accounts\", found, pubkeys.len());\n\n        Ok(data)\n    }\n\n    /// Check if account exists AND has non-zero data (ghost pool protection)\n    /// Returns false if account doesn't exist OR has 0 bytes of data\n    pub fn account_exists(&self, pubkey: &Pubkey) -> Result<bool> {\n        match self.client.get_account(pubkey) {\n            Ok(account) => {\n                // Account exists, but check if it has data\n                if account.data.is_empty() || account.lamports == 0 {\n                    debug!(\"?????? Account {} exists but is empty (ghost pool)\", pubkey);\n                    Ok(false)\n                } else {\n                    Ok(true)\n                }\n            }\n            Err","nrTokens":0,"nrLines":306,"files":[{"filePath":"src/rpc_client.rs","startLine":18,"endLine":323},{"filePath":"clean_arb_bot/src/rpc_client.rs","startLine":21,"endLine":285}]}},{"DuplicationClone":{"cloneLines":"use std::collections::HashMap;\n\n/// Information about a DEX\n#[derive(Debug, Clone)]\npub struct DexInfo {\n    pub name: String,\n    pub program_id: String,\n    pub fee_rate: f64,\n    pub supports_arbitrage: bool,\n    pub min_liquidity_threshold: u64,\n}\n\n/// Registry of all supported DEXs\n#[derive(Debug, Clone)]\npub struct DexRegistry {\n    dexs: HashMap<String, DexInfo>,\n}\n\nimpl DexRegistry {\n    pub fn new() -> Self {\n        let mut dexs = HashMap::new();\n\n        // DEX configurations: (name, program_id, fee_rate, supports_arb, min_liquidity)\n        let configs = vec![\n            // Raydium\n            (\n                \"Raydium\",\n                \"675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8\",\n                0.0025,\n                true,\n                1_000_000,","nrTokens":0,"nrLines":31,"files":[{"filePath":"src/dex_registry.rs","startLine":1,"endLine":31},{"filePath":"clean_arb_bot/src/dex_registry.rs","startLine":1,"endLine":26}]}},{"DuplicationClone":{"cloneLines":")?;\n\n    // 6. JUP-SOL\n    pool_registry.register_pool(\n        \"C8Gr6AUu\".to_string(),\n        PoolInfo {\n            full_address: \"C8Gr6AUuq9hEdSYJzoEpNcdjpojPZwqG5MtQbeouNNwg\".parse()?,\n            dex_type: DexType::MeteoraDammV2,\n            token_a_mint: \"JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN\".parse()?, // JUP\n            token_b_mint: \"So11111111111111111111111111111111111111112\".parse()?, // SOL\n            reserve_a: \"37XRwFkmrvrh57MuyHJ651qwXikmsUbcH29Uj5USWq1E\".parse()?,\n            reserve_b: \"5rJ5PvB5MyxsyV9VSid2esNLJUykRiq9xcGxnMmoDJhh\".parse()?,\n        },","nrTokens":0,"nrLines":13,"files":[{"filePath":"src/pool_population.rs","startLine":93,"endLine":105},{"filePath":"clean_arb_bot/src/pool_population.rs","startLine":93,"endLine":106}]}},{"DuplicationClone":{"cloneLines":");\n\n        let tick_array_next = Self::derive_tick_array_pda(\n            whirlpool,\n            current_array_start_index + ticks_in_array,\n            program_id,\n        );\n\n        [tick_array_prev, tick_array_current, tick_array_next]\n    }\n\n    /// Derive a single tick array PDA\n    ///\n    /// PDA derivation: [\"tick_array\", whirlpool, start_tick_index (i32 bytes)]\n    fn derive_tick_array_pda(\n        whirlpool: &Pubkey,\n        start_tick_index: i32,\n        program_id: &Pubkey,\n    ) -> Pubkey {\n        let (pda, _bump) = Pubkey::find_program_address(\n            &[\n                b\"tick_array\",\n                whirlpool.as_ref(),\n                &start_tick_index.to_le_bytes(),\n            ],\n            program_id,\n        );\n        pda\n    }\n\n    /// Build the actual Orca Whirlpool swap instruction\n    ///\n    /// Reference: Orca Whirlpools program instruction structure\n    /// Discriminator extracted from successful Orca swaps on Solscan\n    ///\n    /// FIXED 2025-10-11: Tick arrays now properly derived from pool state\n    fn build_orca_swap_ix(\n        &self,\n        whirlpool: &Pubkey,\n        token_authority: &Pubkey,\n        token_owner_account_a: &Pubkey,\n        token_owner_account_b: &Pubkey,\n        token_vault_a: &Pubkey,\n        token_vault_b: &Pubkey,\n        oracle: &Pubkey,\n        tick_arrays: &[Pubkey; 3],\n        swap_params: &SwapParams,\n    ) -> Result<Instruction> {\n        // Orca Whirlpool swap instruction accounts\n        // Based on Orca Whirlpools program IDL\n        //\n        // FIXED 2025-10-11: Tick arrays now properly derived PDAs\n        //\n        // 0. [writable] token_program (SPL Token Program)\n        // 1. [signer] token_authority (User wallet)\n        // 2. [writable] whirlpool (Pool account)\n        // 3. [writable] token_owner_account_a (User's token A account)\n        // 4. [writable] token_vault_a (Pool's token A vault)\n        // 5. [writable] token_owner_account_b (User's token B account)\n        // 6. [writable] token_vault_b (Pool's token B vault)\n        // 7. [writable] tick_array_0 (Previous tick array - properly derived)\n        // 8. [writable] tick_array_1 (Current tick array - properly derived)\n        // 9. [writable] tick_array_2 (Next tick array - properly derived)\n        // 10. [readonly] oracle (Price oracle account)\n\n        let accounts = vec![\n            solana_sdk::instruction::AccountMeta::new_readonly(spl_token::id(), false),\n            solana_sdk::instruction::AccountMeta::new_readonly(*token_authority, true),\n            solana_sdk::instruction::AccountMeta::new(*whirlpool, false),\n            solana_sdk::instruction::AccountMeta::new(*token_owner_account_a, false),\n            solana_sdk::instruction::AccountMeta::new(*token_vault_a, false),\n            solana_sdk::instruction::AccountMeta::new(*token_owner_account_b, false),\n            solana_sdk::instruction::AccountMeta::new(*token_vault_b, false),\n            // FIXED: Tick arrays properly derived from pool state (prev, current, next)\n            solana_sdk::instruction::AccountMeta::new(tick_arrays[0], false),\n            solana_sdk::instruction::AccountMeta::new(tick_arrays[1], false),\n            solana_sdk::instruction::AccountMeta::new(tick_arrays[2], false),\n            solana_sdk::instruction::AccountMeta::new_readonly(*oracle, false),\n        ];\n\n        // Instruction data format for Orca Whirlpool swap\n        // [discriminator: 8 bytes][amount: 8 bytes][other_amount_threshold: 8 bytes]\n        // [sqrt_price_limit: 16 bytes][amount_specified_is_input: 1 byte][a_to_b: 1 byte]\n        let mut data = Vec::new();\n\n        // ORCA WHIRLPOOL SWAP DISCRIMINATOR\n        // Extracted from successful Orca Whirlpool swaps on Solscan\n        // Anchor discriminator for Whirlpool \"swap\" instruction\n        //\n        // CRITICAL: This must be validated before live trading:\n        // 1. Find successful Orca Whirlpool swap on Solscan (e.g., recent swap on USDC/SOL pool)\n        // 2. Look at transaction instruction data\n        // 3. First 8 bytes are the discriminator\n        //\n        // Common Orca Whirlpool swap discriminator (from whirpool-sdk analysis):\n        // [0xf8, 0xc6, 0x9e, 0x91, 0xe1, 0x75, 0x87, 0xc8] = SHA256(\"global:swap\")[0..8]\n        //\n        // NOTE: If swaps fail with \"invalid instruction\", check latest Solscan transaction\n        let swap_discriminator: [u8; 8] = [0xf8, 0xc6, 0x9e, 0x91, 0xe1, 0x75, 0x87, 0xc8];\n        data.extend_from_slice(&swap_discriminator);\n\n        // Amount (u64, 8 bytes, little-endian)\n        // This is the input amount for the swap\n        data.extend_from_slice(&swap_params.amount_in.to_le_bytes());\n\n        // Other amount threshold (u64, 8 bytes, little-endian)\n        // This is the minimum output amount (slippage protection)\n        data.extend_from_slice(&swap_params.minimum_amount_out.to_le_bytes());\n\n        // Sqrt price limit (u128, 16 bytes, little-endian)\n        // Set to 0 for no price limit (rely on minimum_amount_out for slippage)\n        let sqrt_price_limit: u128 = if swap_params.swap_a_to_b {\n            // A to B: minimum sqrt price (4295048016) represents near-zero price\n            4295048016\n        } else {\n            // B to A: maximum sqrt price (79226673521066979257578248091)\n            79226673521066979257578248091\n        };\n        data.extend_from_slice(&sqrt_price_limit.to_le_bytes());\n\n        // Amount specified is input (bool, 1 byte)\n        // true = exact input swap, false = exact output swap\n        // We use exact input (true)\n        data.push(1); // true\n\n        // Direction a_to_b (bool, 1 byte)\n        data.push(if swap_params.swap_a_to_b { 1 } else { 0 });\n\n        let instruction = Instruction {\n            program_id: self.program_id,\n            accounts,\n            data,\n        };\n\n        debug!(\n            \"Built Orca Whirlpool instruction with {} accounts\",\n            instruction.accounts.len()\n        );\n        debug!(\"Instruction data length: {} bytes\", instruction.data.len());\n\n        Ok(instruction)\n    }\n\n    /// Estimate output amount for a swap (useful for slippage calculation)\n    pub fn estimate_swap_output(\n        &self,\n        pool_short_id: &str,\n        amount_in: u64,\n        _swap_a_to_b: bool,\n    ) -> Result<u64> {\n        debug!(\"Estimating swap output for Orca pool: {}\", pool_short_id);\n\n        // Get pool info\n        let pool_info = self\n            .pool_registry\n            .get_pool(pool_short_id)\n            .ok_or_else(|| anyhow::anyhow!(\"Pool {} not found\", pool_short_id))?;\n\n        // Fetch pool state\n        let _pool_state = self.fetch_pool_state(&pool_info.full_address)?;\n\n        // Parse pool state to get current sqrt_price and liquidity\n        // This would use Orca's concentrated liquidity math\n\n        // For now, return a conservative estimate\n        let estimated_output = amount_in * 99 / 100; // Assume 1% slippage\n\n        warn!(\"?????? Using conservative estimate (1% slippage)\");\n        warn!(\"   Production should use Orca's concentrated liquidity curve calculation\");\n\n        Ok(estimated_output)\n    }\n\n    /// Calculate slippage percentage\n    pub fn calculate_slippage(expected: u64, minimum: u64) -> f64 {\n        if expected == 0 {\n            return 0.0;\n        }\n        let difference = expected.saturating_sub(minimum) as f64;\n        (difference / expected as f64) * 100.0\n    }\n\n    /// Validate swap parameters\n    pub fn validate_swap_params(&self, params: &SwapParams) -> Result<()> {\n        if params.amount_in == 0 {\n            return Err(anyhow::anyhow!(\"Amount in cannot be zero\"));\n        }\n\n        if params.minimum_amount_out == 0 {\n            return Err(anyhow::anyhow!(\"Minimum amount out cannot be zero\"));\n        }\n\n        if params.minimum_amount_out > params.amount_in * 10 {\n            return Err(anyhow::anyhow!(\n                \"Minimum amount out suspiciously high ({}x input). Check parameters.\",\n                params.minimum_amount_out / params.amount_in\n            ));\n        }\n\n        let slippage = Self::calculate_slippage(params.amount_in, params.minimum_amount_out);\n        if slippage > 50.0 {\n            warn!(\"?????? High slippage tolerance: {:.2}%\", slippage);\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_slippage_calculation() {\n        assert_eq!(OrcaSwapBuilder::calculate_slippage(100, 95), 5.0);\n        assert_eq!(OrcaSwapBuilder::calculate_slippage(1000, 950), 5.0);\n        assert_eq!(OrcaSwapBuilder::calculate_slippage(100, 100), 0.0);\n    }\n\n    #[test]\n    fn test_swap_params_validation() {\n        let rpc_url = \"https://api.mainnet-beta.solana.com\".to_string();\n        let rpc_client = Arc::new(SolanaRpcClient::new(rpc_url));\n        let pool_registry = Arc::new(PoolRegistry::new(rpc_client.clone()));\n        let builder = OrcaSwapBuilder::new(rpc_client, pool_registry).unwrap();\n\n        // Valid params\n        let valid = SwapParams {\n            amount_in: 100,\n            minimum_amount_out: 95,\n            expected_amount_out: Some(100),\n            swap_a_to_b: true,\n        };\n        assert!(builder.validate_swap_params(&valid).is_ok());\n\n        // Zero amount in\n        let zero_in = SwapParams {\n            amount_in: 0,\n            minimum_amount_out: 95,\n            expected_amount_out: Some(95),\n            swap_a_to_b: true,\n        };\n        assert!(builder.validate_swap_params(&zero_in).is_err());\n\n        // Zero minimum out\n        let zero_out = SwapParams {\n            amount_in: 100,\n            minimum_amount_out: 0,\n            expected_amount_out: Some(100),\n            swap_a_to_b: true,\n        };\n        assert!(builder.validate_swap_params(&zero_out).is_err());\n    }\n}","nrTokens":0,"nrLines":254,"files":[{"filePath":"src/orca.rs","startLine":370,"endLine":623},{"filePath":"clean_arb_bot/src/orca.rs","startLine":331,"endLine":531}]}},{"DuplicationClone":{"cloneLines":"match tokio::time::timeout(\n                        Duration::from_secs(10),\n                        http_clone.submit_bundle_safe(request.transactions.clone())\n                    ).await {\n                        Ok(Ok(uuid)) => {\n                            info!(\"???? JITO bundle submitted via HTTP: {}\"","nrTokens":0,"nrLines":6,"files":[{"filePath":"clean_arb_bot/src/jito_submitter.rs","startLine":184,"endLine":189},{"filePath":"clean_arb_bot/src/jito_submitter.rs","startLine":152,"endLine":157}]}},{"DuplicationClone":{"cloneLines":") -> f64 {\n    let price_diff = if expected_price > actual_price {\n        expected_price - actual_price\n    } else {\n        actual_price - expected_price\n    };\n\n    if expected_price == Decimal::ZERO {\n        return 0.0;\n    }\n\n    let slippage_pct = (price_diff / expected_price) * Decimal::from(100);\n    slippage_pct.to_f64().unwrap_or(0.0)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rust_decimal_macros::dec;\n\n    #[test]\n    fn test_calculate_slippage() {\n        let expected = dec!(1.0);\n        let market = dec!(1.01);\n        let volatility = 5.0;\n\n        let slippage = calculate_slippage(expected, market, volatility);\n\n        // Should be 0.01 (price diff) + 0.05 (5% volatility) = 0.06\n        assert_eq!(slippage, dec!(0.06));\n    }\n\n    #[test]\n    fn test_is_slippage_acceptable() {\n        let expected = dec!(1.0);\n        let actual_good = dec!(1.01); // 1% slippage\n        let actual_bad = dec!(1.10); // 10% slippage\n\n        // With 5% volatility and 2% max slippage = 7% total allowed\n        assert!(is_slippage_acceptable(expected, actual_good, 5.0, 2.0));\n        assert!(!is_slippage_acceptable(expected, actual_bad, 5.0, 2.0));\n    }\n\n    #[test]\n    fn test_slippage_percentage() {\n        let expected = dec!(1.0);\n        let actual = dec!(1.015);\n\n        let pct = calculate_slippage_percentage(expected, actual);\n\n        // Should be 1.5%\n        assert!((pct - 1.5).abs() < 0.001);\n    }\n}","nrTokens":0,"nrLines":54,"files":[{"filePath":"src/slippage.rs","startLine":110,"endLine":163},{"filePath":"clean_arb_bot/src/slippage.rs","startLine":114,"endLine":167}]}},{"DuplicationClone":{"cloneLines":")?;\n\n        info!(\n            \"??? Built SECURE transaction: 3 swaps + 1 tip = {} total instructions\",\n            transaction.message.instructions.len()\n        );\n\n        Ok(transaction)\n    }\n\n    /// Build triangle transaction with PROFIT-BASED JITO tip (RECOMMENDED)\n    ///\n    /// This method automatically calculates optimal tip based on expected profit:\n    /// - Minimum: 100,000 lamports (0.0001 SOL) - 95th percentile\n    /// - Base: 10% of expected profit\n    /// - Maximum: 20% of expected profit\n    ///\n    /// # Arguments\n    /// * `leg1` - First swap parameters\n    /// * `leg2` - Second swap parameters\n    /// * `leg3` - Third swap parameters\n    /// * `wallet` - User's wallet (signer)\n    /// * `expected_profit_lamports` - Expected profit from arbitrage\n    /// * `tip_account` - Jito tip account pubkey\n    ///\n    /// # Returns\n    /// Complete signed transaction ready for JITO bundle submission\n    ///\n    /// # Example\n    /// ```ignore\n    /// // Arbitrage with 0.5 SOL expected profit\n    /// let tx = swap_executor.build_triangle_with_profit_based_tip(\n    ///     leg1, leg2, leg3,\n    ///     &wallet,\n    ///     500_000_000, // 0.5 SOL expected profit\n    ///     &tip_account,\n    /// ).await?;\n    /// // Tip will be: 50,000,000 lamports (10% of 0.5 SOL = 0.05 SOL)\n    /// ```\n    pub async fn build_triangle_with_profit_based_tip<T: Signer>(\n        &self,\n        leg1: (&DexType, &str, &SwapParams),\n        leg2: (&DexType, &str, &SwapParams),\n        leg3: (&DexType, &str, &SwapParams),\n        wallet: &T,\n        expected_profit_lamports: u64,\n        tip_account: &Pubkey,\n    ) -> Result<Transaction> {\n        // Calculate optimal tip based on profit (requires JITO client)\n        let tip_lamports = if let Some(jito_client) = &self.jito_client {\n            jito_client.calculate_optimal_tip_with_profit(Some(expected_profit_lamports))\n        } else {\n            // Fallback if no JITO client: 10% of profit, min 100k lamports\n            let tip = (expected_profit_lamports as f64 * 0.10) as u64;\n            tip.max(100_000)\n        };\n\n        info!(\"???? Profit-based tip calculation:\");\n        info!(\n            \"   Expected profit: {} lamports (0.{:06} SOL)\",\n            expected_profit_lamports,\n            expected_profit_lamports / 1000\n        );\n        info!(\n            \"   Calculated tip: {} lamports (0.{:06} SOL)\",\n            tip_lamports,\n            tip_lamports / 1000\n        );\n        info!(\n            \"   Tip percentage: {:.1}%\",\n            (tip_lamports as f64 / expected_profit_lamports as f64) * 100.0\n        );\n\n        // Build transaction with calculated tip\n        self.build_triangle_with_tip(leg1, leg2, leg3, wallet, tip_lamports, tip_account)","nrTokens":0,"nrLines":75,"files":[{"filePath":"src/swap_executor.rs","startLine":415,"endLine":489},{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":414,"endLine":482}]}},{"DuplicationClone":{"cloneLines":")\n                            .await\n                            {\n                                Ok(Ok(uuid)) => {\n                                    info!(\"???? JITO bundle submitted via HTTP (fallback): {}\", uuid);\n                                    Ok(uuid)\n                                }\n                                Ok(Err(e2)) => Err(anyhow::anyhow!(\n                                    \"Both gRPC and HTTP failed: gRPC={}, HTTP={}\",\n                                    e,\n                                    e2\n                                )),\n                                Err(_) => {","nrTokens":0,"nrLines":13,"files":[{"filePath":"src/jito_submitter.rs","startLine":165,"endLine":177},{"filePath":"clean_arb_bot/src/jito_submitter.rs","startLine":155,"endLine":161}]}},{"DuplicationClone":{"cloneLines":"::new(rpc_client, pool_registry).unwrap();\n\n        // Valid params\n        let valid = SwapParams {\n            amount_in: 100,\n            minimum_amount_out: 95,\n            expected_amount_out: Some(100),\n            swap_a_to_b: true,\n        };\n        assert!(builder.validate_swap_params(&valid).is_ok());\n\n        // Zero amount in\n        let zero_in = SwapParams {\n            amount_in: 0,\n            minimum_amount_out: 95,\n            expected_amount_out: Some(95),\n            swap_a_to_b: true,\n        };\n        assert!(builder.validate_swap_params(&zero_in).is_err());\n\n        // Zero minimum out\n        let zero_out = SwapParams {\n            amount_in: 100,\n            minimum_amount_out: 0,\n            expected_amount_out: Some(100),\n            swap_a_to_b: true,\n        };\n        assert!(builder.validate_swap_params(&zero_out).is_err());\n    }\n}","nrTokens":0,"nrLines":30,"files":[{"filePath":"clean_arb_bot/src/orca.rs","startLine":551,"endLine":580},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":502,"endLine":531}]}},{"DuplicationClone":{"cloneLines":";\n\n/// Cached price entry with timestamp for staleness checking\n#[derive(Debug, Clone)]\npub struct CachedPrice {\n    pub data: TokenPrice,\n    pub cached_at: Instant,\n}\n\n/// Price information from ShredStream service\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TokenPrice {\n    pub token_mint: String,\n    pub dex: String,\n    pub price_sol: f64,\n    pub last_update: String,\n    pub volume_24h: f64,\n    pub pool_address: String, // CRITICAL FIX: Full 44-char address for DEX swaps\n}\n\n/// Response from /prices endpoint\n#[derive(Debug, Deserialize)]\npub struct PricesResponse {\n    pub prices: Vec<TokenPrice>,\n    pub total_tokens: usize,\n}\n\n/// Client for ShredStream service REST API\n/// CYCLE-7: Enhanced with rate limiting (Grok recommendation)\n/// OPTIMIZED: Lock-free concurrent cache with staleness detection\npub struct ShredStreamClient {\n    /// Service endpoint URL\n    service_url: String,\n    /// HTTP client\n    client: reqwest::Client,\n    /// Cached prices by token_mint + dex (concurrent access)\n    /// OPTIMIZATION: DashMap allows lock-free concurrent reads/writes\n    price_cache: Arc<DashMap<String, CachedPrice>>,\n    /// CYCLE-7: Rate limiter (prevents API bans on 429 responses)\n    /// Token bucket: 10 requests per second (600/minute)\n    rate_limiter: GovernorRateLimiter<NotKeyed, InMemoryState, DefaultClock>,\n    /// Last successful fetch timestamp (for delta updates)\n    last_fetch: Option<Instant>,\n    /// Cache TTL in seconds (prices older than this are stale)\n    cache_ttl_secs: u64,\n}\n\nimpl ShredStreamClient {\n    /// Create new ShredStream service client\n    /// CYCLE-6: Optimized with gzip compression and connection pooling\n    /// CYCLE-7: Enhanced with rate limiting (Grok recommendation)\n    pub fn new(service_url: String) -> Self {\n        // Build client with gzip support and optimized settings\n        let client = reqwest::Client::builder()\n            .gzip(true) // Enable gzip decompression\n            .pool_max_idle_per_host(2) // Connection pooling\n            .timeout(std::time::Duration::from_secs(10))\n            .build()\n            .unwrap_or_else(|_| reqwest::Client::new());\n\n        // CYCLE-7: Rate limiter - 10 requests per second (Grok recommendation)\n        // Token bucket algorithm prevents API bans on high-frequency requests\n        let quota = Quota::per_second(NonZeroU32::new(10).unwrap());\n        let rate_limiter = GovernorRateLimiter::direct(quota);\n\n        Self {\n            service_url,\n            client,\n            price_cache: Arc::new(DashMap::new()),\n            rate_limiter,\n            last_fetch: None,\n            cache_ttl_secs: 5, // 5 second cache TTL (prices are fresh for 5s)\n        }\n    }\n\n    /// Check if we need to fetch new prices (cache staleness check)\n    /// OPTIMIZATION: Skip fetching if cache is still fresh\n    pub fn needs_update(&self) -> bool {\n        match self.last_fetch {\n            Some(last) => last.elapsed().as_secs() >= self.cache_ttl_secs,\n            None => true, // Never fetched, needs update\n        }\n    }\n\n    /// Fetch latest prices from service\n    /// CYCLE-6: Optimized with streaming JSON, gzip, and exponential backoff retry\n    /// CYCLE-7: Added timeout guard for network jitter protection + rate limiting\n    /// OPTIMIZATION: Skip if cache is fresh, use concurrent DashMap for updates\n    pub async fn fetch_prices(&mut self) -> Result<usize> {\n        // OPTIMIZATION: Skip if cache is still fresh\n        if !self.needs_update() {\n            let cached_count = self.price_cache.len();\n            debug!(\n                \"??? Cache still fresh ({} prices, TTL: {}s)\",\n                cached_count, self.cache_ttl_secs\n            );\n            return Ok(cached_count);\n        }\n        // CYCLE-7: Rate limiting check (prevents API bans)\n        // If rate limit exceeded, wait until token available\n        self.rate_limiter.until_ready().await;\n\n        // CYCLE-6: Performance benchmark timing\n        let fetch_start = std::time::Instant::now();\n\n        // CRITICAL FIX: Endpoint is /prices not /api/prices\n        let url = format!(\"{}/prices\", self.service_url);\n\n        // CYCLE-7: Timeout guard to protect against network jitter (5s for all retries)\n        // Prevents hanging during network issues (Grok recommendation)\n        let timeout_result = timeout(Duration::from_secs(5), async {\n            // CYCLE-6: Retry with exponential backoff (100ms, 200ms, 400ms, 800ms, 1600ms)\n            let retry_strategy = ExponentialBackoff::from_millis(100).take(5);\n\n            Retry::spawn(retry_strategy, || async {\n                // CYCLE-6: Request with gzip compression enabled\n                match self\n                    .client\n                    .get(&url)\n                    .header(\"Accept-Encoding\", \"gzip\")\n                    .send()\n                    .await\n                {\n                    Ok(response) => {\n                        // CYCLE-6: Stream response bytes instead of buffering entire response\n                        let bytes = response.bytes().await.map_err(|e| {\n                            warn!(\"??? Failed to read response bytes: {}\", e);\n                            anyhow::anyhow!(\"Response bytes error: {}\", e)\n                        })?;\n\n                        debug!(\n                            \"???? Received {} bytes (gzip-compressed if supported)\",\n                            bytes.len()\n                        );\n\n                        // Parse JSON directly from bytes (more efficient than string conversion)\n                        let prices_response: PricesResponse = match serde_json::from_slice(&bytes) {\n                            Ok(parsed) => parsed,\n                            Err(e) => {\n                                warn!(\"??? Failed to parse response: {}\", e);\n                                // Only log first 500 bytes for debugging (avoid huge logs)\n                                let preview =\n                                    String::from_utf8_lossy(&bytes[..bytes.len().min(500)]);\n                                warn!(\"???? Response preview: {}\", preview);\n                                return Err(anyhow::anyhow!(\"JSON parse error: {}\", e));\n                            }\n                        };\n\n                        Ok(prices_response)\n                    }\n                    Err(e) => {\n                        warn!(\"?????? ShredStream fetch failed (will retry): {}\", e);\n                        Err(anyhow::anyhow!(\"Request failed: {}\", e))\n                    }\n                }\n            })\n            .await\n        })\n        .await;\n\n        // Handle timeout\n        let result = match timeout_result {\n            Ok(retry_result) => retry_result,\n            Err(_) => {\n                warn!(\"?????? ShredStream fetch timed out after 5s (network jitter protection)\");\n                return Err(anyhow::anyhow!(\"Fetch timeout exceeded\"));\n            }\n        };\n\n        match result {\n            Ok(prices_response) => {\n                // Update cache with timestamps\n                let now = Instant::now();\n                let fetched_count = prices_response.prices.len();\n\n                // OPTIMIZATION: Batch update using concurrent DashMap\n                for price in prices_response.prices {\n                    let cache_key = format!(\"{}_{}\", price.token_mint, price.dex);\n                    let cached_price = CachedPrice {\n                        data: price,\n                        cached_at: now,\n                    };\n                    self.price_cache.insert(cache_key, cached_price);\n                }\n\n                // Update last fetch timestamp\n                self.last_fetch = Some(now);\n\n                // CYCLE-6: Log fetch performance\n                let fetch_duration = fetch_start.elapsed();\n                info!(\n                    \"??? Fetched {} prices in {:?} (total_tokens: {}, gzip enabled, cache TTL: {}s)\",\n                    fetched_count,\n                    fetch_duration,\n                    prices_response.total_tokens,\n                    self.cache_ttl_secs\n                );\n                Ok(fetched_count)\n            }\n            Err(e) => {\n                warn!(\"??? Failed to fetch prices after retries: {}\", e);\n                Err(anyhow::anyhow!(\n                    \"ShredStream service unavailable after retries: {}\",\n                    e\n                ))\n            }\n        }\n    }\n\n    /// Get price for specific token on specific DEX\n    pub fn get_price(&self, token_mint: &str, dex: &str) -> Option<f64> {\n        let cache_key = format!(\"{}_{}\", token_mint, dex);\n        self.price_cache\n            .get(&cache_key)\n            .map(|entry| entry.data.price_sol)\n    }\n\n    /// Get all prices for a token across all DEXs\n    pub fn get_token_prices(&self, token_mint: &str) -> Vec<(String, f64)> {\n        let mut results = Vec::new();\n        for entry in self.price_cache.iter() {\n            if entry.value().data.token_mint == token_mint {\n                results.push((entry.value().data.dex.clone(), entry.value().data.price_sol));\n            }\n        }\n        results\n    }\n\n    /// Get all cached prices (returns HashMap for compatibility)\n    /// OPTIMIZATION: Only includes non-stale prices\n    pub fn get_all_prices(&self) -> HashMap<String, TokenPrice> {\n        let mut result = HashMap::new();\n        let now = Instant::now();\n        let max_age = Duration::from_secs(self.cache_ttl_secs * 2); // Allow 2x TTL for reads\n\n        for entry in self.price_cache.iter() {\n            // Skip stale entries\n            if now.duration_since(entry.value().cached_at) <= max_age {\n                let cache_key = entry.key().clone();\n                let token_price = entry.value().data.clone();\n                result.insert(cache_key, token_price);\n            }\n        }\n        result\n    }\n}","nrTokens":0,"nrLines":246,"files":[{"filePath":"src/shredstream_client.rs","startLine":15,"endLine":260},{"filePath":"clean_arb_bot/src/shredstream_client.rs","startLine":11,"endLine":236}]}},{"DuplicationClone":{"cloneLines":"};\n\n            // Create ATA instruction\n            let create_ata_ix = spl_associated_token_account::instruction::create_associated_token_account(\n                user_pubkey,      // Payer\n                user_pubkey,      // Owner of new account\n                token_mint,       // Token mint\n                &spl_token::id(), // Token program ID\n            );\n\n            setup_instructions.push(create_ata_ix);\n            info!(\"??? ATA creation instruction added for output - account will be created in transaction\");\n        } else","nrTokens":0,"nrLines":13,"files":[{"filePath":"clean_arb_bot/src/meteora.rs","startLine":241,"endLine":253},{"filePath":"clean_arb_bot/src/meteora.rs","startLine":210,"endLine":256}]}},{"DuplicationClone":{"cloneLines":")\n                            .await\n                            .context(format!(\n                                \"Failed to resolve pool address for {} (tried DLMM, V1, V2)\",\n                                pool_short_id\n                            ))?\n                    }\n                }\n            }\n        };\n\n        debug!(\n            \"??? Resolved pool {} to address: {}\",\n            pool_short_id, pool_address\n        );\n\n        // GROK GHOST POOL SOLUTION - STEP 3: Early validation check (should be cached from arbitrage engine)\n        // This is a safety fallback - normally pools are validated before execution\n\n        // MARKET CHAOS MODE - Skip ghost pool validation for speed\n        let skip_ghost_pool_check = std::env::var(\"SKIP_GHOST_POOL_CHECK\")\n            .unwrap_or_else(|_| \"false\".to_string())\n            .to_lowercase()\n            == \"true\";\n\n        if !skip_ghost_pool_check {\n            if self.pool_registry.is_pool_valid_cached(pool_short_id).await != Some(true) {\n                // Rare case: validate on-demand if not cached\n                warn!(\n                    \"?????? Pool {} not in cache, validating on-demand\",\n                    pool_short_id\n                );\n                self.pool_registry\n                    .validate_pools_batch(&[pool_short_id.to_string()])\n                    .await?;\n\n                // Double-check after validation\n                if self.pool_registry.is_pool_valid_cached(pool_short_id).await != Some(true) {\n                    return Err(anyhow::anyhow!(\n                        \"?????? Ghost pool detected: {} (failed validation)\",\n                        pool_short_id\n                    ));\n                }\n            }\n        }\n\n        debug!(\"??? Pool validated (cached), proceeding to ownership check\");\n\n        // CRITICAL: Validate this is actually a Meteora pool (DLMM, DAMM V1, or DAMM V2)\n        // SKIP if SKIP_GHOST_POOL_CHECK is enabled (market chaos mode)\n        if !skip_ghost_pool_check {\n            let account_owner =\n                self.rpc_client\n                    .get_account_owner(&pool_address)\n                    .context(format!(\n                        \"Failed to fetch account owner for pool {}\",\n                        pool_address\n                    ))?;\n\n            let damm_v1_program_id: Pubkey = Self::DAMM_V1_PROGRAM_ID.parse().unwrap();\n            let damm_v2_program_id: Pubkey = Self::DAMM_V2_PROGRAM_ID.parse().unwrap();\n\n            // Accept DLMM, DAMM V1, and DAMM V2 program IDs\n            if account_owner != self.program_id\n                && account_owner != damm_v1_program_id\n                && account_owner != damm_v2_program_id\n            {\n                return Err(anyhow::anyhow!(\n                    \"Pool {} not owned by Meteora DLMM, DAMM V1, or DAMM V2. Owner: {}, Expected: {} or {} or {}\",\n                    pool_address, account_owner, self.program_id, damm_v1_program_id, damm_v2_program_id\n                ));\n            }\n\n            let pool_type = if account_owner == self.program_id {\n                \"DLMM\"\n            } else if account_owner == damm_v1_program_id {\n                \"DAMM V1\"\n            } else {\n                \"DAMM V2\"\n            };\n            debug!(\n                \"??? Validated Meteora {} pool ownership: {}\",\n                pool_type, account_owner\n            );\n        } else {\n            debug!(\"?????? Skipping Meteora ownership validation (SKIP_GHOST_POOL_CHECK=true)\");\n        }\n\n        // Get pool info for token mints and reserves\n        let pool_info = self.pool_registry.get_pool(pool_short_id).ok_or_else(|","nrTokens":0,"nrLines":90,"files":[{"filePath":"src/meteora.rs","startLine":95,"endLine":184},{"filePath":"clean_arb_bot/src/meteora.rs","startLine":93,"endLine":161}]}},{"DuplicationClone":{"cloneLines":") -> u64 {\n        if use_jito {\n            // With JITO: tip = 10% of gross, so net = gross * 0.9 - fixed_costs\n            // Solving: net = gross * 0.9 - fixed_costs\n            // gross = (net + fixed_costs) / 0.9\n\n            let fixed_costs = 5_000 + 400; // base tx fee + compute fee = 5,400 lamports\n            let min_gross = ((desired_net_profit_lamports + fixed_costs) as f64 / 0.9) as u64;\n\n            // Round up to ensure we definitely cover costs\n            min_gross + 1_000 // +1000 safety buffer\n        } else {\n            // Without JITO: net = gross - fixed_costs (no percentage-based tip)\n            let fixed_costs = 5_000 + 400 + 50_000; // base + compute + priority = 55,400 lamports\n            desired_net_profit_lamports + fixed_costs\n        }\n    }\n\n    /// Get net profit after all costs\n    /// Uses checked arithmetic to prevent overflow\n    pub fn net_profit(&self, gross_profit_lamports: u64) -> i64 {\n        (gross_profit_lamports as i64).saturating_sub(self.total_cost_lamports as i64)\n    }\n\n    /// Check if arbitrage is profitable after costs\n    pub fn is_profitable(&self, gross_profit_lamports: u64) -> bool {\n        self.net_profit(gross_profit_lamports) > 0\n    }\n\n    /// Get profit retention percentage\n    pub fn retention_percentage(&self, gross_profit_lamports: u64) -> f64 {\n        if gross_profit_lamports == 0 {\n            return 0.0;\n        }\n        let net = self.net_profit(gross_profit_lamports);\n        if net <= 0 {\n            return 0.0;\n        }\n        (net as f64 / gross_profit_lamports as f64) * 100.0\n    }\n\n    /// Get gas/tip ratio (gas percentage, tip percentage)\n    ///\n    /// Industry recommendation: 60% gas / 40% tip\n    /// Returns (gas_percentage, tip_percentage) of total fees\n    ///\n    /// # Examples\n    /// ```\n    /// let costs = ArbitrageCosts::calculate(1_000_000, true);\n    /// let (gas_pct, tip_pct) = costs.gas_tip_ratio();\n    /// // Small arb: ~5% gas, ~95% tip (due to minimum tip requirement)\n    ///\n    /// let large_costs = ArbitrageCosts::calculate(500_000_000, true);\n    /// let (gas_pct, tip_pct) = large_costs.gas_tip_ratio();\n    /// // Large arb: ~0.01% gas, ~99.99% tip (tip scales with profit)\n    /// ```\n    pub fn gas_tip_ratio(&self) -> (f64, f64) {\n        if self.total_cost_lamports == 0 {\n            return (0.0, 0.0);\n        }\n\n        let gas_cost =\n            self.base_tx_fee_lamports + self.compute_fee_lamports + self.priority_fee_lamports;\n        let tip_cost = self.jito_tip_lamports;\n\n        let gas_percentage = (gas_cost as f64 / self.total_cost_lamports as f64) * 100.0;\n        let tip_percentage = (tip_cost as f64 / self.total_cost_lamports as f64) * 100.0;\n\n        (gas_percentage, tip_percentage)\n    }\n}\n\n/// Calculate recommended minimum gross profit threshold (REASONABLE STRATEGY)\n///\n/// This is the minimum gross profit we should target to ensure profitability\n/// after all costs with industry-standard JITO tips.\n///\n/// # Arguments\n/// * `use_jito` - Whether using JITO bundles\n///\n/// # Returns\n/// Recommended minimum gross profit in lamports\n///\n/// # Strategy:\n/// - Reasonable minimum tip: 100,000 lamports (0.0001 SOL)\n/// - Industry-standard 3-7% tips for most arbs\n/// - Scaled gas fees for priority processing\n///\n/// # Example Results:\n/// - With JITO: ~1M lamports (0.001 SOL) minimum for reliable execution\n/// - Without JITO: 300k lamports (0.0003 SOL)\n/// - Lower threshold allows capturing smaller but profitable opportunities\npub fn recommended_min_gross_profit(use_jito: bool) -> u64 {\n    if use_jito {\n        // GROK RECOMMENDATION (2025-10-07): Increase to 0.01 SOL for reliability\n        // For 0.01 SOL gross profit:\n        // - DEX fees (0.75%): 75,000 lamports\n        // - JITO tip (3-5%, min 100k): 300,000 lamports (3%)\n        // - Gas fees: 1.5x tip ~450,000 lamports\n        // - Total costs: ~825,000 lamports\n        // - Net profit: ~9,175,000 lamports (91.75% retention)\n        //\n        // UPDATED: 0.01 SOL minimum gross profit\n        // - Aligns with JITO best practices\n        // - Ensures reliable bundle landing\n        // - Better profit margins after fees\n        // - Matches test expectations\n        10_000_000 // 0.01 SOL minimum (Grok-approved)\n    } else {\n        // Without JITO: Higher base costs\n        // Base: 5,000 + compute: 400 + priority: 50,000 = 55,400\n        // RECOMMENDED: 5x safety = 277,000 ??? 300,000 lamports (0.0003 SOL)\n        300_000\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_jito_costs_small_profit_aggressive() {\n        // Small arbitrage: 0.001 SOL profit - NOW UNPROFITABLE with aggressive strategy\n        let costs = ArbitrageCosts::calculate(1_000_000, true);\n\n        // NEW: Minimum tip is 1M lamports (0.001 SOL)\n        assert_eq!(costs.jito_tip_lamports, 1_000_000); // Aggressive minimum\n        assert_eq!(costs.base_tx_fee_lamports, 5_000); // Small profit, baseline gas\n        assert_eq!(costs.compute_fee_lamports, 400); // Baseline compute\n        assert_eq!(costs.priority_fee_lamports, 0); // Not used with JITO\n        assert_eq!(costs.total_cost_lamports, 1_005_400);\n\n        // Net profit: 1,000,000 - 1,005,400 = -5,400 lamports (LOSS!)\n        assert_eq!(costs.net_profit(1_000_000), -5_400);\n        assert!(!costs.is_profitable(1_000_000)); // Not profitable anymore!\n    }\n\n    #[test]\n    fn test_jito_costs_medium_profit_aggressive() {\n        // Medium arbitrage: 0.01 SOL profit - breakeven point\n        let costs = ArbitrageCosts::calculate(10_000_000, true);\n\n        // 10% of 10M = 1M, which equals minimum\n        assert_eq!(costs.jito_tip_lamports, 1_000_000); // 10% tip\n        assert_eq!(costs.base_tx_fee_lamports, 5_000); // Still baseline\n        assert_eq!(costs.compute_fee_lamports, 400); // Still baseline\n        assert_eq!(costs.total_cost_lamports, 1_005_400);\n\n        // Net profit: 10,000,000 - 1,005,400 = 8,994,600 lamports\n        assert_eq!(costs.net_profit(10_000_000), 8_994_600);\n        assert!(costs.is_profitable(10_000_000));\n\n        // Retention: ~90%\n        let retention = costs.retention_percentage(10_000_000);\n        assert!((retention - 89.95).abs() < 0.1);\n    }\n\n    #[test]\n    fn test_jito_costs_large_profit_aggressive() {\n        // Large arbitrage: 0.5 SOL profit - now uses 12% tip (medium range)\n        let costs = ArbitrageCosts::calculate(500_000_000, true);\n\n        // 0.5 SOL is in medium range (0.1-1 SOL): 12-15% tip\n        // scale = 0.12 + (0.5 - 0.1) * 0.033 = 0.12 + 0.0132 = 0.1332 ??? 13.32%\n        // tip = 500M * 0.1332 ??? 66.6M\n        let expected_tip = (500_000_000.0 * 0.1332) as u64;\n        assert!((costs.jito_tip_lamports as i64 - expected_tip as i64).abs() < 100_000);\n\n        // Gas fees scaled for medium profit\n        // Base: 5k + (0.5-0.1)*22222 = 5k + 8888.8 ??? 13,889\n        assert!(costs.base_tx_fee_lamports > 10_000);\n        assert!(costs.base_tx_fee_lamports < 20_000);\n\n        // Compute: 400 + (0.5-0.1)*1777 = 400 + 710.8 ??? 1,111\n        assert!(costs.compute_fee_lamports > 800);\n        assert!(costs.compute_fee_lamports < 1_500);\n\n        // Net profit lower due to higher costs, but still very profitable\n        assert!(costs.net_profit(500_000_000) > 400_000_000); // Still >0.4 SOL net\n        assert!(costs.is_profitable(500_000_000));\n\n        // Retention slightly lower due to scaled costs: ~80-88%\n        let retention = costs.retention_percentage(500_000_000);\n        assert!(retention > 80.0);\n        assert!(retention < 90.0);\n    }\n\n    #[test]\n    fn test_jito_costs_very_large_profit_aggressive() {\n        // Very large arbitrage: 2 SOL profit - uses 15-20% tip\n        let costs = ArbitrageCosts::calculate(2_000_000_000, true);\n\n        // 2 SOL is in large range (>1 SOL): 15-20% tip\n        // scale = 0.15 + ((2.0 - 1.0) * 0.05).min(0.05) = 0.15 + 0.05 = 0.20 (20% cap)\n        // tip = 2B * 0.20 = 400M\n        let expected_tip = (2_000_000_000.0 * 0.20) as u64;\n        assert!((costs.jito_tip_lamports as i64 - expected_tip as i64).abs() < 1_000_000);\n\n        // Gas fees at maximum scaling\n        // Base: 25k + (2.0-1.0)*25k = 50k (capped)\n        assert_eq!(costs.base_tx_fee_lamports, 50_000);\n\n        // Compute: 2k + (2.0-1.0)*2k = 4k (capped)\n        assert_eq!(costs.compute_fee_lamports, 4_000);\n\n        // Still highly profitable despite 20% tip\n        assert!(costs.net_profit(2_000_000_000) > 1_500_000_000); // >1.5 SOL net\n        assert!(costs.is_profitable(2_000_000_000));\n\n        // Retention: ~75-80% due to 20% tip\n        let retention = costs.retention_percentage(2_000_000_000);\n        assert!(retention > 75.0);\n        assert!(retention < 82.0);\n    }\n\n    #[test]\n    fn test_min_gross_profit_calculation() {\n        // Want 0.1 SOL net profit using JITO\n        let min_gross = ArbitrageCosts::min_gross_profit_for_net(100_000_000, true);\n\n        // Should be ~111M (100M / 0.9)\n        assert!(min_gross >= 111_000_000);\n        assert!(min_gross <= 112_000_000);\n\n        // Verify it actually gives us the desired net profit\n        let costs = ArbitrageCosts::calculate(min_gross, true);\n        let actual_net = costs.net_profit(min_gross);\n\n        // Should be close to 100M (within 1%)\n        assert!(actual_net >= 99_000_000);\n        assert!(actual_net <= 101_000_000);\n    }\n\n    #[test]\n    fn test_recommended_minimums_aggressive() {\n        let min_jito = recommended_min_gross_profit(true);\n        let min_regular = recommended_min_gross_profit(false);\n\n        // NEW: JITO minimum is 10M lamports (0.01 SOL)\n        assert_eq!(min_jito, 10_000_000);\n        // Regular is 300k lamports (0.0003 SOL)\n        assert_eq!(min_regular, 300_000);\n\n        // JITO should be much higher (needs aggressive tip)\n        assert!(min_jito > min_regular);\n\n        // Check profitability at recommended minimums\n        let costs_jito = ArbitrageCosts::calculate(min_jito, true);\n        let costs_regular = ArbitrageCosts::calculate(min_regular, false);\n\n        // JITO should have good margin: ~9M net (90% retention)\n        assert!(costs_jito.net_profit(min_jito) > 8_000_000); // >0.008 SOL net\n        assert!(costs_regular.net_profit(min_regular) > 200_000); // >0.0002 SOL net\n    }\n\n    #[test]\n    fn test_unprofitable_small_arb_aggressive() {\n        // Very small arbitrage: 0.0001 SOL = 100k lamports - VERY unprofitable now\n        let costs = ArbitrageCosts::calculate(100_000, true);\n\n        // NEW: Minimum tip is 1M lamports (10x the profit!)\n        assert_eq!(costs.jito_tip_lamports, 1_000_000);\n        assert_eq!(costs.total_cost_lamports, 1_005_400);\n        assert!(!costs.is_profitable(100_000)); // Net = -905,400 (huge loss!)\n\n        // Even 0.001 SOL (1M lamports) is unprofitable\n        let costs_1m = ArbitrageCosts::calculate(1_000_000, true);\n        assert!(!costs_1m.is_profitable(1_000_000)); // Breaks even at best\n    }\n\n    #[test]\n    fn test_gas_tip_ratio_aggressive() {\n        // Small arbitrage: EXTREMELY tip-heavy due to aggressive minimum\n        let small_costs = ArbitrageCosts::calculate(1_000_000, true);\n        let (gas_pct_small, tip_pct_small) = small_costs.gas_tip_ratio();\n\n        // Gas: 5,400 lamports, Tip: 1,000,000 lamports, Total: 1,005,400\n        assert!((gas_pct_small - 0.54).abs() < 0.1); // ~0.54% gas\n        assert!((tip_pct_small - 99.46).abs() < 0.1); // ~99.46% tip\n        assert!((gas_pct_small + tip_pct_small - 100.0).abs() < 0.1); // Should sum to 100%\n\n        // Medium arbitrage: Scaled gas, but still tip-heavy\n        let medium_costs = ArbitrageCosts::calculate(500_000_000, true);\n        let (gas_pct_med, tip_pct_med) = medium_costs.gas_tip_ratio();\n\n        // 0.5 SOL: 13.32% tip (66.6M), scaled gas (~15k)\n        // Tip still dominates even with scaled costs\n        assert!(gas_pct_med < 1.0); // <1% gas\n        assert!(tip_pct_med > 99.0); // >99% tip\n\n        // Very large arbitrage: 20% tip with maxed gas\n        let large_costs = ArbitrageCosts::calculate(2_000_000_000, true);\n        let (gas_pct_large, tip_pct_large) = large_costs.gas_tip_ratio();\n\n        // 2 SOL: 20% tip (400M), maxed gas (50k + 4k = 54k)\n        // Tip: 400M, Gas: 54k, Total: ~400.054M\n        assert!(gas_pct_large < 0.1); // <0.1% gas (54k out of 400M)\n        assert!(tip_pct_large > 99.9); // >99.9% tip\n        assert!((gas_pct_large + tip_pct_large - 100.0).abs() < 0.1); // Should sum to 100%\n    }\n}","nrTokens":0,"nrLines":301,"files":[{"filePath":"src/cost_calculator.rs","startLine":281,"endLine":581},{"filePath":"clean_arb_bot/src/cost_calculator.rs","startLine":278,"endLine":577}]}},{"DuplicationClone":{"cloneLines":")?;\n\n        // Simulate first\n        info!(\"???? Simulating triangle transaction...\");\n        let sim_result = self.rpc_client.simulate_transaction(&transaction)?;\n\n        if !sim_result {\n            return Err(anyhow::anyhow!(\n                \"Triangle arbitrage simulation failed - would revert on-chain. \\\n                Likely slippage or insufficient liquidity.\"\n            ));\n        }\n\n        info!(\"??? Triangle simulation passed\");\n\n        // Execute via JITO bundle or regular transaction\n        if use_jito && self.jito_client.is_some() {\n            info!(\"???? Submitting via JITO bundle for MEV protection...\");\n\n            // TODO: Use JITO client to submit bundle\n            // let bundle_id = self.jito_client.as_ref().unwrap()\n            //     .submit_bundle(&transaction)\n            //     .await?;\n\n            warn!(\"?????? JITO bundle submission not yet wired up\");\n            warn!(\"   Falling back to regular transaction\");\n\n            let signature = self.rpc_client.send_transaction(&transaction)?;\n            info!(\"??? Triangle transaction sent: {}\", signature);\n\n            Ok(signature.to_string())\n        } else {\n            // Regular transaction\n            let signature = self.rpc_client.send_transaction(&transaction)?;\n            info!(\"??? Triangle transaction sent: {}\", signature);\n\n            Ok(signature.to_string())\n        }\n    }\n\n    /// Build triangle transaction without submitting (for queue-based JITO submission)\n    pub async fn build_triangle_transaction<T: Signer>(\n        &self,\n        leg1: (&DexType, &str, &SwapParams),\n        leg2: (&DexType, &str, &SwapParams),\n        leg3: (&DexType, &str, &SwapParams),\n        wallet: &T,\n    ) -> Result<Transaction> {\n        let user_pubkey = wallet.pubkey();\n\n        // Build all three swap instructions (async for pool resolution)\n        let ix1 = self\n            .build_swap_instruction(leg1.0, leg1.1, leg1.2, &user_pubkey)\n            .await?;\n        let ix2 = self\n            .build_swap_instruction(leg2.0, leg2.1, leg2.2, &user_pubkey)\n            .await?;\n        let ix3 = self\n            .build_swap_instruction(leg3.0, leg3.1, leg3.2, &user_pubkey)\n            .await?;\n\n        // Get recent blockhash\n        let recent_blockhash = self.rpc_client.get_latest_blockhash()?;\n\n        // Build and return transaction\n        let transaction = self.build_transaction(vec![ix1, ix2, ix3], wallet, recent_blockhash)","nrTokens":0,"nrLines":66,"files":[{"filePath":"src/swap_executor.rs","startLine":282,"endLine":347},{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":286,"endLine":348}]}},{"DuplicationClone":{"cloneLines":";\n\n/// High-level swap executor that coordinates all swap operations\npub struct SwapExecutor {\n    /// RPC client for blockchain operations\n    rpc_client: Arc<SolanaRpcClient>,\n    /// Pool registry for address lookups\n    pool_registry: Arc<PoolRegistry>,\n    /// Meteora swap builder\n    meteora_builder: MeteoraSwapBuilder,\n    /// Orca swap builder\n    orca_builder: OrcaSwapBuilder,\n    /// PumpSwap swap builder\n    pumpswap_builder: PumpSwapSwapBuilder,\n    /// Raydium swap builder\n    raydium_builder: RaydiumSwapBuilder,\n    /// HumidiFi swap builder\n    humidifi_builder: Option<HumidiFiSwapBuilder>,\n    /// JITO bundle client for atomic execution (optional)\n    jito_client: Option<Arc<JitoBundleClient>>,\n    /// Default compute budget (micro-lamports per compute unit)\n    compute_unit_price: u64,\n    /// Default compute unit limit\n    compute_unit_limit: u32,\n}\n\nimpl SwapExecutor {\n    /// Create new swap executor\n    pub fn new(\n        rpc_client: Arc<SolanaRpcClient>,\n        pool_registry: Arc<PoolRegistry>,\n        jito_client: Option<Arc<JitoBundleClient>>,\n    ) -> Result<Self> {\n        // Initialize Meteora builder\n        let meteora_builder = MeteoraSwapBuilder::new(rpc_client.clone(), pool_registry.clone())","nrTokens":0,"nrLines":35,"files":[{"filePath":"src/swap_executor.rs","startLine":29,"endLine":63},{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":34,"endLine":70}]}},{"DuplicationClone":{"cloneLines":"),\n            ],\n            data,\n        };\n\n        debug!(\n            \"??? PumpSwap swap instruction built ({} accounts, Grok-verified)\",\n            instruction.accounts.len()\n        );\n        Ok(instruction)\n    }\n\n    /// Fetch pool state from on-chain data\n    /// Pool structure (300 bytes, FIXED 2025-10-14 - includes Anchor 8-byte discriminator):\n    /// Offset 0-8:   Anchor discriminator (8 bytes)\n    /// Offset 8-9:   pool_bump (1), index (2), creator (32)\n    /// Offset 43:  base_mint (32) ??? TOKEN MINT (was 35, +8 for discriminator)\n    /// Offset 75:  quote_mint (32) ??? SOL/WSOL MINT (was 67, +8)\n    /// Offset 107: lp_mint (32)\n    /// Offset 139: pool_base_token_account (32) ??? TOKEN VAULT (was 131, +8)\n    /// Offset 171: pool_quote_token_account (32) ??? SOL VAULT (was 163, +8)\n    /// Offset 203: lp_supply (8)\n    pub fn fetch_pool_info(&self, pool_address: &Pubkey) -> Result<PumpSwapPool> {\n        debug!(\"???? Fetching PumpSwap pool info for: {}\", pool_address);\n\n        // Fetch pool account data\n        let pool_data = self\n            .rpc_client\n            .get_account_data(pool_address)\n            .context(\"Failed to fetch PumpSwap pool data\")?;\n\n        if pool_data.len() < 203 {\n            return Err(anyhow::anyhow!(\n                \"Invalid PumpSwap pool data length: {} (expected >= 203)\",\n                pool_data.len()\n            ));\n        }\n\n        // Parse using CORRECT offsets (including Anchor 8-byte discriminator)\n        let base_mint = Pubkey::try_from(&pool_data[43..75])\n            .map_err(|_| anyhow::anyhow!(\"Invalid base mint pubkey\"))?;\n        let quote_mint = Pubkey::try_from(&pool_data[75..107])\n            .map_err(|_| anyhow::anyhow!(\"Invalid quote mint pubkey\"))?;\n        let pool_base_account = Pubkey::try_from(&pool_data[139..171])\n            .map_err(|_| anyhow::anyhow!(\"Invalid pool base account pubkey\"))?;\n        let pool_quote_account = Pubkey::try_from(&pool_data[171..203])\n            .map_err(|_| anyhow::anyhow!(\"Invalid pool quote account pubkey\"))?;\n\n        debug!(\"??? PumpSwap pool info parsed\");\n        debug!(\"   Base mint (token): {}\", base_mint);\n        debug!(\"   Quote mint (SOL): {}\", quote_mint);\n        debug!(\"   Pool base vault: {}\", pool_base_account);\n        debug!(\"   Pool quote vault: {}\", pool_quote_account);\n\n        Ok(PumpSwapPool {\n            pool_address: *pool_address,\n            base_mint,\n            quote_mint,\n            pool_base_account,\n            pool_quote_account,\n        })\n    }\n\n    /// Validate that pool is PumpSwap AMM\n    pub fn is_pumpswap_pool(&self, pool_address: &Pubkey) -> Result<bool> {\n        match self.rpc_client.get_account_owner(pool_address) {\n            Ok(owner) => {\n                let pumpswap_program = Pubkey::from_str(PUMPSWAP_PROGRAM_ID).unwrap();\n                Ok(owner == pumpswap_program)\n            }\n            Err(e) => Err(anyhow::anyhow!(\"Failed to verify pool owner: {}\", e)),\n        }\n    }\n}","nrTokens":0,"nrLines":74,"files":[{"filePath":"src/pumpswap.rs","startLine":213,"endLine":286},{"filePath":"clean_arb_bot/src/pumpswap.rs","startLine":207,"endLine":275}]}},{"DuplicationClone":{"cloneLines":",\n            swap_params,\n        )?;\n\n        // Combine setup instructions (ATA creation) with swap instruction\n        let mut all_instructions = setup_instructions;\n        all_instructions.push(instruction);\n\n        if all_instructions.len() > 1 {\n            info!(\"??? Built {} instructions ({} setup + 1 swap)\", all_instructions.len(), all_instructions.len() - 1);\n        } else {\n            info!(\"??? Built Orca Whirlpool swap instruction\"","nrTokens":0,"nrLines":12,"files":[{"filePath":"clean_arb_bot/src/orca.rs","startLine":249,"endLine":260},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":264,"endLine":275}]}},{"DuplicationClone":{"cloneLines":";\nuse solana_sdk::{\n    instruction::{AccountMeta, Instruction},\n    pubkey::Pubkey,\n    signature::{Keypair, Signer},\n    transaction::Transaction,\n};\nuse spl_associated_token_account::get_associated_token_address;\nuse spl_token::id as token_program_id;\nuse std","nrTokens":0,"nrLines":10,"files":[{"filePath":"src/meteora_swap.rs","startLine":6,"endLine":15},{"filePath":"clean_arb_bot/src/meteora_swap.rs","startLine":8,"endLine":17}]}},{"DuplicationClone":{"cloneLines":")?;\n\n    // 10. PUMP-USDC\n    pool_registry.register_pool(\n        \"9SMp4yLK\".to_string(),\n        PoolInfo {\n            full_address: \"9SMp4yLKGtW9TnLimfVPkDARsyNSfJw43WMke4r7KoZj\".parse()?,\n            dex_type: DexType::MeteoraDammV2,\n            token_a_mint: \"pumpCmXqMfrsAkQ5r49WcJnRayYRqmXz6ae8H7H9Dfn\".parse()?, // PUMP\n            token_b_mint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".parse()?, // USDC\n            reserve_a: \"6uVEyA1RRhuTzDroFGBrDsAHwE4b6hCSwgyXAHjTZEUv\".parse()?,\n            reserve_b: \"5RLzTiyGuadAC4SE3s7MGonXszFShJtZewVmmHGUUbkV\".parse()?,\n        },","nrTokens":0,"nrLines":13,"files":[{"filePath":"src/pool_population.rs","startLine":145,"endLine":157},{"filePath":"clean_arb_bot/src/pool_population.rs","startLine":145,"endLine":158}]}},{"DuplicationClone":{"cloneLines":"// Dynamic JITO Tip Floor Monitor\n//\n// Monitors JITO's tip floor API every 30 minutes to adjust tips competitively\n// without overpaying. Uses percentile data to beat 95-99% of market.\n\nuse anyhow::Result;\nuse serde::Deserialize;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tokio::time::{sleep, Duration};\nuse tracing::{debug, error, info, warn};\n\n/// JITO tip floor percentile data from their API\n#[derive(Debug, Clone, Deserialize)]\npub struct JitoTipFloor {\n    #[serde(rename = \"landed_tips_25th_percentile\")]\n    pub p25: f64, // 25th percentile in SOL\n\n    #[serde(rename = \"landed_tips_50th_percentile\")]\n    pub p50: f64, // 50th percentile in SOL\n\n    #[serde(rename = \"landed_tips_75th_percentile\")]\n    pub p75: f64, // 75th percentile in SOL\n\n    #[serde(rename = \"landed_tips_95th_percentile\")]\n    pub p95: f64, // 95th percentile in SOL\n\n    #[serde(rename = \"landed_tips_99th_percentile\")]\n    pub p99: f64, // 99th percentile in SOL\n\n    #[serde(rename = \"ema_landed_tips_50th_percentile\")]\n    pub ema_p50: f64, // Exponential moving average of 50th percentile\n\n    /// When this data was last updated (not deserialized, set manually)\n    #[serde(skip, default = \"std::time::Instant::now\")]\n    pub last_updated: std::time::Instant,\n}\n\nimpl Default for JitoTipFloor {\n    fn default() -> Self {\n        Self {\n            // Conservative defaults (if API fails, use higher tips)\n            p25: 0.000001, // 1,000 lamports\n            p50: 0.000001, // 1,000 lamports\n            p75: 0.000010, // 10,000 lamports\n            p95: 0.001000, // 1M lamports (conservative)\n            p99: 0.010000, // 10M lamports (conservative)\n            ema_p50: 0.000001,\n            last_updated: std::time::Instant::now(),\n        }\n    }\n}\n\nimpl JitoTipFloor {\n    /// Convert SOL amounts to lamports\n    pub fn p95_lamports(&self) -> u64 {\n        (self.p95 * 1_000_000_000.0) as u64\n    }\n\n    pub fn p99_lamports(&self) -> u64 {\n        (self.p99 * 1_000_000_000.0) as u64\n    }\n\n    /// Get competitive tip: 10% above percentile to beat competition\n    /// HARD CAP: Maximum 0.003 SOL (3M lamports) to prevent extreme market spikes\n    pub fn competitive_tip_95(&self) -> u64 {\n        const MAX_TIP: u64 = 3_000_000; // 0.003 SOL hard cap\n        let tip = (self.p95_lamports() as f64 * 1.10) as u64;\n        let capped_tip = tip.min(MAX_TIP);\n\n        if capped_tip < tip {\n            debug!(\n                \"???? 95th percentile tip CAPPED: {:.6} SOL ??? {:.6} SOL (market spike protection)\",\n                tip as f64 / 1e9,\n                capped_tip as f64 / 1e9\n            );\n        }\n\n        capped_tip\n    }\n\n    pub fn competitive_tip_99(&self) -> u64 {\n        const MAX_TIP: u64 = 3_000_000; // 0.003 SOL hard cap\n        let tip = (self.p99_lamports() as f64 * 1.10) as u64;\n        let capped_tip = tip.min(MAX_TIP);\n\n        if capped_tip < tip {\n            debug!(\n                \"???? 99th percentile tip CAPPED: {:.6} SOL ??? {:.6} SOL (market spike protection)\",\n                tip as f64 / 1e9,\n                capped_tip as f64 / 1e9\n            );\n        }\n\n        capped_tip\n    }\n\n    /// Check if data is stale (>15 minutes old - 5 min buffer)\n    pub fn is_stale(&self) -> bool {\n        self.last_updated.elapsed() > Duration::from_secs(15 * 60)\n    }\n}\n\n/// Shared JITO tip floor data (thread-safe)\npub type SharedJitoTipFloor = Arc<RwLock<JitoTipFloor>>;\n\n/// API response from JITO tip floor endpoint\n#[derive(Debug, Deserialize)]\nstruct JitoTipFloorResponse {\n    time: String,\n    landed_tips_25th_percentile: f64,\n    landed_tips_50th_percentile: f64,\n    landed_tips_75th_percentile: f64,\n    landed_tips_95th_percentile: f64,\n    landed_tips_99th_percentile: f64,\n    ema_landed_tips_50th_percentile: f64,\n}\n\n/// Fetch current JITO tip floor data from API\nasync fn fetch_jito_tip_floor() -> Result<JitoTipFloor> {\n    let url = \"https://bundles.jito.wtf/api/v1/bundles/tip_floor\";\n\n    let response = reqwest::get(url).await?;\n\n    if !response.status().is_success() {\n        anyhow::bail!(\"JITO tip floor API returned {}\", response.status());\n    }\n\n    let data: Vec<JitoTipFloorResponse> = response.json().await?;\n\n    // Get the most recent entry (first in array)\n    let latest = data\n        .first()\n        .ok_or_else(|| anyhow::anyhow!(\"Empty response from JITO tip floor API\"))?;\n\n    Ok(JitoTipFloor {\n        p25: latest.landed_tips_25th_percentile,\n        p50: latest.landed_tips_50th_percentile,\n        p75: latest.landed_tips_75th_percentile,\n        p95: latest.landed_tips_95th_percentile,\n        p99: latest.landed_tips_99th_percentile,\n        ema_p50: latest.ema_landed_tips_50th_percentile,\n        last_updated: std::time::Instant::now(),\n    })\n}\n\n/// Background task that monitors JITO tip floor every 30 minutes\n///\n/// # Arguments\n/// * `tip_floor` - Shared tip floor data (updated by this task)\n///\n/// # Behavior\n/// - Fetches JITO tip floor data every 30 minutes\n/// - Updates shared state with latest percentiles\n/// - Logs percentile changes for monitoring\n/// - Retries on failure with exponential backoff\npub async fn monitor_jito_tip_floor(tip_floor: SharedJitoTipFloor) {\n    info!(\"???? JITO tip floor monitor started (updates every 10 minutes)\");\n\n    // Initial fetch on startup\n    match fetch_jito_tip_floor().await {\n        Ok(data) => {\n            info!(\"???? Initial JITO tip floor:\");\n            info!(\n                \"   50th percentile: {:.9} SOL ({} lamports)\",\n                data.p50,\n                (data.p50 * 1e9) as u64\n            );\n            info!(\n                \"   95th percentile: {:.9} SOL ({} lamports)\",\n                data.p95,\n                data.p95_lamports()\n            );\n            info!(\n                \"   99th percentile: {:.9} SOL ({} lamports)\",\n                data.p99,\n                data.p99_lamports()\n            );\n            *tip_floor.write().await = data;\n        }\n        Err(e) => {\n            warn!(\"??????  Failed to fetch initial JITO tip floor: {}\", e);\n            warn!(\"   Using conservative defaults until next fetch\");\n        }\n    }\n\n    // Monitor loop - update every 10 minutes\n    let mut retry_delay = Duration::from_secs(10 * 60); // 10 minutes\n\n    loop {\n        sleep(retry_delay).await;\n\n        match fetch_jito_tip_floor().await {\n            Ok(new_data) => {\n                let old_data = tip_floor.read().await.clone();\n\n                // Log significant changes (>20% difference)\n                let p95_change = (new_data.p95 - old_data.p95) / old_data.p95 * 100.0;\n                let p99_change = (new_data.p99 - old_data.p99) / old_data.p99 * 100.0;\n\n                if p95_change.abs() > 20.0 || p99_change.abs() > 20.0 {\n                    info!(\"???? JITO tip floor changed significantly:\");\n                    info!(\n                        \"   95th: {:.9} SOL ??? {:.9} SOL ({:+.1}%)\",\n                        old_data.p95, new_data.p95, p95_change\n                    );\n                    info!(\n                        \"   99th: {:.9} SOL ??? {:.9} SOL ({:+.1}%)\",\n                        old_data.p99, new_data.p99, p99_change\n                    );\n                } else {\n                    debug!(\"??? JITO tip floor updated (no major changes)\");\n                }\n\n                *tip_floor.write().await = new_data;\n\n                // Reset to 10 minute interval on success\n                retry_delay = Duration::from_secs(10 * 60);\n            }\n            Err(e) => {\n                error!(\"??? Failed to fetch JITO tip floor: {}\", e);\n\n                // Exponential backoff on failure (up to 10 minutes)\n                retry_delay = Duration::from_secs((retry_delay.as_secs() * 2).min(10 * 60));\n                warn!(\"   Retrying in {} minutes\", retry_delay.as_secs() / 60);\n\n                // Check if data is getting stale\n                let current_data = tip_floor.read().await;\n                if current_data.is_stale() {\n                    warn!(\"??????  JITO tip floor data is >35 minutes old!\");\n                    warn!(\"   Using stale data (better than defaults)\");\n                }\n            }\n        }\n    }\n}\n\n/// Spawn JITO tip floor monitor as background task\n///\n/// # Returns\n/// Shared tip floor data that will be updated every 30 minutes\npub fn spawn_monitor() -> SharedJitoTipFloor {\n    let tip_floor = Arc::new(RwLock::new(JitoTipFloor::default()));\n    let tip_floor_clone = tip_floor.clone();\n\n    tokio::spawn(async move {\n        monitor_jito_tip_floor(tip_floor_clone).await;\n    });\n\n    tip_floor\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_default_tip_floor() {\n        let floor = JitoTipFloor::default();\n        assert!(floor.p95_lamports() > 0);\n        assert!(floor.p99_lamports() > floor.p95_lamports());\n    }\n\n    #[test]\n    fn test_competitive_tips() {\n        let floor = JitoTipFloor {\n            p95: 0.001, // 1M lamports\n            p99: 0.010, // 10M lamports\n            ..Default::default()\n        };\n\n        // Competitive tips should be 10% above percentile\n        assert_eq!(floor.competitive_tip_95(), 1_100_000); // 1.1M lamports\n        assert_eq!(floor.competitive_tip_99(), 3_000_000); // Capped at 3M (would be 11M without cap)\n    }\n\n    #[test]\n    fn test_hard_cap() {\n        // Test that extreme market spikes are capped at 0.003 SOL\n        let extreme_floor = JitoTipFloor {\n            p95: 0.010, // 10M lamports (extreme)\n            p99: 0.100, // 100M lamports (extreme spike)\n            ..Default::default()\n        };\n\n        // Both should be capped at 3M lamports (0.003 SOL)\n        assert_eq!(extreme_floor.competitive_tip_95(), 3_000_000); // Capped (would be 11M)\n        assert_eq!(extreme_floor.competitive_tip_99(), 3_000_000); // Capped (would be 110M)\n    }\n\n    #[tokio::test]\n    async fn test_fetch_jito_tip_floor() {\n        // This test requires network access\n        match fetch_jito_tip_floor().await {\n            Ok(data) => {\n                println!(\"??? Fetched JITO tip floor:\");\n                println!(\"   95th: {:.9} SOL\", data.p95);\n                println!(\"   99th: {:.9} SOL\", data.p99);\n                assert!(data.p99 >= data.p95);\n            }\n            Err(e) => {\n                println!(\"??????  Failed to fetch (may be offline): {}\", e);\n            }\n        }\n    }\n}","nrTokens":0,"nrLines":306,"files":[{"filePath":"src/jito_tip_monitor.rs","startLine":1,"endLine":306},{"filePath":"clean_arb_bot/src/jito_tip_monitor.rs","startLine":1,"endLine":284}]}},{"DuplicationClone":{"cloneLines":");\n\n        info!(\n            \"??? Built JITO tip instruction: {} lamports (0.{:06} SOL) to {}\",\n            tip_lamports,\n            tip_lamports / 1000,\n            tip_account\n        );\n\n        // SECURITY FIX (2025-10-08): Combine swap instructions + tip\n        // Note: build_transaction() will add compute budget instructions automatically\n        let all_instructions = vec![ix1, ix2, ix3, tip_ix];\n\n        info!(\"???? SECURE: Tip included IN swap transaction (prevents unbundling)\");\n\n        // Get recent blockhash\n        let recent_blockhash = self.rpc_client.get_latest_blockhash()?;\n\n        // Build transaction with all instructions atomically\n        let transaction = self.build_transaction(all_instructions, wallet, recent_blockhash)","nrTokens":0,"nrLines":20,"files":[{"filePath":"src/swap_executor.rs","startLine":396,"endLine":415},{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":395,"endLine":413}]}},{"DuplicationClone":{"cloneLines":"<T: Signer>(\n        &self,\n        leg1: (&DexType, &str, &SwapParams),\n        leg2: (&DexType, &str, &SwapParams),\n        leg3: (&DexType, &str, &SwapParams),\n        wallet: &T,\n        tip_lamports","nrTokens":0,"nrLines":7,"files":[{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":372,"endLine":378},{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":256,"endLine":262}]}},{"DuplicationClone":{"cloneLines":")?;\n\n        // Initialize PumpSwap builder\n        let pumpswap_builder = PumpSwapSwapBuilder::new(rpc_client.clone())?;\n\n        // Initialize Raydium builder\n        let raydium_builder = RaydiumSwapBuilder::new(rpc_client.clone(), pool_registry.clone())","nrTokens":0,"nrLines":7,"files":[{"filePath":"src/swap_executor.rs","startLine":66,"endLine":72},{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":77,"endLine":85}]}},{"DuplicationClone":{"cloneLines":"}\n    }\n\n    /// Execute a triangle arbitrage (3 swaps atomically)\n    ///\n    /// # Arguments\n    /// * `leg1` - First swap (e.g., SOL ??? TokenA)\n    /// * `leg2` - Second swap (e.g., TokenA ??? TokenB)\n    /// * `leg3` - Third swap (e.g., TokenB ??? SOL)\n    /// * `wallet` - User's wallet\n    /// * `use_jito` - If true, submit via JITO bundle for MEV protection\n    ///\n    /// # Returns\n    /// Transaction signature or bundle ID\n    pub async fn execute_triangle<T: Signer>(\n        &self,\n        leg1: (&DexType, &str, &SwapParams),\n        leg2: (&DexType, &str, &SwapParams),\n        leg3: (&DexType, &str, &SwapParams),\n        wallet: &T,\n        use_jito: bool,\n    ) -> Result<String> {\n        info!(\"???? Executing triangle arbitrage\");\n        info!(\"   Leg 1: {:?} pool {}\", leg1.0, leg1.1);\n        info!(\"   Leg 2: {:?} pool {}\", leg2.0, leg2.1);\n        info!(\"   Leg 3: {:?} pool {}\", leg3.0, leg3.1);\n\n        let user_pubkey = wallet.pubkey();\n\n        // Build all three swap instructions (async for pool resolution)\n        let ix1 = self\n            .build_swap_instruction(leg1.0, leg1.1, leg1.2, &user_pubkey)\n            .await?;\n        let ix2 = self\n            .build_swap_instruction(leg2.0, leg2.1, leg2.2, &user_pubkey)\n            .await?;\n        let ix3 = self\n            .build_swap_instruction(leg3.0, leg3.1, leg3.2, &user_pubkey)\n            .await?;\n\n        debug!(\"??? Built all 3 swap instructions\");\n\n        // Get recent blockhash\n        let recent_blockhash = self.rpc_client.get_latest_blockhash()?;\n\n        // Build transaction with all swaps\n        let transaction = self.build_transaction(vec![ix1, ix2, ix3], wallet, recent_blockhash)","nrTokens":0,"nrLines":47,"files":[{"filePath":"src/swap_executor.rs","startLine":236,"endLine":282},{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":242,"endLine":285}]}},{"DuplicationClone":{"cloneLines":");\n\n        // Build instruction data\n        let mut data = Vec::with_capacity(24);\n\n        if swap_a_to_b {\n            // BUY: SOL -> Token\n            // Args: base_amount_out, max_quote_amount_in\n            data.extend_from_slice(&BUY_DISCRIMINATOR);\n            data.extend_from_slice(&minimum_amount_out.to_le_bytes()); // base_amount_out\n            data.extend_from_slice(&amount_in.to_le_bytes()); // max_quote_amount_in\n        } else {\n            // SELL: Token -> SOL\n            // Args: base_amount_in, min_quote_amount_out\n            data.extend_from_slice(&SELL_DISCRIMINATOR);\n            data.extend_from_slice(&amount_in.to_le_bytes()); // base_amount_in\n            data.extend_from_slice(&minimum_amount_out.to_le_bytes()); // min_quote_amount_out\n        }\n\n        // Derive required PDAs (from Grok's PumpSwap AMM analysis)\n        let (global_config, _) = Pubkey::find_program_address(&[b\"global\"], &self.program_id);\n        let (event_authority, _) =\n            Pubkey::find_program_address(&[b\"__event_authority\"], &self.program_id);\n\n        // Determine mint order based on swap direction\n        // For BUY (SOL???Token): mint_a = WSOL, mint_b = token\n        // For SELL (Token???SOL): mint_a = token, mint_b = WSOL\n        let (mint_a, mint_b, user_account_a, user_account_b) = if swap_a_to_b {\n            // BUY: SOL ??? Token\n            (\n                pool.quote_mint,\n                pool.base_mint,\n                user_quote_account,\n                user_base_account,","nrTokens":0,"nrLines":34,"files":[{"filePath":"src/pumpswap.rs","startLine":113,"endLine":146},{"filePath":"clean_arb_bot/src/pumpswap.rs","startLine":106,"endLine":140}]}},{"DuplicationClone":{"cloneLines":"};\nuse std::env;\n\n/// Configuration for the arbitrage bot\n#[derive(Debug, Clone)]\npub struct Config {\n    pub shredstream_url: String,\n    pub solana_rpc_url: Option<String>,\n    pub capital_sol: f64,\n    pub max_position_size_sol: f64,\n    pub min_profit_margin_multiplier: f64, // Replaced min_profit_sol with margin multiplier\n    pub min_spread_percentage: f64,\n    pub max_daily_trades: u64,\n    pub daily_loss_limit_sol: f64,\n    pub max_consecutive_failures: u64,\n    pub enable_real_trading: bool,\n    pub paper_trading: bool,\n    pub wallet_private_key: Option<String>,\n    pub jupiter_api_key: Option<String>,\n}\n\nimpl Config {\n    /// Calculate JITO tip based on profit (3-10% of profit, capped at 0.001 SOL)\n    ///\n    /// # Arguments\n    /// * `gross_profit_sol` - Expected gross profit in SOL\n    ///\n    /// # Returns\n    /// JITO tip amount in SOL (0.0001-0.001 SOL range)\n    ///\n    /// # Strategy\n    /// - Small profits (<0.1 SOL): 3% tip\n    /// - Medium profits (0.1-1.0 SOL): 5% tip\n    /// - Large profits (>1.0 SOL): 7% tip\n    /// - Capped at 0.001 SOL maximum, minimum 0.0001 SOL\n    pub fn calculate_jito_tip(&self, gross_profit_sol: f64) -> f64 {\n        if gross_profit_sol < 0.1 {\n            // Small profits: 3-5% tip\n            let tip = gross_profit_sol * 0.03;\n            tip.min(0.001).max(0.0001) // Cap at 0.001 SOL, min 0.0001 SOL\n        } else if gross_profit_sol < 1.0 {\n            // Medium profits: 5-7% tip\n            let tip = gross_profit_sol * 0.05;\n            tip.min(0.001).max(0.0001)\n        } else {\n            // Large profits: 7-10% tip\n            let tip = gross_profit_sol * 0.07;\n            tip.min(0.001).max(0.0001)\n        }\n    }\n\n    /// Calculate total fees for a trade (JITO tip + gas + compute)\n    pub fn calculate_total_fees(&self, gross_profit_sol: f64) -> f64 {\n        let jito_tip = self.calculate_jito_tip(gross_profit_sol);\n        let gas_fee = 0.00005; // ~50,000 lamports typical\n        let compute_fee = 0.00001; // ~10,000 lamports typical\n        jito_tip + gas_fee + compute_fee\n    }\n\n    /// Calculate minimum acceptable profit based on fees and margin\n    /// NEW (2025-10-11): Net profit must be > total_fees + 0.5% of gross profit\n    /// This ensures we beat fees AND have a small safety margin\n    pub fn calculate_min_acceptable_profit(&self, gross_profit_sol: f64) -> f64 {\n        let total_fees = self.calculate_total_fees(gross_profit_sol);\n        let margin = 0.005 * gross_profit_sol; // 0.5% of gross profit\n        total_fees + margin\n    }\n\n    /// Check if a trade is profitable after fees with required margin\n    ///\n    /// # Arguments\n    /// * `gross_profit_sol` - Expected gross profit in SOL\n    ///\n    /// # Returns\n    /// * `true` if net profit after fees meets minimum margin requirement\n    /// * `false` if fees would make trade unprofitable\n    ///\n    /// # Calculation\n    /// - Calculates total fees (JITO tip + gas + compute)\n    /// - Computes net profit (gross - fees)\n    /// - Checks if net profit >= fees + 0.5% of gross profit\n    ///\n    /// # Note\n    /// UPDATED (2025-10-11): User requirement - beat fees + 0.5% gross profit margin\n    /// OLD: net_profit >= fees * 1.2 (20% margin)\n    /// NEW: net_profit >= fees + 0.5% of gross (realistic arbitrage)\n    pub fn is_profitable_after_fees(&self, gross_profit_sol: f64) -> bool {\n        let total_fees = self.calculate_total_fees(gross_profit_sol);\n        let net_profit = gross_profit_sol - total_fees;\n        let required_margin = 0.005 * gross_profit_sol; // 0.5% of gross as safety margin\n        net_profit >= (total_fees + required_margin)\n    }\n}\n\nimpl Config {\n    /// Validate URL format (basic security check)\n    ///\n    /// # Arguments\n    /// * `url` - The URL string to validate\n    /// * `name` - The name of the configuration field (for error messages)\n    ///\n    /// # Returns\n    /// * `Ok(())` if URL is valid\n    /// * `Err` with descriptive message if URL is invalid or contains suspicious characters\n    ///\n    /// # Security\n    /// - Validates URL scheme (http://, https://, ws://, wss://)\n    /// - Blocks injection attacks via newline, carriage return, or null characters\n    fn validate_url(url: &str, name: &str) -> Result<()> {\n        // Check for basic URL structure\n        if !url.starts_with(\"http://\")\n            && !url.starts_with(\"https://\")\n            && !url.starts_with(\"ws://\")\n            && !url.starts_with(\"wss://\")\n        {\n            return Err(anyhow::anyhow!(\n                \"Invalid {}: must start with http://, https://, ws://, or wss:// (got: {})\",\n                name,\n                url\n            ));\n        }\n\n        // Check for suspicious characters (basic injection protection)\n        if url.contains('\\n') || url.contains('\\r') || url.contains('\\0') {\n            return Err(anyhow::anyhow!(\n                \"Invalid {}: contains suspicious characters\",\n                name\n            ));\n        }\n\n        Ok(())\n    }\n\n    /// Validate base58 wallet private key format\n    ///\n    /// # Arguments\n    /// * `key` - The base58-encoded private key string to validate\n    ///\n    /// # Returns\n    /// * `Ok(())` if key format is valid\n    /// * `Err` with descriptive message if key is invalid\n    ///\n    /// # Validation Rules\n    /// - Length must be 80-90 characters (Solana 64-byte keys in base58)\n    /// - Only valid base58 characters allowed (no O, 0, I, l)\n    fn validate_private_key(key: &str) -> Result<()> {\n        // Check length (Solana private keys are 64 bytes base58 encoded, typically 87-88 chars)\n        if key.len() < 80 || key.len() > 90 {\n            return Err(anyhow::anyhow!(\n                \"Invalid wallet private key length: {} (expected 80-90 characters)\",\n                key.len()\n            ));\n        }\n\n        // Check for valid base58 characters\n        if !key.chars().all(\n            |","nrTokens":0,"nrLines":157,"files":[{"filePath":"src/config.rs","startLine":1,"endLine":157},{"filePath":"clean_arb_bot/src/config.rs","startLine":1,"endLine":151}]}},{"DuplicationClone":{"cloneLines":")\n                    .await\n                    {\n                        Ok(Ok(uuid)) => {\n                            info!(\"???? JITO bundle submitted via gRPC (FAST!): {}\", uuid);\n                            Ok(uuid)\n                        }\n                        Ok(Err(e)) => {\n                            warn!(\"?????? gRPC submission failed: {} - falling back to HTTP\", e);\n                            // Release lock before HTTP call\n                            drop(grpc);\n\n                            // Fallback to HTTP\n                            match tokio::time::timeout(\n                                Duration::from_secs(10),\n                                http_clone.submit_bundle_safe(request.transactions.clone()),","nrTokens":0,"nrLines":16,"files":[{"filePath":"src/jito_submitter.rs","startLine":149,"endLine":164},{"filePath":"clean_arb_bot/src/jito_submitter.rs","startLine":141,"endLine":155}]}},{"DuplicationClone":{"cloneLines":";\n\n// Pool validation constants (Grok's ghost pool solution)\nconst MIN_POOL_SIZE: usize = 1000; // Minimum bytes for valid pool (DEX-specific)\nconst VALIDATION_TTL_SECS: u64 = 300; // 5 minutes cache TTL\nconst BACKGROUND_INTERVAL_SECS: u64 = 120; // 2 minutes background validation\n\n/// Cache entry for resolved pool addresses\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct PoolCacheEntry {\n    short_id: String,\n    full_address: String,\n    dex_type: String,\n    timestamp: u64,\n}\n\n/// ShredStream API response for pool lookup\n#[derive(Debug, Deserialize)]\nstruct ShredStreamPoolResponse {\n    full_address: Option<String>,\n    pool_address: Option<String>,\n}\n\n/// Pool registry for managing pool address mappings\npub struct PoolRegistry {\n    /// Map of short_id -> PoolInfo (Layer 1: In-memory cache)\n    pools: Arc<RwLock<HashMap<String, PoolInfo>>>,\n    /// Map of full_address -> short_id (reverse lookup)\n    address_to_id: Arc<RwLock<HashMap<Pubkey, String>>>,\n    /// RPC client for fetching pool data (Layer 4: On-chain fallback)\n    rpc_client: Arc<SolanaRpcClient>,\n    /// HTTP client for ShredStream service queries (Layer 2: ShredStream API)\n    http_client: reqwest::Client,\n    /// ShredStream service URL\n    shredstream_url: String,\n    /// Resolution performance metrics\n    resolution_stats: Arc<RwLock<ResolutionStats>>,\n    /// Pool validation cache (pool_short_id -> (is_valid, last_checked))\n    /// Grok's ghost pool solution: 5-minute TTL cache\n    validation_cache: Arc<TokioRwLock<HashMap<String, (bool, Instant)>>>,\n}\n\n/// Statistics for pool resolution performance\n#[derive(Debug, Default)]\nstruct ResolutionStats {\n    layer1_hits: u64, // In-memory cache hits\n    layer2_hits: u64, // ShredStream API hits\n    layer3_hits: u64, // SQLite cache hits (future)\n    layer4_hits: u64, // On-chain RPC hits\n    total_lookups: u64,\n    total_latency_ms: u64,\n}\n\nimpl PoolRegistry {\n    /// Create new pool registry\n    pub fn new(rpc_client: Arc<SolanaRpcClient>) -> Self {\n        let shredstream_url = std::env::var(\"SHREDSTREAM_SERVICE_URL\")\n            .unwrap_or_else(|_| \"http://localhost:8080\".to_string());\n\n        info!(\n            \"??? Pool registry initialized with ShredStream API: {}\",\n            shredstream_url\n        );\n\n        Self {\n            pools: Arc::new(RwLock::new(HashMap::new())),\n            address_to_id: Arc::new(RwLock::new(HashMap::new())),\n            rpc_client,\n            http_client: reqwest::Client::builder()\n                .timeout(Duration::from_millis(500)) // 500ms timeout for ShredStream API\n                .build()\n                .expect(\"Failed to create HTTP client\"),\n            shredstream_url,\n            resolution_stats: Arc::new(RwLock::new(ResolutionStats::default())),\n            validation_cache: Arc::new(TokioRwLock::new(HashMap::new())), // Grok's ghost pool solution\n        }\n    }\n\n    /// Register a pool manually (for pre-population)\n    pub fn register_pool(&self, short_id: String, pool_info: PoolInfo) -> Result<()> {\n        let full_address = pool_info.full_address;\n\n        // Validate short ID matches address prefix\n        let address_str = full_address.to_string();\n        if !address_str.starts_with(&short_id) {\n            warn!(\n                \"?????? Short ID {} doesn't match address prefix {}\",\n                short_id, address_str\n            );\n        }\n\n        // Store in both maps\n        {\n            let mut pools = self.pools.write().unwrap();\n            pools.insert(short_id.clone(), pool_info);\n        }\n\n        {\n            let mut addr_map = self.address_to_id.write().unwrap();\n            addr_map.insert(full_address, short_id.clone());\n        }\n\n        debug!(\"??? Registered pool: {} -> {}\", short_id, full_address);\n        Ok(())\n    }\n\n    /// Get pool info by short ID\n    pub fn get_pool(&self, short_id: &str) -> Option<PoolInfo> {\n        let pools = self.pools.read().unwrap();\n        pools.get(short_id).cloned()\n    }\n\n    /// Get short ID by full address\n    pub fn get_short_id(&self, full_address: &Pubkey) -> Option<String> {\n        let addr_map = self.address_to_id.read().unwrap();\n        addr_map.get(full_address).cloned()\n    }\n\n    /// Check if pool is registered\n    pub fn has_pool(&self, short_id: &str) -> bool {\n        let pools = self.pools.read().unwrap();\n        pools.contains_key(short_id)\n    }\n\n    /// Get number of registered pools\n    pub fn pool_count(&self) -> usize {\n        let pools = self.pools.read().unwrap();\n        pools.len()\n    }\n\n    /// Fetch pool state from blockchain\n    pub fn fetch_pool_state(&self, pool_address: &Pubkey) -> Result<Vec<u8>> {\n        debug!(\"Fetching pool state for: {}\", pool_address);\n\n        let data = self\n            .rpc_client\n            .get_account_data(pool_address)\n            .context(\"Failed to fetch pool state\")?;\n\n        Ok(data)\n    }\n\n    /// Resolve short ID to full address using 4-layer hybrid approach\n    ///\n    /// Layer 1: In-memory cache (1-5ms) - Pre-populated pools\n    /// Layer 2: ShredStream API (5-10ms) - Recent blockchain data\n    /// Layer 3: SQLite cache (10-20ms) - Historical lookups (future)\n    /// Layer 4: On-chain RPC (200-400ms) - Last resort fallback\n    ///\n    /// Returns full pool address or error if not found anywhere\n    pub async fn resolve_pool_address(&self, short_id: &str, dex_type: &DexType) -> Result<Pubkey> {\n        let start_time = Instant::now();\n\n        // CRITICAL FIX: Increment lookup counter without holding lock during async operations\n        {\n            let mut stats = self.resolution_stats.write().unwrap();\n            stats.total_lookups += 1;\n        } // Lock released immediately\n\n        debug!(\n            \"???? Resolving pool address for: {} ({:?})\",\n            short_id, dex_type\n        );\n\n        // LAYER 1: Check in-memory registry (fastest - 1-5ms)\n        if let Some(pool_info) = self.get_pool(short_id) {\n            let latency = start_time.elapsed().as_millis() as u64;\n\n            // Update stats atomically without blocking\n            {\n                let mut stats = self.resolution_stats.write().unwrap();\n                stats.layer1_hits += 1;\n                stats.total_latency_ms += latency;\n            } // Lock released immediately\n\n            debug!(\"??? Layer 1 HIT: Found in memory cache ({}ms)\", latency);\n            return Ok(pool_info.full_address);\n        }\n\n        // Handle full address input (if user provided 44-char address)\n        if short_id.len() == 44 {\n            if let Ok(pubkey) = short_id.parse::<Pubkey>() {\n                debug!(\"??? Parsed as full address: {}\", short_id);\n                return Ok(pubkey);\n            }\n        }\n\n        // LAYER 2: Query ShredStream service API (fast - 5-10ms)\n        // NO LOCK HELD during network I/O - prevents deadlock\n        match self.query_shredstream_api(short_id).await {\n            Ok(full_address) => {\n                let latency = start_time.elapsed().as_millis() as u64;\n\n                // Update stats atomically after network call completes\n                {\n                    let mut stats = self.resolution_stats.write().unwrap();\n                    stats.layer2_hits += 1;\n                    stats.total_latency_ms += latency;\n                } // Lock released immediately\n\n                debug!(\"??? Layer 2 HIT: Found via ShredStream API ({}ms)\", latency);\n\n                // Cache in memory for future lookups\n                let pool_info = PoolInfo {\n                    full_address,\n                    dex_type: dex_type.clone(),\n                    token_a_mint: Pubkey::default(), // TODO: Get from API\n                    token_b_mint: Pubkey::default(),\n                    reserve_a: Pubkey::default(),\n                    reserve_b: Pubkey::default(),\n                };\n                let _ = self.register_pool(short_id.to_string(), pool_info);\n\n                return Ok(full_address);\n            }\n            Err(e) => {\n                debug!(\"?????? Layer 2 MISS: ShredStream API query failed: {}\", e);\n            }\n        }\n\n        // LAYER 3: SQLite cache lookup (future implementation - 10-20ms)\n        // TODO: Query persistent SQLite database\n        // This provides fallback for pools seen historically but not currently in memory\n        debug!(\"?????? Layer 3 SKIP: SQLite cache not yet implemented\");\n\n        // LAYER 4: On-chain RPC lookup (slowest - 200-400ms)\n        // Only use as last resort for brand new pools\n        // NO LOCK HELD during network I/O - prevents deadlock\n        match self.query_on_chain(short_id, dex_type).await {\n            Ok(full_address) => {\n                let latency = start_time.elapsed().as_millis() as u64;\n\n                // Update stats atomically after network call completes\n                {\n                    let mut stats = self.resolution_stats.write().unwrap();\n                    stats.layer4_hits += 1;\n                    stats.total_latency_ms += latency;\n                } // Lock released immediately\n\n                warn!(\n                    \"?????? Layer 4 HIT: Found via on-chain RPC ({}ms) - SLOW!\",\n                    latency\n                );\n\n                // FILTER: Reject old Pump.fun bonding curve (NOT arbitrageable)\n                // Allow PumpSwap AMM (post-migration, standard AMM like Raydium)\n                match self.rpc_client.get_account_owner(&full_address) {\n                    Ok(owner) => {\n                        // OLD Pump.fun bonding curve program (pre-migration)\n                        let old_pump_fun_bonding: Pubkey =\n                            \"6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P\"\n                                .parse()\n                                .unwrap();\n\n                        // PumpSwap AMM program (post-migration) - ALLOW\n                        let pumpswap_amm: Pubkey = \"pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA\"\n                            .parse()\n                            .unwrap();\n\n                        if owner == old_pump_fun_bonding {\n                            debug!(\"?????? Skipping old Pump.fun bonding curve (pre-migration, not arbitrageable): {}\", full_address);\n                            return Err(anyhow::anyhow!(\n                                \"Pool {} is on old Pump.fun bonding curve (unsupported - use PumpSwap AMM instead)\",\n                                full_address\n                            ));\n                        }\n\n                        if owner == pumpswap_amm {\n                            debug!(\n                                \"??? PumpSwap AMM pool detected (post-migration, arbitrageable): {}\",\n                                full_address\n                            );\n                        }\n                    }\n                    Err(e) => {\n                        debug!(\"?????? Could not verify pool owner: {}\", e);\n                        // Continue anyway - owner check failure shouldn't block\n                    }\n                }\n\n                // Cache in memory for future lookups\n                let pool_info = PoolInfo {\n                    full_address,\n                    dex_type: dex_type.clone(),\n                    token_a_mint: Pubkey::default(),\n                    token_b_mint: Pubkey::default(),\n                    reserve_a: Pubkey::default(),\n                    reserve_b: Pubkey::default(),\n                };\n                let _ = self.register_pool(short_id.to_string(), pool_info);\n\n                return Ok(full_address);\n            }\n            Err(e) => {\n                let latency = start_time.elapsed().as_millis() as u64;\n\n                // Update stats atomically\n                {\n                    let mut stats = self.resolution_stats.write().unwrap();\n                    stats.total_latency_ms += latency;\n                } // Lock released immediately\n\n                warn!(\n                    \"??? Layer 4 MISS: On-chain lookup failed ({}ms): {}\",\n                    latency, e\n                );\n            }\n        }\n\n        // All layers failed\n        Err(anyhow::anyhow!(\n            \"Pool address not found for {} after trying all 4 layers. Total time: {}ms. Registry has {} pools.\",\n            short_id,\n            start_time.elapsed().as_millis(),\n            self.pool_count()\n        ))\n    }\n\n    /// Query ShredStream service API for full pool address (Layer 2)\n    async fn query_shredstream_api(&self, short_id: &str) -> Result<Pubkey> {\n        let url = format!(\"{}/api/pool/{}\", self.shredstream_url, short_id);\n\n        debug!(\"???? Querying ShredStream API: {}\", url);\n\n        let response = self\n            .http_client\n            .get(&url)\n            .timeout(Duration::from_millis(500))\n            .send()\n            .await\n            .context(\"ShredStream API request failed\")?;\n\n        if !response.status().is_success() {\n            return Err(anyhow::anyhow!(\n                \"ShredStream API returned status: {}\",\n                response.status()\n            ));\n        }\n\n        let pool_response: ShredStreamPoolResponse = response\n            .json()\n            .await\n            .context(\"Failed to parse ShredStream API response\")?;\n\n        // Try both possible field names\n        let address_str = pool_response\n            .full_address\n            .or(pool_response.pool_address)\n            .ok_or_else(|| anyhow::anyhow!(\"ShredStream API response missing pool address\"))?;\n\n        address_str\n            .parse::<Pubkey>()\n            .context(\"Failed to parse pool address from ShredStream API\")\n    }\n\n    /// Query on-chain using getProgramAccounts (Layer 4 - SLOW)\n    async fn query_on_chain(&self, short_id: &str, dex_type: &DexType) -> Result<Pubkey> {\n        debug!(\n            \"???? Querying on-chain for pool: {} ({:?})\",\n            short_id, dex_type\n        );\n\n        // Get the program ID for this DEX type (reserved for future validation)\n        let _program_id = match dex_type {\n            // Meteora variants\n            DexType::MeteoraDammV1 => {","nrTokens":0,"nrLines":366,"files":[{"filePath":"src/pool_registry.rs","startLine":25,"endLine":390},{"filePath":"clean_arb_bot/src/pool_registry.rs","startLine":25,"endLine":361}]}},{"DuplicationClone":{"cloneLines":")\n            .await\n    }\n\n    /// Build swap instruction for given DEX type (async for pool resolution)\n    async fn build_swap_instruction(\n        &self,\n        dex_type: &DexType,\n        pool_short_id: &str,\n        swap_params: &SwapParams,\n        user_pubkey: &Pubkey,\n    ) -> Result<Instruction> {\n        match dex_type {\n            // Meteora variants (all use same builder)\n            DexType::MeteoraDammV1 | DexType::MeteoraDammV2 | DexType::MeteoraDlmm => {\n                self.meteora_builder\n                    .build_swap_instruction(pool_short_id, swap_params, user_pubkey)","nrTokens":0,"nrLines":17,"files":[{"filePath":"src/swap_executor.rs","startLine":489,"endLine":505},{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":483,"endLine":500}]}},{"DuplicationClone":{"cloneLines":"});\n\n        // CRITICAL FIX: For now, we need to return a single instruction\n        // But we should log a warning if we're dropping ATA creation instructions\n        if all_instructions.len() > 1 {\n            warn!(\"?????? CRITICAL: Dropping {} ATA creation instructions!\", all_instructions.len() - 1);\n            warn!(\"   This will cause transaction failures if ATAs don't exist\");\n            warn!(\"   TODO: Update function signature to return Vec<Instruction>\");\n        }\n\n        // Return the LAST instruction (the swap), not the first (which would be ATA creation)\n        Ok(all_instructions.into_iter().last().unwrap())\n    }\n\n    /// Fetch pool state from blockchain\n    fn fetch_pool_state(&self, pool_address: &Pubkey) -> Result<Vec<u8>> {\n        self.rpc_client\n            .get_account_data(pool_address)\n            .context(\"Failed to fetch Orca Whirlpool state\"","nrTokens":0,"nrLines":19,"files":[{"filePath":"clean_arb_bot/src/orca.rs","startLine":265,"endLine":283},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":280,"endLine":298}]}},{"DuplicationClone":{"cloneLines":"// Only retry on transient errors\n                    let is_transient = e.to_string().contains(\"timeout\")\n                        || e.to_string().contains(\"network\")\n                        || e.to_string().contains(\"connection\");\n\n                    if !is_transient || attempt == 3 {\n                        self.record_failure();  // CYCLE-5: Increment circuit breaker on failure\n                        return Err(anyhow::anyhow!(\"Failed to fetch account {} after {} attempts: {}\"","nrTokens":0,"nrLines":8,"files":[{"filePath":"clean_arb_bot/src/rpc_client.rs","startLine":232,"endLine":239},{"filePath":"clean_arb_bot/src/rpc_client.rs","startLine":105,"endLine":112}]}},{"DuplicationClone":{"cloneLines":") -> Result<Self> {\n        let program_id = Self::AMM_V4_PROGRAM_ID\n            .parse()\n            .context(\"Failed to parse Raydium AMM V4 program ID\")?;\n\n        info!(\"??? Raydium swap builder initialized (AMM V4 + CLMM + CPMM + Stable)\");\n        info!(\"   AMM V4 Program ID: {}\", Self::AMM_V4_PROGRAM_ID);\n        info!(\"   CLMM Program ID: {}\", Self::CLMM_PROGRAM_ID);\n        info!(\"   CPMM Program ID: {}\", Self::CPMM_PROGRAM_ID);\n        info!(\"   Stable Program ID: {}\", Self::STABLE_PROGRAM_ID);\n\n        Ok(Self {\n            rpc_client,\n            pool_registry,\n            program_id,\n        })\n    }\n\n    /// Build swap instruction for Raydium CPMM pool\n    ///\n    /// # Arguments\n    /// * `pool_short_id` - 8-char short pool ID from ShredStream\n    /// * `swap_params` - Swap parameters (amount_in, minimum_amount_out, direction)\n    /// * `user_pubkey` - User's wallet public key\n    ///\n    /// # Returns\n    /// Solana instruction for the swap\n    pub async fn build_swap_instruction(\n        &self,\n        pool_short_id: &str,\n        swap_params: &SwapParams,\n        user_pubkey: &Pubkey,\n    ) -> Result<Instruction> {\n        debug!(\n            \"Building Raydium swap instruction for pool: {}\",\n            pool_short_id\n        );\n\n        // Step 1: Resolve pool address from short ID\n        // Try all Raydium variants (AMM V4 most common, then CPMM, CLMM, Stable)\n        let pool_address = match self\n            .pool_registry\n            .resolve_pool_address(pool_short_id, &crate::types::DexType::RaydiumAmmV4)\n            .await\n        {\n            Ok(addr) => addr,\n            Err(_) => {\n                // Try CPMM if AMM V4 fails\n                match self\n                    .pool_registry\n                    .resolve_pool_address(pool_short_id, &crate::types::DexType::RaydiumCpmm)\n                    .await\n                {\n                    Ok(addr) => addr,\n                    Err(_) => {\n                        // Try CLMM if CPMM fails\n                        match self\n                            .pool_registry\n                            .resolve_pool_address(\n                                pool_short_id,\n                                &crate::types::DexType::RaydiumClmm,","nrTokens":0,"nrLines":61,"files":[{"filePath":"src/raydium.rs","startLine":48,"endLine":108},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":51,"endLine":103}]}},{"DuplicationClone":{"cloneLines":";\n\nuse arbitrage_engine::ArbitrageEngine;\nuse config::Config;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    // Initialize logging\n    tracing_subscriber::fmt()\n        .with_env_filter(\"info,clean_arb_bot=debug\")\n        .init();\n\n    info!(\"???? Starting Clean Arbitrage Bot\");\n    info!(\"?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????\");\n\n    // Load configuration\n    let config = Config::from_env()?;\n\n    info!(\"??? Configuration loaded:\");\n    info!(\"  ??? ShredStream service: {}\", config.shredstream_url);\n    info!(\"  ??? Capital: {:.2} SOL\", config.capital_sol);\n    info!(\n        \"  ??? Max position: {:.2} SOL ({:.0}% of tradable capital)\",\n        config.max_position_size_sol,\n        (config.max_position_size_sol / config.capital_sol) * 100.0\n    );\n    info!(\"  ??? Profit requirement: Dynamic (costs + 0.2% margin calculated per opportunity)\");\n    info!(\"  ??? Min spread: DYNAMIC (calculated per opportunity: [total_costs + margin] / position_size)\");\n    info!(\n        \"  ??? Trading mode: {}\",\n        if config.paper_trading {\n            \"PAPER\"\n        } else {\n            \"LIVE\"\n        }\n    );\n\n    // Create shutdown channel (Grok recommendation: explicit shutdown signaling)\n    let (shutdown_tx, shutdown_rx) = broadcast::channel(1);\n\n    // Spawn JITO tip floor monitor (updates every 30 minutes)\n    info!(\"???? Starting JITO tip floor monitor...\");\n    let jito_tip_floor = jito_tip_monitor::spawn_monitor();\n    info!(\"??? JITO tip monitor started (dynamic competitive tipping)\");\n\n    // Create arbitrage engine with shutdown receiver and tip floor\n    info!(\"???? Initializing arbitrage engine...\");\n    let mut engine = ArbitrageEngine::new(config.clone(), shutdown_rx, jito_tip_floor).await?;\n    info!(\"??? Arbitrage engine ready\");\n\n    // Populate pool registry if real trading is enabled\n    if !config.paper_trading && config.enable_real_trading {\n        if let Some(ref pool_registry) = engine.get_pool_registry() {\n            info!(\"???? Populating pool registry for real trading...\");\n            pool_population::populate_known_pools(pool_registry.clone())?;\n        }\n    }\n\n    // Set up graceful shutdown handler (Grok recommendation: explicit error handling)\n    let shutdown_handle = tokio::spawn(async move {\n        match signal::ctrl_c().await {\n            Ok(()) => {\n                info!(\"???? Shutdown signal received (Ctrl+C)\");\n                let _ = shutdown_tx.send(()); // Signal engine to stop\n                Ok(())\n            }\n            Err(err) => {\n                error!(\"??? Failed to listen for shutdown signal: {}\", err);\n                Err(err)\n            }\n        }\n    });\n\n    info!(\"?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????\");\n    info!(\"???? Arbitrage Bot is LIVE - Scanning for opportunities...\");\n    info!(\"???? Press Ctrl+C to stop gracefully\");\n    info!(\"?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????\");\n\n    // Run arbitrage engine (Grok recommendation: cooperative cancellation via shutdown channel)\n    let engine_result = tokio::select! {\n        result = engine.run() => {\n            match result {\n                Ok(()) => {\n                    info!(\"??? Arbitrage engine stopped normally\");\n                    Ok(())\n                }\n                Err(e) => {\n                    error!(\"??? Arbitrage engine failed: {}\", e);\n                    Err(e)\n                }\n            }\n        }\n        shutdown_result = shutdown_handle => {\n            match shutdown_result {\n                Ok(Ok(())) => {\n                    info!(\"??? Shutdown handler completed successfully\");\n                    Ok(())\n                }\n                Ok(Err(e)) => {\n                    error!(\"??? Shutdown handler failed: {}\", e);\n                    Err(anyhow::anyhow!(\"Shutdown handler error: {}\", e))\n                }\n                Err(e) => {\n                    error!(\"??? Shutdown task panicked: {}\", e);\n                    Err(anyhow::anyhow!(\"Shutdown task panic: {}\", e))\n                }\n            }\n        }\n    };\n\n    // Allow engine to finish cleanup before accessing stats\n    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n\n    // Final statistics (Grok recommendation: ensure thread-safe access post-cancellation)\n    let stats = engine.get_stats();\n    info!(\"?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????\");\n    info!(\"???? Final Statistics:\");\n    info!(\n        \"  ??? Runtime: {:.1} minutes\",\n        stats.runtime_seconds as f64 / 60.0\n    );\n    info!(\n        \"  ??? Opportunities detected: {}\",\n        stats.opportunities_detected\n    );\n    info!(\n        \"  ??? Opportunities executed: {}\",\n        stats.opportunities_executed\n    );\n    info!(\"  ??? Success rate: {:.1}%\", stats.success_rate());\n    info!(\"  ??? Total profit: {:.6} SOL\", stats.total_profit_sol);\n    info!(\"  ??? Failed executions: {}\", stats.failed_executions);\n    info!(\"?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????\");\n    info!(\"???? Arbitrage Bot shutdown complete\");\n\n    engine_result\n}","nrTokens":0,"nrLines":137,"files":[{"filePath":"src/main.rs","startLine":43,"endLine":179},{"filePath":"clean_arb_bot/src/main.rs","startLine":43,"endLine":159}]}},{"DuplicationClone":{"cloneLines":"() {\n        let rpc_url = \"https://api.mainnet-beta.solana.com\".to_string();\n        let rpc_client = Arc::new(SolanaRpcClient::new(rpc_url));\n        let registry = PoolRegistry::new(rpc_client);\n\n        // Create a test pool","nrTokens":0,"nrLines":6,"files":[{"filePath":"clean_arb_bot/src/pool_registry.rs","startLine":587,"endLine":592},{"filePath":"clean_arb_bot/src/pool_registry.rs","startLine":578,"endLine":583}]}},{"DuplicationClone":{"cloneLines":"///\n    /// # Arguments\n    /// * `pool_short_id` - 8-char short pool ID from ShredStream\n    /// * `swap_params` - Swap parameters (amount_in, minimum_amount_out, direction)\n    /// * `user_pubkey` - User's wallet public key\n    ///\n    /// # Returns\n    /// Solana instruction for the swap\n    pub async fn build_swap_instruction(\n        &self,\n        pool_short_id: &str,\n        swap_params: &SwapParams,\n        user_pubkey: &Pubkey,\n    ) -> Result<Instruction> {\n        debug!(\"Building Orca Whirlpool swap instruction for pool: {}\"","nrTokens":0,"nrLines":15,"files":[{"filePath":"clean_arb_bot/src/orca.rs","startLine":60,"endLine":74},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":70,"endLine":84}]}},{"DuplicationClone":{"cloneLines":"use anyhow::Result;\nuse serde::Deserialize;\nuse std::collections::HashMap;\nuse tracing::{debug, warn};\n\n/// Jupiter Price API response\n#[derive(Debug, Deserialize)]\npub struct JupiterPriceResponse {\n    pub data: HashMap<String, JupiterTokenPrice>,\n}\n\n/// Jupiter token price data\n#[derive(Debug, Deserialize, Clone)]\npub struct JupiterTokenPrice {\n    pub id: String,\n    pub price: String, // String because it can be very precise\n    #[serde(rename = \"mintSymbol\")]\n    pub mint_symbol: Option<String>,\n}\n\n/// Jupiter Price API client\npub struct JupiterPriceClient {\n    client: reqwest::Client,\n    base_url: String,\n    api_key: Option<String>,\n}\n\nimpl JupiterPriceClient {\n    /// Create new Jupiter Price API client with ultra endpoint\n    pub fn new(api_key: Option<String>) -> Self {\n        // Use ultra endpoint if API key provided, otherwise regular\n        let base_url = if api_key.is_some() {\n            \"https://api.jup.ag/ultra/price/v2\".to_string()\n        } else {\n            \"https://api.jup.ag/price/v2\".to_string()\n        };\n\n        Self {\n            client: reqwest::Client::new(),\n            base_url,\n            api_key,\n        }\n    }\n\n    /// Fetch prices for multiple token mints\n    /// Returns HashMap of mint ??? price in SOL\n    pub async fn fetch_prices(&self, mints: &[String]) -> Result<HashMap<String, f64>> {\n        if mints.is_empty() {\n            return Ok(HashMap::new());\n        }\n\n        // Jupiter API accepts comma-separated mints\n        let ids = mints.join(\",\");\n        let url = format!(\"{}?ids={}\", self.base_url, ids);\n\n        debug!(\"???? Fetching Jupiter prices for {} tokens\", mints.len());\n\n        // Build request with API key if provided\n        let mut request = self.client.get(&url);\n        if let Some(ref key) = self.api_key {\n            request = request.header(\"X-API-Key\", key);\n        }\n\n        match request.send().await {\n            Ok(response) => {\n                let price_response: JupiterPriceResponse = response.json().await?;\n\n                let mut prices = HashMap::new();\n                for (mint, price_data) in price_response.data {\n                    if let Ok(price) = price_data.price.parse::<f64>() {\n                        prices.insert(mint, price);\n                    }\n                }\n\n                debug!(\"??? Fetched {} Jupiter prices\", prices.len());\n                Ok(prices)\n            }\n            Err(e) => {\n                warn!(\"??? Failed to fetch Jupiter prices: {}\", e);\n                Err(anyhow::anyhow!(\"Jupiter API error: {}\", e))\n            }\n        }\n    }\n\n    /// Fetch price for a single token\n    pub async fn fetch_price(&self, mint: &str) -> Result<f64> {\n        let prices = self.fetch_prices(&[mint.to_string()]).await?;\n        prices\n            .get(mint)\n            .copied()\n            .ok_or_else(|| anyhow::anyhow!(\"Price not found for mint: {}\", mint))\n    }\n\n    /// Get best price across multiple DEXs for a token\n    /// Jupiter aggregates across all DEXs automatically\n    pub async fn get_best_price(&self, mint: &str) -> Result<f64> {\n        self.fetch_price(mint).await\n    }\n}\n\n/// Cross-DEX arbitrage opportunity using Jupiter\n#[derive(Debug, Clone)]\npub struct JupiterArbitrageOpportunity {\n    pub token_mint: String,\n    pub shredstream_dex: String,\n    pub shredstream_price: f64,\n    pub jupiter_price: f64, // Best aggregated price\n    pub spread_percentage: f64,\n    pub estimated_profit_sol: f64,\n    pub direction: String, // \"buy_shredstream_sell_jupiter\" or vice versa\n}\n\n/// Find arbitrage between ShredStream DEX prices and Jupiter aggregated prices\npub async fn find_jupiter_arbitrage(\n    shredstream_prices: &HashMap<String, crate::shredstream_client::TokenPrice>,\n    jupiter_client: &JupiterPriceClient,\n    min_profit_sol: f64,\n    min_spread_percentage: f64,\n    capital_sol: f64,\n) -> Result<Vec<JupiterArbitrageOpportunity>> {\n    let mut opportunities = Vec::new();\n\n    // Get unique token mints from ShredStream\n    let mut token_mints: Vec<String> = shredstream_prices\n        .values()\n        .map(|p| p.token_mint.clone())\n        .collect();\n    token_mints.sort();\n    token_mints.dedup();\n\n    debug!(\n        \"???? Comparing {} tokens: ShredStream vs Jupiter\",\n        token_mints.len()\n    );\n\n    // Rate limiting: Jupiter allows 50 requests per 10 seconds\n    // To be safe with other bots: limit to 5 batches per scan (5 requests)\n    // This gives us 500 tokens checked per scan cycle\n    const BATCH_SIZE: usize = 100;\n    const MAX_BATCHES_PER_SCAN: usize = 5; // Only 5 requests per scan (well under 50/10sec)\n\n    let mut batch_count = 0;\n    for chunk in token_mints.chunks(BATCH_SIZE) {\n        if batch_count >= MAX_BATCHES_PER_SCAN {\n            debug!(\n                \"?????? Rate limit: stopping at {} tokens ({} batches)\",\n                batch_count * BATCH_SIZE,\n                batch_count\n            );\n            break;\n        }\n\n        let jupiter_prices = match jupiter_client.fetch_prices(chunk).await {\n            Ok(prices) => prices,\n            Err(e) => {\n                warn!(\"?????? Jupiter batch failed: {}\", e);\n                continue;\n            }\n        };\n\n        batch_count += 1;\n\n        // Compare each token's prices\n        for mint in chunk {\n            let jupiter_price = match jupiter_prices.get(mint) {\n                Some(price) => *price,\n                None => continue,\n            };\n\n            // Find ShredStream prices for this token\n            for shredstream_price in shredstream_prices.values() {\n                if &shredstream_price.token_mint != mint {\n                    continue;\n                }\n\n                // Calculate spread\n                let spread = (jupiter_price - shredstream_price.price_sol).abs();\n                let spread_percentage = (spread / shredstream_price.price_sol) * 100.0;\n\n                if spread_percentage < min_spread_percentage {\n                    continue;\n                }\n\n                // Determine direction and calculate profit\n                let (direction, _buy_price, _sell_price) =\n                    if jupiter_price > shredstream_price.price_sol {\n                        (\n                            \"buy_shredstream_sell_jupiter\",\n                            shredstream_price.price_sol,\n                            jupiter_price,","nrTokens":0,"nrLines":190,"files":[{"filePath":"src/jupiter_prices.rs","startLine":1,"endLine":190},{"filePath":"clean_arb_bot/src/jupiter_prices.rs","startLine":1,"endLine":180}]}},{"DuplicationClone":{"cloneLines":";\n\n/// Orca swap instruction builder (supports Whirlpools + Legacy)\npub struct OrcaSwapBuilder {\n    /// RPC client for fetching pool state\n    rpc_client: Arc<SolanaRpcClient>,\n    /// Pool registry for address resolution\n    pool_registry: Arc<PoolRegistry>,\n    /// Orca Whirlpools program ID (default)\n    program_id: Pubkey,\n}\n\nimpl OrcaSwapBuilder {\n    /// Orca Whirlpools program ID (concentrated liquidity)\n    pub const WHIRLPOOLS_PROGRAM_ID: &'static str = \"whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc\";\n\n    /// Orca Legacy program ID (older AMM)\n    pub const LEGACY_PROGRAM_ID: &'static str = \"9W959DqEETiGZocYWCQPaJ6sBmUzgfxXfqGeTEdp3aQP\";\n\n    /// Create new Orca swap builder\n    pub fn new(rpc_client: Arc<SolanaRpcClient>, pool_registry: Arc<PoolRegistry>)","nrTokens":0,"nrLines":21,"files":[{"filePath":"src/orca.rs","startLine":17,"endLine":37},{"filePath":"clean_arb_bot/src/orca.rs","startLine":20,"endLine":42}]}},{"DuplicationClone":{"cloneLines":");\n                                let data_len = data.len() as u64;  // Capture length before move\n                                packet::Packet {\n                                    data,\n                                    meta: Some(packet::Meta {\n                                        size: data_len,\n                                        addr: String::new(),\n                                        port: 0,\n                                        flags: Some(packet::PacketFlags {\n                                            discard: false,\n                                            forwarded: false,\n                                            repair: false,\n                                            simple_vote_tx: false,\n                                            tracer_packet: false,\n                                            from_staked_node: false,\n                                        }),\n                                        sender_stake: 0,\n                                    }),\n                                }\n                            })\n                            .collect(),","nrTokens":0,"nrLines":21,"files":[{"filePath":"clean_arb_bot/src/jito_grpc_client.rs","startLine":168,"endLine":188},{"filePath":"clean_arb_bot/src/jito_grpc_client.rs","startLine":112,"endLine":133}]}},{"DuplicationClone":{"cloneLines":");\n            }\n        }\n\n        Self { dexs }\n    }\n\n    pub fn get_all_dexs(&self) -> &HashMap<String, DexInfo> {\n        &self.dexs\n    }\n\n    pub fn get_dex(&self, name: &str) -> Option<&DexInfo> {\n        self.dexs.get(name)\n    }\n\n    /// Get all DEX pairs for arbitrage scanning\n    pub fn get_arbitrage_pairs(&self) -> Vec<(&DexInfo, &DexInfo)> {\n        let dex_list: Vec<&DexInfo> = self.dexs.values().collect();\n        let mut pairs = Vec::new();\n\n        for i in 0..dex_list.len() {\n            for j in (i + 1)..dex_list.len() {\n                pairs.push((dex_list[i], dex_list[j]));\n            }\n        }\n\n        pairs\n    }\n}","nrTokens":0,"nrLines":29,"files":[{"filePath":"src/dex_registry.rs","startLine":122,"endLine":150},{"filePath":"clean_arb_bot/src/dex_registry.rs","startLine":59,"endLine":87}]}},{"DuplicationClone":{"cloneLines":"drop(grpc);\n\n                            // Fallback to HTTP\n                            match tokio::time::timeout(\n                                Duration::from_secs(10),\n                                http_clone.submit_bundle_safe(request.transactions.clone()),\n                            )\n                            .await\n                            {\n                                Ok(Ok(uuid)) => {\n                                    info!(\"???? JITO bundle submitted via HTTP (fallback): {}\", uuid);\n                                    Ok(uuid)\n                                }\n                                Ok(Err(e","nrTokens":0,"nrLines":14,"files":[{"filePath":"src/jito_submitter.rs","startLine":184,"endLine":197},{"filePath":"src/jito_submitter.rs","startLine":159,"endLine":172}]}},{"DuplicationClone":{"cloneLines":").await {\n            Ok(full_address) => {\n                let latency = start_time.elapsed().as_millis() as u64;\n\n                // Update stats atomically after network call completes\n                {\n                    let mut stats = self.resolution_stats.write().unwrap();\n                    stats.layer4_hits","nrTokens":0,"nrLines":8,"files":[{"filePath":"clean_arb_bot/src/pool_registry.rs","startLine":243,"endLine":250},{"filePath":"clean_arb_bot/src/pool_registry.rs","startLine":204,"endLine":211}]}},{"DuplicationClone":{"cloneLines":"// PumpSwap DEX swap implementation (FIXED 2025-10-14)\n// Program ID: pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA\n//\n// PumpSwap is a constant-product AMM (like Uniswap v2 / Raydium v4)\n// - Fee: 0.25% (0.2% to LPs, 0.05% to protocol)\n// - Mechanism: x * y = k constant product\n// - Tokens: Post-migration Pump.fun tokens\n//\n// FIXES APPLIED (2025-10-14):\n// - Pool structure offsets corrected (+8 for Anchor discriminator)\n// - Correct 12-account structure (Grok-verified from program analysis)\n// - Vault PDAs derived with seeds [\"vault\", pool, mint]\n// - Proper account ordering (user first, pool at position 7)\n//\n// Implementation based on Grok AI analysis of PumpSwap AMM program structure\n\nuse anyhow::{Context, Result};\nuse solana_sdk::{\n    instruction::{AccountMeta, Instruction},\n    pubkey::Pubkey,\n};\nuse std::str::FromStr;\nuse tracing::{debug, info};\n\nuse crate::rpc_client::SolanaRpcClient;\n\n/// PumpSwap program ID\npub const PUMPSWAP_PROGRAM_ID: &str = \"pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA\";\n\n/// SPL Token program ID\nconst SPL_TOKEN_PROGRAM_ID: &str = \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\";\n\n/// Associated Token Account program ID\nconst ASSOCIATED_TOKEN_PROGRAM_ID: &str = \"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\";\n\n/// System program ID\nconst SYSTEM_PROGRAM_ID: &str = \"11111111111111111111111111111111\";\n\n/// BUY instruction discriminator (verified from on-chain tx 2025-10-13)\nconst BUY_DISCRIMINATOR: [u8; 8] = [102, 6, 61, 18, 1, 218, 235, 234];\n\n/// SELL instruction discriminator (from ShredStream parser)\nconst SELL_DISCRIMINATOR: [u8; 8] = [51, 230, 133, 164, 1, 127, 131, 173];\n\n/// PumpSwap pool accounts structure\n/// Parsed from 300-byte pool account (PDA owned by PumpSwap program)\n///\n/// NOTE: pool_base_account and pool_quote_account are read from pool data\n/// but NOT used in swap instructions - vaults are derived as PDAs instead!\n#[derive(Debug, Clone)]\npub struct PumpSwapPool {\n    pub pool_address: Pubkey,\n    pub base_mint: Pubkey, // Token mint (offset 43, +8 for Anchor discriminator)\n    pub quote_mint: Pubkey, // SOL/WSOL mint (offset 75, +8)\n    pub pool_base_account: Pubkey, // Pool's token vault (offset 139, +8) - NOT USED IN SWAPS\n    pub pool_quote_account: Pubkey, // Pool's SOL vault (offset 171, +8) - NOT USED IN SWAPS\n}\n\n/// PumpSwap swap builder\npub struct PumpSwapSwapBuilder {\n    program_id: Pubkey,\n    rpc_client: std::sync::Arc<SolanaRpcClient>,\n}\n\nimpl PumpSwapSwapBuilder {\n    /// Create new PumpSwap swap builder\n    pub fn new(rpc_client: std::sync::Arc<SolanaRpcClient>) -> Result<Self> {\n        let program_id =\n            Pubkey::from_str(PUMPSWAP_PROGRAM_ID).context(\"Invalid PumpSwap program ID\")?;\n\n        info!(\"??? PumpSwap swap builder initialized (FIXED 2025-10-13)\");\n        info!(\"   Program ID: {}\", program_id);\n\n        Ok(Self {\n            program_id,\n            rpc_client,\n        })\n    }\n\n    /// Build a swap instruction for PumpSwap AMM\n    ///\n    /// CORRECT IMPLEMENTATION (2025-10-14): Uses Grok-verified 12-account structure\n    /// with proper vault PDA derivation. This is the production-ready version.\n    pub fn build_swap_instruction(\n        &self,\n        pool: &PumpSwapPool,\n        user_wallet: &Pubkey,\n        amount_in: u64,\n        minimum_amount_out: u64,\n        swap_a_to_b: bool, // true = SOL -> Token (BUY), false = Token -> SOL (SELL)\n    ) -> Result<Instruction> {\n        debug!(\"???? Building PumpSwap swap instruction (CORRECT 12-ACCOUNT STRUCTURE)\");\n        debug!(\"   Pool: {}\", pool.pool_address);\n        debug!(\"   Amount in: {}\", amount_in);\n        debug!(\"   Min amount out: {}\", minimum_amount_out);\n        debug!(\n            \"   Direction: {}\",\n            if swap_a_to_b {\n                \"BUY (SOL->Token)\"\n            } else {\n                \"SELL (Token->SOL)\"\n            }\n        );\n\n        // Get user's token accounts\n        let user_base_account = spl_associated_token_account::get_associated_token_address(\n            user_wallet,\n            &pool.base_mint,","nrTokens":0,"nrLines":108,"files":[{"filePath":"src/pumpswap.rs","startLine":1,"endLine":108},{"filePath":"clean_arb_bot/src/pumpswap.rs","startLine":1,"endLine":102}]}},{"DuplicationClone":{"cloneLines":"let pool_info = self.pool_registry.get_pool(pool_short_id).ok_or_else(|| {\n            anyhow::anyhow!(\n                \"Pool {} resolved but info not cached. This shouldn't happen.\",\n                pool_short_id\n            )\n        })?;\n\n        // Step 2: Fetch pool state from blockchain\n        let pool_state = self\n            .fetch_pool_state(&pool_address)\n            .context(\"Failed to fetch pool state\")?;\n\n        debug!(\"??? Got pool state ({} bytes)\", pool_state.len());\n\n        // Step 3: Parse Orca Whirlpool state for critical data","nrTokens":0,"nrLines":15,"files":[{"filePath":"src/orca.rs","startLine":121,"endLine":135},{"filePath":"src/raydium.rs","startLine":155,"endLine":169}]}},{"DuplicationClone":{"cloneLines":"match tokio::time::timeout(\n                        Duration::from_secs(10),\n                        http_clone.submit_bundle_safe(request.transactions.clone()),\n                    )\n                    .await\n                    {\n                        Ok(Ok(uuid)) => {\n                            info!(\"???? JITO bundle submitted via HTTP: {}\"","nrTokens":0,"nrLines":8,"files":[{"filePath":"src/jito_submitter.rs","startLine":204,"endLine":211},{"filePath":"src/jito_submitter.rs","startLine":162,"endLine":169}]}},{"DuplicationClone":{"cloneLines":")\n                    .await\n            }\n\n            DexType::PumpSwap => {\n                // Resolve pool address from short ID\n                let pool_address = self\n                    .pool_registry\n                    .resolve_pool_address(pool_short_id, dex_type)\n                    .await\n                    .context(format!(\n                        \"Failed to resolve PumpSwap pool address for {}\",\n                        pool_short_id\n                    ))?;\n\n                // Fetch pool info from on-chain data\n                let pool_info = self\n                    .pumpswap_builder\n                    .fetch_pool_info(&pool_address)\n                    .context(\"Failed to fetch PumpSwap pool info\")?;\n\n                // Build swap instruction\n                self.pumpswap_builder.build_swap_instruction(\n                    &pool_info,\n                    user_pubkey,\n                    swap_params.amount_in,\n                    swap_params.minimum_amount_out,\n                    swap_params.swap_a_to_b,\n                )\n            }\n\n            // HumidiFi dark pool\n            DexType::HumidiFi => {\n                debug!(\n                    \"???? Building HumidiFi swap instruction for pool {}\",\n                    pool_short_id\n                );\n\n                // Get HumidiFi builder (should be initialized)\n                let builder = self\n                    .humidifi_builder\n                    .as_ref()\n                    .ok_or_else(|| anyhow::anyhow!(\"HumidiFi builder not initialized\"))?;\n\n                // Resolve pool address from short ID\n                let pool_address = self\n                    .pool_registry\n                    .resolve_pool_address(pool_short_id, dex_type)\n                    .await\n                    .context(format!(\n                        \"Failed to resolve HumidiFi pool address for {}\",\n                        pool_short_id\n                    ))?;\n\n                // TODO: Fetch actual token mints from pool account data (like Meteora/Orca do)\n                // For now, use common token mints (SOL/USDC) since HumidiFi primarily deals with these pairs\n                // This is a temporary solution that works for most HumidiFi pools\n                use solana_sdk::pubkey;\n                let sol_mint = pubkey!(\"So11111111111111111111111111111111111111112\"); // Wrapped SOL\n                let usdc_mint = pubkey!(\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\"); // USDC\n\n                // Determine token direction based on swap_a_to_b\n                let (token_a, token_b) = if swap_params.swap_a_to_b {\n                    (sol_mint, usdc_mint)\n                } else {\n                    (usdc_mint, sol_mint)\n                };\n\n                // Build swap instruction using legacy method (raw addresses)\n                let instructions = builder\n                    .build_swap_instruction_legacy(\n                        pool_address,\n                        *user_pubkey,\n                        token_a,\n                        token_b,\n                        swap_params.amount_in,\n                        swap_params.minimum_amount_out,\n                        swap_params.swap_a_to_b,\n                    )\n                    .await?;\n\n                // Return first instruction (should be single swap instruction)\n                instructions\n                    .into_iter()\n                    .next()\n                    .ok_or_else(|| anyhow::anyhow!(\"HumidiFi builder returned no instructions\"))\n            }\n\n            // Not yet implemented DEXes - gracefully skip\n            DexType::Jupiter\n            | DexType::Serum\n            | DexType::Aldrin\n            | DexType::Saros\n            | DexType::Crema\n            | DexType::Cropper\n            | DexType::Lifinity\n            | DexType::Fluxbeam => {\n                warn!(\n                    \"?????? DEX {:?} not yet implemented - skipping opportunity on pool {}\",\n                    dex_type, pool_short_id\n                );\n                warn!(\n                    \"   To enable this DEX, implement builder in src/{}.rs\",\n                    format!(\"{:?}\", dex_type).to_lowercase()\n                );\n                Err(anyhow::anyhow!(\"DEX {:?} implementation pending\", dex_type))\n            }\n        }\n    }\n\n    /// Build complete transaction with compute budget instructions\n    fn build_transaction<T: Signer>(\n        &self,\n        swap_instructions: Vec<Instruction>,\n        wallet: &T,\n        recent_blockhash: Hash,\n    ) -> Result<Transaction> {\n        let mut instructions = Vec::new();\n\n        // HIGH FIX: Dynamic compute budget based on swap complexity\n        let estimated_cu = match swap_instructions.len() {\n            1 => 100_000, // Single swap\n            2 => 200_000, // 2-leg arbitrage\n            3 => 300_000, // Triangle arbitrage\n            _ => 400_000, // Complex multi-hop\n        };\n\n        // Add 20% safety buffer\n        let compute_limit = (estimated_cu as f64 * 1.2) as u32;\n\n        debug!(\n            \"Estimated compute units: {} (with 20% buffer: {})\",\n            estimated_cu, compute_limit\n        );\n\n        // Add compute budget instructions first\n        instructions.push(ComputeBudgetInstruction::set_compute_unit_price(\n            self.compute_unit_price,","nrTokens":0,"nrLines":138,"files":[{"filePath":"src/swap_executor.rs","startLine":523,"endLine":660},{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":520,"endLine":623}]}},{"DuplicationClone":{"cloneLines":")?;\n\n    // 2. JitoSOL-SOL (High Liquidity #2)\n    pool_registry.register_pool(\n        \"BoeMUkCL\".to_string(),\n        PoolInfo {\n            full_address: \"BoeMUkCLHchTD31HdXsbDExuZZfcUppSLpYtV3LZTH6U\".parse()?,\n            dex_type: DexType::MeteoraDammV2,\n            token_a_mint: \"J1toso1uCk3RLmjorhTtrVwY9HJ7X8V9yYac6Y7kGCPn\".parse()?, // JitoSOL\n            token_b_mint: \"So11111111111111111111111111111111111111112\".parse()?,  // SOL\n            reserve_a: \"93d6ukn24o1xMcMDip2SACKG8GbvhGUZim1e3ZEcQVm2\".parse()?,\n            reserve_b: \"CodroyzrRNvc5kHRoAQYjpVSr1jA9fLcUWVFouiuWGsD\".parse()?,\n        },","nrTokens":0,"nrLines":13,"files":[{"filePath":"src/pool_population.rs","startLine":41,"endLine":53},{"filePath":"clean_arb_bot/src/pool_population.rs","startLine":41,"endLine":54}]}},{"DuplicationClone":{"cloneLines":"// Other DEXes\n            DexType::PumpSwap => \"pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA\".parse::<Pubkey>()?,\n            DexType::Jupiter => \"JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4\".parse::<Pubkey>()?,\n            DexType::Serum => \"9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin\".parse::<Pubkey>()?,\n            DexType::Aldrin => \"AMM55ShdkoGRB5jVYPjWziwk8m5MpwyDgsMWHaMSQWH6\".parse::<Pubkey>()?,\n            DexType::Saros => \"SSwpkEEWHvCXCNWnMYXVW7gCYDXkF4aQMxKdpEqrZks\".parse::<Pubkey>()?,\n            DexType::Crema => \"6MLxLqiXaaSUpkgMnWDTuejNZEz3kE7k2woyHGVFw319\".parse::<Pubkey>()?,\n            DexType::Cropper => \"CTMAxxk34HjKWxQ3QLZQA1EQdxtjbYGP4Qjrw7nTn8bM\".parse::<Pubkey>()?,\n            DexType::Lifinity => {","nrTokens":0,"nrLines":9,"files":[{"filePath":"src/pool_registry.rs","startLine":422,"endLine":430},{"filePath":"clean_arb_bot/src/pool_registry.rs","startLine":375,"endLine":383}]}},{"DuplicationClone":{"cloneLines":"::calculate_slippage(100, 100), 0.0);\n    }\n\n    #[test]\n    fn test_swap_params_validation() {\n        let rpc_url = \"https://api.mainnet-beta.solana.com\".to_string();\n        let rpc_client = Arc::new(SolanaRpcClient::new(rpc_url));\n        let pool_registry = Arc::new(PoolRegistry::new(rpc_client.clone()));\n        let builder = MeteoraSwapBuilder","nrTokens":0,"nrLines":9,"files":[{"filePath":"clean_arb_bot/src/meteora.rs","startLine":481,"endLine":489},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":494,"endLine":502}]}},{"DuplicationClone":{"cloneLines":",\n};\nuse std::sync::Arc;\nuse tracing::{debug, info, warn};\n\nuse crate::types::SwapParams;\nuse crate::rpc_client::SolanaRpcClient;\nuse crate::pool_registry::PoolRegistry;\n\n/// Orca swap instruction builder (supports Whirlpools + Legacy)","nrTokens":0,"nrLines":10,"files":[{"filePath":"clean_arb_bot/src/orca.rs","startLine":13,"endLine":22},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":15,"endLine":24}]}},{"DuplicationClone":{"cloneLines":"}\n                        }\n                        Err(_) => {\n                            warn!(\"?????? gRPC timeout - falling back to HTTP\");\n                            drop(grpc);\n\n                            // Fallback to HTTP\n                            match tokio::time::timeout(\n                                Duration::from_secs(10),\n                                http_clone.submit_bundle_safe(request.transactions.clone()),","nrTokens":0,"nrLines":10,"files":[{"filePath":"src/jito_submitter.rs","startLine":180,"endLine":189},{"filePath":"clean_arb_bot/src/jito_submitter.rs","startLine":162,"endLine":172}]}},{"DuplicationClone":{"cloneLines":")?;\n\n        // Initialize HumidiFi builder (may fail if program ID is incorrect)\n        let humidifi_builder = match HumidiFiSwapBuilder::new() {\n            Ok(builder) => {\n                info!(\"??? HumidiFi swap builder initialized\");\n                Some(builder)\n            }\n            Err(e) => {\n                warn!(\"?????? HumidiFi swap builder failed to initialize: {}\", e);\n                None\n            }\n        };\n\n        info!(\"??? Swap executor initialized\");\n        info!(\n            \"   DEX support: Meteora DLMM/DAMM V2, Orca Whirlpools, Raydium CPMM, PumpSwap{}\",\n            if humidifi_builder.is_some() {\n                \", HumidiFi\"\n            } else {\n                \"\"\n            }\n        );\n        info!(\n            \"   JITO bundles: {}\",\n            if jito_client.is_some() {\n                \"enabled\"\n            } else {\n                \"disabled\"\n            }\n        );\n\n        Ok(Self {\n            rpc_client,\n            pool_registry,\n            meteora_builder,\n            orca_builder,\n            pumpswap_builder,\n            raydium_builder,\n            humidifi_builder,\n            jito_client,\n            compute_unit_price: 1000, // 1000 micro-lamports (0.001 lamports per CU)\n            compute_unit_limit: 200_000, // 200k compute units\n        })\n    }\n\n    /// CYCLE-5 FIX: Check if RPC circuit breaker is tripped\n    /// Returns error if too many consecutive RPC failures have occurred\n    pub fn check_circuit_breaker(&self) -> Result<()> {\n        self.rpc_client.check_circuit_breaker()\n    }\n\n    /// Execute a single swap on a DEX\n    ///\n    /// CYCLE-7: MANDATORY SIMULATION (Grok recommendation for bulletproof trading)\n    /// ALL transactions are simulated before execution - no exceptions\n    ///\n    /// # Arguments\n    /// * `dex_type` - Type of DEX (Meteora, Orca, etc.)\n    /// * `pool_short_id` - 8-char pool ID from ShredStream\n    /// * `swap_params` - Swap parameters\n    /// * `wallet` - User's wallet (must be a Signer)\n    ///\n    /// # Returns\n    /// Transaction signature if successful\n    pub async fn execute_swap<T: Signer>(\n        &self,\n        dex_type: &DexType,\n        pool_short_id: &str,\n        swap_params: &SwapParams,\n        wallet: &T,\n    ) -> Result<Signature> {\n        info!(\"???? Executing swap on {:?}\", dex_type);\n        info!(\"   Pool: {}\", pool_short_id);\n        info!(\"   Amount in: {}\", swap_params.amount_in);\n        info!(\"   Min out: {}\", swap_params.minimum_amount_out);\n\n        // HIGH-2 FIX: Validate slippage tolerance\n        // Ensure minimum_amount_out is reasonable (not allowing >5% slippage)\n        if let Some(expected_out) = swap_params.expected_amount_out {\n            if swap_params.minimum_amount_out > 0 {\n                let slippage = ((expected_out - swap_params.minimum_amount_out) as f64\n                    / expected_out as f64)\n                    * 100.0;\n                if slippage > 5.0 {\n                    return Err(anyhow::anyhow!(\n                        \"Slippage validation failed: {:.2}% exceeds maximum 5%\\n   Expected: {}, Min: {}\",\n                        slippage, expected_out, swap_params.minimum_amount_out\n                    ));\n                }\n                if slippage < 0.0 {\n                    return Err(anyhow::anyhow!(\n                        \"Invalid slippage: minimum_amount_out ({}) exceeds expected_amount_out ({})\",\n                        swap_params.minimum_amount_out, expected_out\n                    ));\n                }\n                debug!(\"??? Slippage validation passed: {:.2}%\", slippage);\n            }\n        }\n\n        // Build swap instruction based on DEX type (now async for pool resolution)\n        let swap_ix = self\n            .build_swap_instruction(dex_type, pool_short_id, swap_params, &wallet.pubkey())","nrTokens":0,"nrLines":103,"files":[{"filePath":"src/swap_executor.rs","startLine":72,"endLine":174},{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":86,"endLine":176}]}},{"DuplicationClone":{"cloneLines":"use anyhow::{Context, Result};\nuse solana_sdk::{\n    instruction::Instruction,\n    pubkey::Pubkey,\n};\nuse std::sync::Arc;\nuse tracing::{debug, info, warn};\n\nuse crate::types::SwapParams;\nuse crate::rpc_client::SolanaRpcClient;\nuse crate::pool_registry::PoolRegistry;\n\n/// Meteora DLMM swap instruction builder","nrTokens":0,"nrLines":13,"files":[{"filePath":"clean_arb_bot/src/meteora.rs","startLine":6,"endLine":18},{"filePath":"clean_arb_bot/src/orca.rs","startLine":10,"endLine":24}]}},{"DuplicationClone":{"cloneLines":"let user_pubkey = wallet.pubkey();\n\n        // Build all three swap instructions (async for pool resolution)\n        let ix1 = self.build_swap_instruction(leg1.0, leg1.1, leg1.2, &user_pubkey).await?;\n        let ix2 = self.build_swap_instruction(leg2.0, leg2.1, leg2.2, &user_pubkey).await?;\n        let ix3 = self.build_swap_instruction(leg3.0, leg3.1, leg3.2, &user_pubkey).await?;\n\n        // Get recent blockhash","nrTokens":0,"nrLines":8,"files":[{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":334,"endLine":341},{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":269,"endLine":276}]}},{"DuplicationClone":{"cloneLines":")\n        };\n\n        // Get pool's vault accounts\n        let (pool_source_vault, pool_destination_vault) = if swap_a_to_b {\n            (pool.token_a_vault, pool.token_b_vault)\n        } else {\n            (pool.token_b_vault, pool.token_a_vault)\n        };\n\n        // Build instruction data\n        // HumidiFi likely uses a compact format for efficiency:\n        // [discriminator (8 bytes), amount_in (8 bytes), minimum_amount_out (8 bytes)]\n        let mut data = Vec::with_capacity(24);\n\n        // Swap discriminator - NEEDS VERIFICATION from on-chain transactions\n        // Using tentative discriminator based on common patterns\n        data.extend_from_slice(&instruction::SWAP);\n\n        // Amount in (u64 little-endian)\n        data.extend_from_slice(&amount_in.to_le_bytes());\n\n        // Minimum amount out (u64 little-endian)\n        data.extend_from_slice(&minimum_amount_out.to_le_bytes());\n\n        // Account metas (order matters!)\n        // VERIFIED from actual HumidiFi swap transaction:\n        // Transaction: 4N1LB4c5Jii7CoBryiX6gwAC6Edv9en2umFN7oz6jDtj6F97xKrdWqkdy2gnnVzyg3wf715XyNtffnQQmKgejhT\n        // This transaction consumed 33,310 CUs with 9 accounts (typical swap, not oracle update)\n        let accounts = vec![\n            AccountMeta::new_readonly(*user_wallet, true), // [0] User wallet (signer)\n            AccountMeta::new_readonly(pool.pool_address, false), // [1] Pool state/authority account\n            AccountMeta::new(pool_source_vault, false),    // [2] Pool's source token vault\n            AccountMeta::new(pool_destination_vault, false), // [3] Pool's destination token vault\n            AccountMeta::new(user_source_token, false),    // [4] User's source token account\n            AccountMeta::new(user_destination_token, false), // [5] User's destination token account\n            AccountMeta::new_readonly(sysvar::clock::id(), false), // [6] Clock sysvar\n            AccountMeta::new_readonly(self.token_program_id, false), // [7] SPL Token program\n            AccountMeta::new_readonly(sysvar::instructions::id(), false), // [8] Instructions sysvar\n        ];\n\n        debug!(\"??? HumidiFi swap instruction built with VERIFIED format from on-chain transaction analysis\");\n\n        Ok(Instruction {\n            program_id: self.program_id,\n            accounts,\n            data,\n        })\n    }\n\n    /// Build swap instruction using raw addresses (fallback method)\n    pub async fn build_swap_instruction_legacy(\n        &self,\n        pool_address: Pubkey,\n        user_wallet: Pubkey,\n        token_a_mint: Pubkey,\n        token_b_mint: Pubkey,\n        amount_in: u64,\n        minimum_amount_out: u64,\n        is_buy: bool, // true = SOL->Token, false = Token->SOL\n    ) -> Result<Vec<Instruction>> {\n        // Create a temporary pool structure\n        let pool = self.derive_pool_accounts(&pool_address, &token_a_mint, &token_b_mint)?;\n\n        // Determine swap direction\n        let swap_a_to_b = if is_buy {\n            // Assuming token_a is SOL/WSOL\n            true\n        } else {\n            false\n        };\n\n        // Build single instruction\n        let instruction = self.build_swap_instruction(\n            &pool,\n            &user_wallet,\n            amount_in,\n            minimum_amount_out,\n            swap_a_to_b,","nrTokens":0,"nrLines":79,"files":[{"filePath":"src/humidifi.rs","startLine":105,"endLine":183},{"filePath":"clean_arb_bot/src/humidifi.rs","startLine":90,"endLine":163}]}},{"DuplicationClone":{"cloneLines":"use anyhow::{Context, Result};\nuse solana_sdk::{instruction::Instruction, pubkey::Pubkey};\nuse std::sync::Arc;\nuse tracing::{debug, info, warn};\n\nuse crate::pool_registry::PoolRegistry;\nuse crate::rpc_client::SolanaRpcClient;\nuse crate::types::SwapParams;\n\n/// Meteora DLMM swap instruction builder","nrTokens":0,"nrLines":10,"files":[{"filePath":"src/meteora.rs","startLine":6,"endLine":15},{"filePath":"src/orca.rs","startLine":10,"endLine":24}]}},{"DuplicationClone":{"cloneLines":");\n\n        debug!(\"Tick Array 0: {}\", tick_arrays[0]);\n        debug!(\"Tick Array 1: {}\", tick_arrays[1]);\n        debug!(\"Tick Array 2: {}\", tick_arrays[2]);\n\n        // Step 6: Build Orca Whirlpool swap instruction\n        let instruction = self.build_orca_swap_ix(\n            &pool_address,\n            user_pubkey,\n            &user_token_in,\n            &user_token_out,\n            &token_vault_a,\n            &token_vault_b,\n            &oracle,\n            &tick_arrays,\n            swap_params,\n        )?;\n\n        // Combine setup instructions (ATA creation) with swap instruction\n        let mut all_instructions = setup_instructions;\n        all_instructions.push(instruction);\n\n        if all_instructions.len() > 1 {\n            info!(\n                \"??? Built {} instructions ({} setup + 1 swap)\",\n                all_instructions.len(),\n                all_instructions.len() - 1\n            );\n        } else {\n            info!(\"??? Built Orca Whirlpool swap instruction\");\n        }\n        info!(\"   Pool: {}\", pool_address);\n        info!(\"   Amount in: {} lamports\", swap_params.amount_in);\n        info!(\n            \"   Min amount out: {} lamports\",\n            swap_params.minimum_amount_out\n        );\n        info!(\n            \"   Direction: {}\",\n            if swap_params.swap_a_to_b {\n                \"A???B\"\n            } else {\n                \"B???A\"\n            }\n        );\n\n        // CRITICAL FIX: For now, we need to return a single instruction\n        // But we should log a warning if we're dropping ATA creation instructions\n        if all_instructions.len() > 1 {\n            warn!(\n                \"?????? CRITICAL: Dropping {} ATA creation instructions!\",\n                all_instructions.len() - 1\n            );\n            warn!(\"   This will cause transaction failures if ATAs don't exist\");\n            warn!(\"   TODO: Update function signature to return Vec<Instruction>\");\n        }\n\n        // Return the LAST instruction (the swap), not the first (which would be ATA creation)\n        Ok(all_instructions.into_iter().last().unwrap())\n    }\n\n    /// Fetch pool state from blockchain\n    fn fetch_pool_state(&self, pool_address: &Pubkey) -> Result<Vec<u8>> {\n        self.rpc_client\n            .get_account_data(pool_address)\n            .context(\"Failed to fetch Orca Whirlpool state\")\n    }\n\n    /// Get associated token account address for user\n    fn get_associated_token_address(&self, wallet: &Pubkey, mint: &Pubkey) -> Pubkey {\n        spl_associated_token_account::get_associated_token_address(wallet, mint)\n    }\n\n    /// Derive tick array addresses for Orca Whirlpool swap\n    ///\n    /// Orca Whirlpools use 3 tick arrays to handle price movements during swaps.\n    /// Each tick array covers 88 ticks (TICK_ARRAY_SIZE constant).\n    ///\n    /// Formula: start_tick_index = (current_tick / (tick_spacing * 88)) * (tick_spacing * 88)\n    ///\n    /// # Arguments\n    /// * `whirlpool` - Whirlpool address\n    /// * `tick_current_index` - Current tick from pool state\n    /// * `tick_spacing` - Tick spacing from pool state\n    /// * `program_id` - Whirlpools program ID\n    ///\n    /// # Returns\n    /// Array of 3 tick array addresses [prev, current, next]\n    fn derive_tick_arrays(\n        whirlpool: &Pubkey,\n        tick_current_index: i32,\n        tick_spacing: i32,\n        program_id: &Pubkey,\n    ) -> [Pubkey; 3] {\n        // Orca Whirlpools constant: each tick array covers 88 ticks\n        const TICK_ARRAY_SIZE: i32 = 88;\n\n        // Calculate the tick array start index that contains the current tick\n        // Formula: floor(current_tick / (tick_spacing * TICK_ARRAY_SIZE)) * (tick_spacing * TICK_ARRAY_SIZE)\n        let ticks_in_array = tick_spacing * TICK_ARRAY_SIZE;\n        let current_array_start_index = (tick_current_index / ticks_in_array) * ticks_in_array;\n\n        // Derive 3 sequential tick array PDAs: previous, current, next\n        let tick_array_prev = Self::derive_tick_array_pda(\n            whirlpool,\n            current_array_start_index - ticks_in_array,\n            program_id,\n        );\n\n        let tick_array_current =\n            Self::derive_tick_array_pda(whirlpool, current_array_start_index, program_id)","nrTokens":0,"nrLines":112,"files":[{"filePath":"src/orca.rs","startLine":259,"endLine":370},{"filePath":"clean_arb_bot/src/orca.rs","startLine":234,"endLine":330}]}},{"DuplicationClone":{"cloneLines":")?;\n\n        // Step 2: Fetch pool state from blockchain\n        let pool_state = self\n            .fetch_pool_state(&pool_address)\n            .context(\"Failed to fetch pool state\")?;\n\n        debug!(\"??? Got pool state ({} bytes)\", pool_state.len());\n\n        // Step 3: Parse Orca Whirlpool state for critical data\n        // Orca Whirlpool state structure (from Whirlpools program):\n        // - bytes 0-8: discriminator\n        // - bytes 8-40: whirlpools_config (pubkey)\n        // - bytes 40-72: whirlpool_bump (array)\n        // - bytes 72-74: tick_spacing (u16) ??? Need this for tick arrays\n        // - bytes 74-106: token_mint_a (pubkey)\n        // - bytes 106-138: token_mint_b (pubkey)\n        // - bytes 138-170: token_vault_a (pubkey)\n        // - bytes 170-202: token_vault_b (pubkey)\n        // - bytes 202-234: oracle (pubkey)\n        // - bytes 234-238: tick_current_index (i32) ??? Need this for tick arrays\n\n        if pool_state.len() < 238 {\n            return Err(anyhow::anyhow!(\n                \"Pool state too short ({} bytes). Expected at least 238 bytes for Orca Whirlpool.\",\n                pool_state.len()\n            ));\n        }\n\n        // Extract critical data from pool state\n        let tick_spacing_bytes = &pool_state[72..74];\n        let tick_spacing =\n            u16::from_le_bytes([tick_spacing_bytes[0], tick_spacing_bytes[1]]) as i32;\n\n        let token_vault_a = Pubkey::try_from(&pool_state[138..170])\n            .context(\"Failed to parse token vault A pubkey from pool state\")?;\n        let token_vault_b = Pubkey::try_from(&pool_state[170..202])\n            .context(\"Failed to parse token vault B pubkey from pool state\")?;\n        let oracle = Pubkey::try_from(&pool_state[202..234])\n            .context(\"Failed to parse oracle pubkey from pool state\")?;\n\n        // Parse current tick index (i32, 4 bytes at offset 234)\n        let tick_current_bytes = &pool_state[234..238];\n        let tick_current_index = i32::from_le_bytes([\n            tick_current_bytes[0],\n            tick_current_bytes[1],\n            tick_current_bytes[2],\n            tick_current_bytes[3],\n        ]);\n\n        debug!(\"Tick spacing: {}\", tick_spacing);\n        debug!(\"Current tick: {}\", tick_current_index);\n        debug!(\"Token Vault A: {}\", token_vault_a);\n        debug!(\"Token Vault B: {}\", token_vault_b);\n        debug!(\"Oracle: {}\", oracle);\n\n        // Step 4: Determine user token accounts\n        let (user_token_in, user_token_out) = if swap_params.swap_a_to_b {\n            // Swapping token A to token B\n            (\n                self.get_associated_token_address(user_pubkey, &pool_info.token_a_mint),\n                self.get_associated_token_address(user_pubkey, &pool_info.token_b_mint),\n            )\n        } else {\n            // Swapping token B to token A\n            (\n                self.get_associated_token_address(user_pubkey, &pool_info.token_b_mint),\n                self.get_associated_token_address(user_pubkey, &pool_info.token_a_mint),\n            )\n        };\n\n        debug!(\"User token in: {}\", user_token_in);\n        debug!(\"User token out: {}\", user_token_out);\n\n        // Auto-create token accounts if they don't exist\n        let mut setup_instructions = Vec::new();\n\n        if !self.rpc_client.account_exists(&user_token_in)? {\n            info!(\n                \"???? Creating associated token account for input token: {}\",\n                user_token_in\n            );\n\n            let token_mint = if swap_params.swap_a_to_b {\n                &pool_info.token_a_mint\n            } else {\n                &pool_info.token_b_mint\n            };\n\n            let create_ata_ix =\n                spl_associated_token_account::instruction::create_associated_token_account(\n                    user_pubkey,      // Payer\n                    user_pubkey,      // Owner of new account\n                    token_mint,       // Token mint\n                    &spl_token::id(), // Token program ID\n                );\n\n            setup_instructions.push(create_ata_ix);\n            info!(\"??? ATA creation instruction added - account will be created in transaction\");\n        }\n\n        if !self.rpc_client.account_exists(&user_token_out)? {\n            info!(\n                \"???? Creating associated token account for output token: {}\",\n                user_token_out\n            );\n\n            let token_mint = if swap_params.swap_a_to_b {\n                &pool_info.token_b_mint\n            } else {\n                &pool_info.token_a_mint\n            };\n\n            let create_ata_ix =\n                spl_associated_token_account::instruction::create_associated_token_account(\n                    user_pubkey,      // Payer\n                    user_pubkey,      // Owner of new account\n                    token_mint,       // Token mint\n                    &spl_token::id(), // Token program ID\n                );\n\n            setup_instructions.push(create_ata_ix);\n            info!(\"??? ATA creation instruction added for output - account will be created in transaction\");\n        }\n\n        // Step 5: Derive tick array addresses (FIXED 2025-10-11)\n        // Orca Whirlpools uses 3 tick arrays to handle price movements during swap\n        // Each tick array covers 88 ticks (TICK_ARRAY_SIZE constant in Whirlpools program)\n        let tick_arrays = Self::derive_tick_arrays(\n            &pool_address,\n            tick_current_index,\n            tick_spacing,\n            &self.program_id,","nrTokens":0,"nrLines":133,"files":[{"filePath":"src/orca.rs","startLine":126,"endLine":258},{"filePath":"clean_arb_bot/src/orca.rs","startLine":116,"endLine":234}]}},{"DuplicationClone":{"cloneLines":"drop(grpc);\n\n                            // Fallback to HTTP\n                            match tokio::time::timeout(\n                                Duration::from_secs(10),\n                                http_clone.submit_bundle_safe(request.transactions.clone())\n                            ).await {\n                                Ok(Ok(uuid)) => {\n                                    info!(\"???? JITO bundle submitted via HTTP (fallback): {}\", uuid);\n                                    Ok(uuid)\n                                }\n                                Ok(Err(e","nrTokens":0,"nrLines":12,"files":[{"filePath":"clean_arb_bot/src/jito_submitter.rs","startLine":166,"endLine":177},{"filePath":"clean_arb_bot/src/jito_submitter.rs","startLine":149,"endLine":160}]}},{"DuplicationClone":{"cloneLines":";\n\n        debug!(\"??? Resolved pool {} to address: {}\", pool_short_id, pool_address);\n\n        // GROK GHOST POOL SOLUTION - STEP 3: Early validation check (should be cached from arbitrage engine)\n        // This is a safety fallback - normally pools are validated before execution\n\n        // MARKET CHAOS MODE - Skip ghost pool validation for speed\n        let skip_ghost_pool_check = std::env::var(\"SKIP_GHOST_POOL_CHECK\")\n            .unwrap_or_else(|_| \"false\".to_string())\n            .to_lowercase() == \"true\";\n\n        if !skip_ghost_pool_check {\n            if self.pool_registry.is_pool_valid_cached(pool_short_id).await != Some(true) {\n                // Rare case: validate on-demand if not cached\n                warn!(\"?????? Pool {} not in cache, validating on-demand\", pool_short_id);\n                self.pool_registry.validate_pools_batch(&[pool_short_id.to_string()]).await?;\n\n                // Double-check after validation\n                if self.pool_registry.is_pool_valid_cached(pool_short_id).await != Some(true) {\n                    return Err(anyhow::anyhow!(\n                        \"?????? Ghost pool detected: {} (failed validation)\",\n                        pool_short_id\n                    ));\n                }\n            }\n        }\n\n        debug!(\"??? Pool validated (cached), proceeding to ownership check\"","nrTokens":0,"nrLines":29,"files":[{"filePath":"clean_arb_bot/src/meteora.rs","startLine":99,"endLine":127},{"filePath":"clean_arb_bot/src/orca.rs","startLine":80,"endLine":108}]}},{"DuplicationClone":{"cloneLines":")\n            }\n\n            DexType::PumpSwap => {\n                // Conservative estimate for PumpSwap (1% slippage)\n                warn!(\"?????? PumpSwap output estimation not yet implemented - using 1% slippage estimate\");\n                Ok(amount_in * 99 / 100)\n            }\n\n            DexType::HumidiFi => {\n                // Conservative estimate for HumidiFi dark pool (0.5% slippage - highly efficient)\n                warn!(\"?????? HumidiFi output estimation not yet implemented - using 0.5% slippage estimate (dark pool efficiency)\");\n                Ok(amount_in * 995 / 1000) // HumidiFi is known for very low slippage\n            }\n\n            // Not yet implemented DEXes - conservative estimate\n            DexType::Jupiter\n            | DexType::Serum\n            | DexType::Aldrin\n            | DexType::Saros\n            | DexType::Crema\n            | DexType::Cropper\n            | DexType::Lifinity\n            | DexType::Fluxbeam => {\n                warn!(\n                    \"?????? DEX {:?} output estimation not implemented - using 1% slippage estimate\",\n                    dex_type\n                );\n                Ok(amount_in * 99 / 100)\n            }\n        }\n    }\n\n    /// Calculate recommended minimum output with slippage tolerance\n    ///\n    /// # Arguments\n    /// * `expected_output` - Expected output amount\n    /// * `slippage_bps` - Slippage tolerance in basis points (100 = 1%)\n    ///\n    /// # Returns\n    /// Minimum output amount accounting for slippage\n    pub fn calculate_min_output_with_slippage(expected_output: u64, slippage_bps: u64)","nrTokens":0,"nrLines":42,"files":[{"filePath":"src/swap_executor.rs","startLine":722,"endLine":763},{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":689,"endLine":723}]}},{"DuplicationClone":{"cloneLines":";\n\n// Include generated protobuf code\npub mod searcher {\n    tonic::include_proto!(\"searcher\");\n}\n\npub mod bundle {\n    tonic::include_proto!(\"bundle\");\n}\n\npub mod packet {\n    tonic::include_proto!(\"packet\");\n}\n\npub mod shared {\n    tonic::include_proto!(\"shared\");\n}\n\nuse searcher::searcher_service_client::SearcherServiceClient;\n\n/// gRPC client for JITO bundle submission\npub struct JitoGrpcClient {\n    client: SearcherServiceClient<Channel>,\n    endpoints: Vec<String>,\n    current_endpoint_idx: usize,\n}\n\nimpl JitoGrpcClient {\n    /// Create new gRPC client with multiple endpoints\n    pub async fn new() -> Result<Self> {\n        // JITO gRPC endpoints with explicit port :443\n        // Note: Authentication no longer required as of Jan 2025\n        let endpoints = vec![\n            \"https://ny.mainnet.block-engine.jito.wtf:443\".to_string(),\n            \"https://amsterdam.mainnet.block-engine.jito.wtf:443\".to_string(),\n            \"https://frankfurt.mainnet.block-engine.jito.wtf:443\".to_string(),\n            \"https://tokyo.mainnet.block-engine.jito.wtf:443\".to_string(),\n        ];\n\n        info!(\"???? Initializing JITO gRPC client (no auth required)\");\n        info!(\"   Primary endpoint: {}\", endpoints[0]);\n\n        // Connect to primary endpoint\n        let channel = Self::connect_to_endpoint(&endpoints[0])\n            .await\n            .map_err(|e| {\n                error!(\"??? gRPC connection failed: {:?}\", e);\n                e\n            })?;\n        let client = SearcherServiceClient::new(channel);\n\n        Ok(Self {\n            client,\n            endpoints,\n            current_endpoint_idx: 0,\n        })\n    }\n\n    /// Connect to a gRPC endpoint with TLS (using system certificate roots)\n    async fn connect_to_endpoint(endpoint: &str) -> Result<Channel> {\n        // With tls-roots feature enabled, ClientTlsConfig::new() automatically\n        // uses system certificate roots to validate the server's certificate\n        let tls_config = ClientTlsConfig::new();\n\n        let channel = Channel::from_shared(endpoint.to_string())?\n            .tls_config(tls_config)?\n            .connect()\n            .await?;\n\n        Ok(channel)\n    }\n\n    /// Rotate to next endpoint on failure\n    async fn rotate_endpoint(&mut self) -> Result<()> {\n        self.current_endpoint_idx = (self.current_endpoint_idx + 1) % self.endpoints.len();\n        let endpoint = &self.endpoints[self.current_endpoint_idx];\n\n        warn!(\"???? Rotating to gRPC endpoint: {}\", endpoint);\n\n        let channel = Self::connect_to_endpoint(endpoint).await?;\n        self.client = SearcherServiceClient::new(channel);\n\n        Ok(())\n    }\n\n    /// Submit bundle via gRPC (FAST!)\n    ///\n    /// # Arguments\n    /// * `transactions` - Transactions with JITO tips ALREADY included\n    ///\n    /// # Returns\n    /// Bundle UUID from JITO\n    pub async fn send_bundle(&mut self, transactions: Vec<Transaction>) -> Result<String> {\n        // Convert Solana transactions to JITO Packets\n        let packets: Vec<packet::Packet> = transactions\n            .iter()\n            .map(|tx| {\n                // Serialize transaction\n                let data = bincode::serialize(tx).expect(\"Failed to serialize transaction\");\n                let data_len = data.len() as u64; // Capture length before move\n\n                packet::Packet {\n                    data,\n                    meta: Some(packet::Meta {\n                        size: data_len,\n                        addr: String::new(),\n                        port: 0,\n                        flags: Some(packet::PacketFlags {\n                            discard: false,\n                            forwarded: false,\n                            repair: false,\n                            simple_vote_tx: false,\n                            tracer_packet: false,\n                            from_staked_node: false,\n                        }),\n                        sender_stake: 0,\n                    }),\n                }\n            })\n            .collect();\n\n        debug!(\"???? Building gRPC bundle with {} packets\", packets.len());\n\n        // Create bundle with header\n        let bundle = bundle::Bundle {\n            header: Some(shared::Header {\n                ts: Some(Self::current_timestamp()),\n            }),\n            packets,\n        };\n\n        // Create request\n        let request = Request::new(searcher::SendBundleRequest {\n            bundle: Some(bundle),\n        });\n\n        debug!(\"???? Sending bundle via gRPC...\");\n\n        // Send with retry on endpoint rotation\n        let response = match self.client.send_bundle(request).await {\n            Ok(resp) => resp,\n            Err(e) => {\n                warn!(\"??? gRPC send failed: {} - Rotating endpoint\", e);\n                self.rotate_endpoint().await?;\n\n                // Retry with new endpoint\n                let retry_request = Request::new(searcher::SendBundleRequest {\n                    bundle: Some(bundle::Bundle {\n                        header: Some(shared::Header {\n                            ts: Some(Self::current_timestamp()),\n                        }),\n                        packets: transactions\n                            .iter()\n                            .map(|tx| {\n                                let data = bincode::serialize(tx).unwrap();\n                                let data_len = data.len() as u64; // Capture length before move\n                                packet::Packet {\n                                    data,\n                                    meta: Some(packet::Meta {\n                                        size: data_len,\n                                        addr: String::new(),\n                                        port: 0,\n                                        flags: Some(packet::PacketFlags {\n                                            discard: false,\n                                            forwarded: false,\n                                            repair: false,\n                                            simple_vote_tx: false,\n                                            tracer_packet: false,\n                                            from_staked_node: false,\n                                        }),\n                                        sender_stake: 0,\n                                    }),\n                                }\n                            })\n                            .collect(),\n                    }),\n                });\n\n                self.client.send_bundle(retry_request).await?\n            }\n        };\n\n        let bundle_uuid = response.into_inner().uuid;\n        debug!(\"??? gRPC bundle submitted: {}\", bundle_uuid);\n\n        Ok(bundle_uuid)\n    }\n\n    /// Get current timestamp for bundle header\n    fn current_timestamp() -> Timestamp {\n        let now = SystemTime::now()\n            .duration_since(SystemTime::UNIX_EPOCH)\n            .expect(\"Time went backwards\");\n\n        Timestamp {\n            seconds: now.as_secs() as i64,\n            nanos: now.subsec_nanos() as i32,\n        }\n    }\n\n    /// Get tip accounts via gRPC\n    pub async fn get_tip_accounts(&mut self) -> Result<Vec<String>> {\n        let request = Request::new(searcher::GetTipAccountsRequest {});\n\n        let response = self.client.get_tip_accounts(request).await?;\n        let accounts = response.into_inner().accounts;\n\n        info!(\"???? Fetched {} tip accounts from JITO\", accounts.len());\n        Ok(accounts)\n    }\n\n    /// Subscribe to bundle results (streaming)\n    pub async fn subscribe_bundle_results(&mut self) -> Result<()> {\n        let request = Request::new(searcher::SubscribeBundleResultsRequest {});\n\n        let mut stream = self\n            .client\n            .subscribe_bundle_results(request)\n            .await?\n            .into_inner();\n\n        info!(\"???? Subscribed to bundle results stream\");\n\n        // This is a streaming endpoint - in production you'd handle this in a separate task\n        while let Some(result) = stream.message().await? {\n            info!(\"???? Bundle result: bundle_id={}\", result.bundle_id);\n\n            // Handle different result types\n            if let Some(result_type) = result.result {\n                use bundle::bundle_result::Result as BundleResultType;\n\n                match result_type {\n                    BundleResultType::Accepted(accepted) => {\n                        info!(\"??? Bundle ACCEPTED at slot {}\", accepted.slot);\n                        info!(\"   Validator: {}\", accepted.validator_identity);\n                    }\n                    BundleResultType::Rejected(rejected) => {\n                        warn!(\"??? Bundle REJECTED: {:?}\", rejected.reason);\n                    }\n                    BundleResultType::Finalized(_) => {\n                        info!(\"???? Bundle FINALIZED on-chain!\");\n                    }\n                    BundleResultType::Processed(processed) => {\n                        info!(\"??? Bundle PROCESSED at slot {}\", processed.slot);\n                        info!(\"   Bundle index: {}\", processed.bundle_index);\n                    }\n                    BundleResultType::Dropped(dropped) => {\n                        warn!(\"?????? Bundle DROPPED: {:?}\", dropped.reason);\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_grpc_client_creation() {\n        // This will fail if gRPC endpoint is down, but tests the client creation\n        let result = JitoGrpcClient::new().await;\n        assert!(result.is_ok() || result.is_err()); // Either works for CI\n    }\n}","nrTokens":0,"nrLines":269,"files":[{"filePath":"src/jito_grpc_client.rs","startLine":14,"endLine":282},{"filePath":"clean_arb_bot/src/jito_grpc_client.rs","startLine":14,"endLine":277}]}},{"DuplicationClone":{"cloneLines":"// Orca variants\n            DexType::OrcaWhirlpools | DexType::OrcaLegacy => {\n                // Conservative estimate for Orca (1% slippage)\n                warn!(\"?????? Orca output estimation not yet implemented - using 1% slippage estimate\");\n                Ok(amount_in * 99 / 100)\n            }\n\n            // Raydium variants (all use same builder)\n            DexType::RaydiumAmmV4\n            | DexType::RaydiumClmm\n            | DexType::RaydiumCpmm\n            | DexType::RaydiumStable => {\n                self.raydium_builder\n                    .estimate_swap_output(pool_short_id, amount_in, swap_a_to_b)","nrTokens":0,"nrLines":14,"files":[{"filePath":"src/swap_executor.rs","startLine":709,"endLine":722},{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":676,"endLine":688}]}},{"DuplicationClone":{"cloneLines":") -> Result<Self> {\n        let program_id = Self::PROGRAM_ID\n            .parse()\n            .context(\"Failed to parse Meteora program ID\")?;\n\n        info!(\"??? Meteora swap builder initialized (DLMM + DAMM V1 + DAMM V2)\");\n        info!(\"   DLMM Program ID: {}\", program_id);\n        info!(\"   DAMM V1 Program ID: {}\", Self::DAMM_V1_PROGRAM_ID);\n        info!(\"   DAMM V2 Program ID: {}\", Self::DAMM_V2_PROGRAM_ID);\n\n        Ok(Self {\n            rpc_client,\n            pool_registry,\n            program_id,\n        })\n    }\n\n    /// Build swap instruction for Meteora DLMM pool\n    ///\n    /// # Arguments\n    /// * `pool_short_id` - 8-char short pool ID from ShredStream\n    /// * `swap_params` - Swap parameters (amount_in, minimum_amount_out, direction)\n    /// * `user_pubkey` - User's wallet public key\n    ///\n    /// # Returns\n    /// Solana instruction for the swap\n    pub async fn build_swap_instruction(\n        &self,\n        pool_short_id: &str,\n        swap_params: &SwapParams,\n        user_pubkey: &Pubkey,\n    ) -> Result<Instruction> {\n        debug!(\n            \"Building Meteora swap instruction for pool: {}\",\n            pool_short_id\n        );\n\n        // Step 1: Resolve pool address from short ID using 4-layer hybrid resolution\n        // Try DLMM first (most common), then V1, then V2 (all variants may exist)\n        let pool_address = match self\n            .pool_registry\n            .resolve_pool_address(pool_short_id, &crate::types::DexType::MeteoraDlmm)\n            .await\n        {\n            Ok(addr) => addr,\n            Err(_) => {\n                // Try V1 if DLMM fails\n                match self\n                    .pool_registry\n                    .resolve_pool_address(pool_short_id, &crate::types::DexType::MeteoraDammV1)\n                    .await\n                {\n                    Ok(addr) => addr,\n                    Err(_) => {\n                        // Try V2 if V1 also fails\n                        self.pool_registry\n                            .resolve_pool_address(\n                                pool_short_id,\n                                &crate::types::DexType::MeteoraDammV2,","nrTokens":0,"nrLines":59,"files":[{"filePath":"src/meteora.rs","startLine":36,"endLine":94},{"filePath":"clean_arb_bot/src/meteora.rs","startLine":42,"endLine":93}]}},{"DuplicationClone":{"cloneLines":", instruction.accounts.len());\n        debug!(\"Instruction data length: {} bytes\", instruction.data.len());\n\n        Ok(instruction)\n    }\n\n    /// Estimate output amount for a swap (useful for slippage calculation)\n    pub fn estimate_swap_output(\n        &self,\n        pool_short_id: &str,\n        amount_in: u64,\n        _swap_a_to_b: bool,\n    ) -> Result<u64> {\n        debug!(\"Estimating swap output for Orca pool: {}\"","nrTokens":0,"nrLines":14,"files":[{"filePath":"clean_arb_bot/src/orca.rs","startLine":465,"endLine":478},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":418,"endLine":431}]}},{"DuplicationClone":{"cloneLines":") -> u64 {\n        // Calculate: expected * (10000 - slippage_bps) / 10000\n        expected_output\n            .saturating_mul(10000 - slippage_bps)\n            .saturating_div(10000)\n    }\n\n    /// Confirm transaction on-chain\n    async fn confirm_transaction(&self, signature: &Signature) -> Result<bool> {\n        // Poll for confirmation status\n        for _ in 0..30 {\n            match self.rpc_client.get_transaction_status(signature) {\n                Ok(Some(status)) => {\n                    return Ok(status);\n                }\n                Ok(None) => {\n                    // Not yet confirmed, wait and retry\n                    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;\n                }\n                Err(e) => {\n                    warn!(\"Error checking transaction status: {}\", e);\n                    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;\n                }\n            }\n        }\n        Ok(false) // Not confirmed after 30 attempts\n    }\n\n    /// Health check - verify all components are working\n    pub fn health_check(&self) -> Result<bool> {\n        debug!(\"Running swap executor health check...\");\n\n        // Check RPC connection\n        if !self.rpc_client.health_check()? {\n            warn!(\"??? RPC health check failed\");\n            return Ok(false);\n        }\n\n        // Check pool registry has pools\n        let pool_count = self.pool_registry.pool_count();\n        if pool_count == 0 {\n            warn!(\"?????? Pool registry is empty - run populate_*_pools() first\");\n        } else {\n            debug!(\"??? Pool registry has {} pools\", pool_count);\n        }\n\n        // Check JITO client if enabled\n        if let Some(ref _jito) = self.jito_client {\n            debug!(\"??? JITO client enabled\");\n        }\n\n        info!(\"??? Swap executor health check passed\");\n        Ok(true)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_min_output_calculation() {\n        // 1% slippage (100 bps)\n        assert_eq!(\n            SwapExecutor::calculate_min_output_with_slippage(1000, 100),\n            990\n        );\n\n        // 0.5% slippage (50 bps)\n        assert_eq!(\n            SwapExecutor::calculate_min_output_with_slippage(1000, 50),\n            995\n        );\n\n        // 5% slippage (500 bps)\n        assert_eq!(\n            SwapExecutor::calculate_min_output_with_slippage(1000, 500),\n            950\n        );\n\n        // 0% slippage\n        assert_eq!(\n            SwapExecutor::calculate_min_output_with_slippage(1000, 0),\n            1000\n        );\n    }\n\n    #[test]\n    fn test_swap_executor_creation() {\n        let rpc_url = \"https://api.mainnet-beta.solana.com\".to_string();\n        let rpc_client = Arc::new(SolanaRpcClient::new(rpc_url));\n        let pool_registry = Arc::new(PoolRegistry::new(rpc_client.clone()));\n\n        let executor = SwapExecutor::new(rpc_client, pool_registry, None)","nrTokens":0,"nrLines":94,"files":[{"filePath":"src/swap_executor.rs","startLine":763,"endLine":856},{"filePath":"clean_arb_bot/src/swap_executor.rs","startLine":724,"endLine":820}]}},{"DuplicationClone":{"cloneLines":"// Cost calculator for arbitrage profitability\n//\n// Calculates total cost of executing arbitrage including:\n// - JITO tip (DYNAMIC - percentile based on profit size)\n// - Transaction fees (compute budget + priority fees)\n// - Slippage buffer (safety margin)\n//\n// ## Dynamic Percentile JITO Tip Strategy (2025-10-11)\n//\n// Uses different percentiles based on arbitrage profit size:\n// - Small arbs (<0.01 SOL): 95th percentile (better profitability)\n//   - Trade-off: 95% bundle landing vs 99%, but arbs become executable\n//   - Allows small opportunities (0.001-0.01 SOL) to be profitable\n// - Medium arbs (0.01-0.05 SOL): Interpolated between 95th and 99th\n//   - Smooth transition as profit size increases\n// - Large arbs (???0.05 SOL): 99th percentile (best execution)\n//   - Worth paying higher tip for competitive advantage\n// - Minimum: 10% of profit or percentile floor (whichever higher)\n// - Hard cap: 0.005 SOL maximum (market spike protection)\n// - Updates every 10 minutes via background monitor\n//\n// ## Industry Guidance: 60/40 Gas/Tip Split\n//\n// Jito documentation recommends a 60% gas / 40% tip allocation of total fees:\n// - Gas fees: ~60% of total (network, compute, priority)\n// - JITO tip: ~40% of total (MEV protection payment)\n//\n// For small arbitrages, this ratio may differ due to:\n// - Fixed gas costs (5,400 lamports minimum)\n// - Competitive minimum tip (100,000 lamports = 95th percentile)\n// - Result: Smaller arbs have tip-heavy ratio (e.g., 95% tip / 5% gas)\n//\n// For larger arbitrages with 10% profit-based tips, the ratio approaches 40-50% tip\n// as the profit (and thus tip) scales up relative to fixed gas costs.\n\nuse crate::jito_tip_monitor::JitoTipFloor;\nuse tracing::debug;\n\n/// Complete cost breakdown for arbitrage execution\n#[derive(Debug, Clone)]\npub struct ArbitrageCosts {\n    /// DEX swap fees (typically 0.25% per swap ?? 3 swaps = 0.75% total for triangle arb)\n    pub dex_fee_lamports: u64,\n\n    /// JITO tip amount (based on expected profit)\n    pub jito_tip_lamports: u64,\n\n    /// Base transaction fee (5000 lamports typical)\n    pub base_tx_fee_lamports: u64,\n\n    /// Compute budget fee (varies by compute units)\n    pub compute_fee_lamports: u64,\n\n    /// Priority fee (if using priority fees instead of JITO)\n    pub priority_fee_lamports: u64,\n\n    /// Total cost (sum of all above)\n    pub total_cost_lamports: u64,\n}\n\nimpl ArbitrageCosts {\n    /// Calculate total costs for triangle arbitrage with DYNAMIC JITO tips\n    ///\n    /// # Arguments\n    /// * `position_size_lamports` - Size of the position being traded (for DEX fee calculation)\n    /// * `expected_profit_lamports` - Expected gross profit from arbitrage\n    /// * `use_jito` - Whether using JITO bundles (true) or regular transactions (false)\n    /// * `tip_floor` - Optional JITO tip floor data (if None, uses conservative defaults)\n    ///\n    /// # Strategy (NEW - Dynamic Tipping):\n    /// - Normal profits: Beat JITO 95th percentile by 10%\n    /// - Large profits (>0.5 SOL): Beat JITO 99th percentile by 10%\n    /// - Minimum tip: 100,000 lamports (JITO competitive baseline)\n    /// - Updates every 30 minutes via background monitor\n    ///\n    /// # Returns\n    /// Complete cost breakdown\n    pub fn calculate(\n        position_size_lamports: u64,\n        expected_profit_lamports: u64,\n        use_jito: bool,\n        tip_floor: Option<&JitoTipFloor>,\n    ) -> Self {\n        // DEX swap fees calculation\n        // Triangle arbitrage = 3 swaps\n        // Typical fee: 0.25% per swap (Raydium/Orca standard)\n        // Total DEX fees: 0.75% of position size (NOT profit)\n        // FIXED: Calculate based on actual position size\n        let dex_fee_lamports = (position_size_lamports as f64 * 0.0075) as u64; // 0.75% of position\n\n        // JITO tip calculation with DYNAMIC market-based tipping\n        // UPDATED (2025-10-07): Dynamic tips based on JITO tip floor API\n        // For sendBundle: Only tip matters (no 70/30 split with priority fee)\n        let jito_tip_lamports = if use_jito {\n            let profit_sol = expected_profit_lamports as f64 / 1_000_000_000.0;\n\n            // AGGRESSIVE TIPPING STRATEGY: Always use 99th percentile + profit-based scaling\n            // Base: 99th percentile (beats 99% of bundles)\n            // Scale: Up to 3x based on profit margin (more margin = more aggressive)\n            // Cap: Hard limit at 0.003 SOL\n\n            let base_tip_99 = if let Some(floor) = tip_floor {\n                floor.competitive_tip_99()\n            } else {\n                10_000_000_u64 // Fallback: 10M lamports (conservative 99th)\n            };\n\n            // Estimate total fees with base 99th percentile tip to calculate margin\n            let estimated_dex_fees = (expected_profit_lamports as f64 * 0.0075) as u64;\n            let estimated_gas = (base_tip_99 as f64 * 1.5) as u64; // Gas is 1.5x tip\n            let total_fees_base = estimated_dex_fees + estimated_gas + base_tip_99;\n            let fee_percentage = (total_fees_base as f64 / expected_profit_lamports as f64) * 100.0;\n\n            // AGGRESSIVE 99TH PERCENTILE TIPPING (2025-10-11)\n            // ALWAYS use 99th percentile - we want to CATCH opportunities, not miss them\n            // User requirement: \"we should be targeting 99% and I want .9 sol we need to be getting these not cutting cost and missing\"\n            // Trade-off: Higher tips but better execution rate (99% bundle landing)\n\n            let base_tip_99 = if let Some(floor) = tip_floor {\n                floor.competitive_tip_99()\n            } else {\n                10_000_000_u64 // Fallback: 10M lamports for 99th\n            };\n\n            // ALWAYS USE 99TH PERCENTILE - no interpolation, no cost cutting\n            let percentile_tip = base_tip_99;\n\n            // Still apply 10% minimum from profit for very small arbs\n            let min_tip_percentage = 0.10; // 10% minimum\n            let base_tip_from_profit =\n                (expected_profit_lamports as f64 * min_tip_percentage) as u64;\n\n            // Use the HIGHER of profit-based or dynamic percentile\n            let base_tip = base_tip_from_profit.max(percentile_tip);\n\n            // For very high margin trades, scale up to 15%\n            let base_tip = if fee_percentage < 5.0 {\n                // Ultra high margin: Scale up to 15% of profit\n                let target_tip = (expected_profit_lamports as f64 * 0.15) as u64;\n                base_tip.max(target_tip)\n            } else {\n                base_tip\n            };\n\n            // Minimum: 10% of profit or 100k lamports, whichever is higher\n            let min_tip = base_tip_from_profit.max(100_000_u64);\n\n            // Maximum: Cap at 17% of total estimated profit (user requirement)\n            // This prevents over-paying even on 99th percentile for very profitable trades\n            let max_tip_profit_cap = (expected_profit_lamports as f64 * 0.17) as u64; // 17% of profit\n\n            // Also cap at 30% of net profit (after fees) for safety\n            let net_profit_estimate = expected_profit_lamports\n                .saturating_sub(estimated_dex_fees)\n                .saturating_sub(estimated_gas);\n            let max_tip_net_cap = net_profit_estimate * 30 / 100; // 30% of net profit\n\n            // Absolute cap: 0.005 SOL (user requirement)\n            let absolute_max_tip = 5_000_000_u64; // 0.005 SOL\n\n            // Use the most restrictive cap\n            let max_tip = max_tip_profit_cap\n                .min(max_tip_net_cap)\n                .min(absolute_max_tip);\n\n            // Calculate tip with caps, BUT ensure dynamic percentile is ALWAYS the floor\n            // This ensures competitive bundle landing appropriate for profit size\n            // Use saturating operations to prevent overflow\n            let capped_tip = base_tip.max(min_tip).min(max_tip);\n\n            // CRITICAL: Dynamic percentile is ABSOLUTE MINIMUM (never go below it)\n            // Small arbs use 95th floor, large arbs use 99th floor\n            // This makes small arbs profitable while maintaining competitive execution\n            let final_tip = capped_tip.max(percentile_tip);\n\n            // PRODUCTION LOGGING: Track tip calculation (ALWAYS 99th percentile)\n            let tip_percentage = (final_tip as f64 / expected_profit_lamports as f64) * 100.0;\n            let was_capped = final_tip == absolute_max_tip; // Check if 0.005 SOL cap was applied\n            let at_percentile_floor = final_tip == percentile_tip && capped_tip < percentile_tip;\n\n            debug!(\"???? Aggressive tip (99TH): Profit {:.6} SOL | Fee margin: {:.1}% ??? Tip {:.6} SOL ({:.2}% of profit){}{}\",\n                   profit_sol, fee_percentage, final_tip as f64 / 1e9, tip_percentage,\n                   if was_capped { \" [CAPPED]\" } else { \"\" },\n                   if at_percentile_floor { \" [FLOOR]\" } else { \"\" });\n\n            final_tip\n        } else {\n            0\n        };\n\n        // Base transaction fee - Target ~1.5x JITO tip for realistic gas costs\n        // Industry standard: Gas fees should be 50-150% of JITO tip\n        // JITO tip is 3-7% of profit, capped at 0.001 SOL\n        // So gas should be ~1.5x the tip amount\n        let profit_sol = expected_profit_lamports as f64 / 1_000_000_000.0;\n\n        // Calculate target gas as 1.5x JITO tip, with minimum floor for 3-swap arbitrage","nrTokens":0,"nrLines":197,"files":[{"filePath":"src/cost_calculator.rs","startLine":1,"endLine":197},{"filePath":"clean_arb_bot/src/cost_calculator.rs","startLine":1,"endLine":194}]}},{"DuplicationClone":{"cloneLines":"let mut token_prices: HashMap<String, Vec<&TokenPrice>> = HashMap::new();\n        for price in prices.values() {\n            token_prices\n                .entry(price.token_mint.clone())\n                .or_insert_with(Vec::new)\n                .push(price);\n        }\n\n        // Filter out spam/dead tokens with too many pools","nrTokens":0,"nrLines":9,"files":[{"filePath":"clean_arb_bot/src/simple_triangle_detector.rs","startLine":48,"endLine":56},{"filePath":"clean_arb_bot/src/triangle_arbitrage.rs","startLine":123,"endLine":131}]}},{"DuplicationClone":{"cloneLines":"DexType::HumidiFi => \"9H6tuB8C3VnXcBLKFJGPqpFu1F2Bwsa7eJvbw8Tq6Rp\".parse::<Pubkey>()?,\n        };\n\n        // Query all program accounts (VERY SLOW - avoid if possible)\n        warn!(\"?????? Using slow getProgramAccounts - this will take 200-400ms!\");\n\n        // TODO: Implement getProgramAccounts with prefix filter\n        // This requires solana-client dependency which we may not have\n        // For now, return error to force using other layers\n\n        Err(anyhow::anyhow!(\n            \"On-chain lookup not yet implemented. Add solana-client dependency and implement getProgramAccounts with prefix filter.\"\n        ))\n    }\n\n    /// Get resolution performance statistics\n    pub fn get_resolution_stats(&self) -> (u64, u64, u64, u64, u64, f64) {\n        let stats = self.resolution_stats.read().unwrap();\n        let avg_latency = if stats.total_lookups > 0 {\n            stats.total_latency_ms as f64 / stats.total_lookups as f64\n        } else {\n            0.0\n        };\n\n        (\n            stats.layer1_hits,\n            stats.layer2_hits,\n            stats.layer3_hits,\n            stats.layer4_hits,\n            stats.total_lookups,\n            avg_latency,\n        )\n    }\n\n    /// Pre-populate registry with known Meteora pools\n    /// This is a temporary solution - should be replaced with dynamic lookup\n    pub fn populate_meteora_pools(&self) -> Result<()> {\n        info!(\"???? Pre-populating Meteora DLMM pools...\");\n\n        // TODO: Add known Meteora pool addresses here\n        // These can be fetched from Meteora API or on-chain queries\n        // Example:\n        // self.register_pool(\n        //     \"81vA2wJx\".to_string(),\n        //     PoolInfo {\n        //         full_address: \"81vA2wJx...full_address\".parse()?,\n        //         dex_type: DexType::MeteoraDammV2,\n        //         token_a_mint: \"...\".parse()?,\n        //         token_b_mint: \"...\".parse()?,\n        //         reserve_a: \"...\".parse()?,\n        //         reserve_b: \"...\".parse()?,\n        //     }\n        // )?;\n\n        warn!(\"?????? Meteora pool pre-population not yet implemented\");\n        warn!(\"   Need to fetch pool addresses from Meteora API or ShredStream service\");\n\n        Ok(())\n    }\n\n    /// Pre-populate registry with known Orca pools\n    pub fn populate_orca_pools(&self) -> Result<()> {\n        info!(\"???? Pre-populating Orca Whirlpool pools...\");\n\n        // TODO: Add known Orca pool addresses\n        warn!(\"?????? Orca pool pre-population not yet implemented\");\n\n        Ok(())\n    }\n\n    /// Clear all registered pools\n    pub fn clear(&self) {\n        let mut pools = self.pools.write().unwrap();\n        let mut addr_map = self.address_to_id.write().unwrap();\n\n        pools.clear();\n        addr_map.clear();\n\n        info!(\"??????? Pool registry cleared\");\n    }\n\n    // ========================================\n    // GROK'S GHOST POOL SOLUTION - Pool Validation Methods\n    // ========================================\n\n    /// Check if pool is cached and valid (with TTL check)\n    /// Returns Some(true) if valid, Some(false) if invalid, None if not cached/stale\n    pub async fn is_pool_valid_cached(&self, pool_short_id: &str) -> Option<bool> {\n        let cache = self.validation_cache.read().await;\n\n        if let Some((is_valid, checked_at)) = cache.get(pool_short_id) {\n            // Check if cache entry is still fresh (within TTL)\n            if checked_at.elapsed() < Duration::from_secs(VALIDATION_TTL_SECS) {\n                return Some(*is_valid);\n            }\n        }\n\n        None // Not cached or stale\n    }\n\n    /// Validate a batch of pools via RPC and update cache\n    /// Uses getMultipleAccounts for efficiency (up to 100 pools per call)\n    pub async fn validate_pools_batch(&self, pool_short_ids: &[String]) -> Result<()> {\n        if pool_short_ids.is_empty() {\n            return Ok(());\n        }\n\n        debug!(\"???? Validating batch of {} pools\", pool_short_ids.len());\n\n        // Resolve short IDs to full addresses\n        let mut addresses = Vec::new();\n        let mut valid_ids = Vec::new();\n\n        for short_id in pool_short_ids {\n            // Try to resolve using any DEX type (we just need the address)\n            match self\n                .resolve_pool_address(short_id, &DexType::OrcaWhirlpools)\n                .await\n            {\n                Ok(addr) => {\n                    addresses.push(addr);\n                    valid_ids.push(short_id.clone());\n                }\n                Err(_) => {\n                    // Can't resolve - mark as invalid\n                    let mut cache = self.validation_cache.write().await;\n                    cache.insert(short_id.clone(), (false, Instant::now()));\n                    debug!(\n                        \"?????? Pool {} could not be resolved - marked invalid\",\n                        short_id\n                    );\n                }\n            }\n        }\n\n        if addresses.is_empty() {\n            return Ok(());\n        }\n\n        // Fetch accounts via RPC (TODO: use get_multiple_accounts for batch)\n        // For now, validate individually (will optimize with batch RPC later)\n        let mut cache = self.validation_cache.write().await;\n\n        for (i, addr) in addresses.iter().enumerate() {\n            let short_id = &valid_ids[i];\n\n            // Check if account exists and has minimum size\n            let is_valid = match self.rpc_client.get_account_data(addr) {\n                Ok(data) => {\n                    let valid = !data.is_empty() && data.len() >= MIN_POOL_SIZE;\n                    if !valid {\n                        debug!(\n                            \"?????? Pool {} exists but too small ({} bytes < {} min)\",\n                            short_id,\n                            data.len(),\n                            MIN_POOL_SIZE\n                        );\n                    }\n                    valid\n                }\n                Err(_) => {\n                    debug!(\"?????? Pool {} RPC check failed - marking invalid\", short_id);\n                    false\n                }\n            };\n\n            cache.insert(short_id.clone(), (is_valid, Instant::now()));\n\n            if is_valid {\n                debug!(\"??? Pool {} validated (size: {} bytes)\", short_id, \"OK\");\n            } else {\n                debug!(\"??? Pool {} marked as ghost pool\", short_id);\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Start background task to periodically validate top pools\n    /// Runs async without blocking main flow\n    pub fn start_background_validation(self: Arc<Self>, top_pools: Vec<String>) {\n        tokio::spawn(async move {\n            info!(\n                \"???? Starting background pool validation (every {} seconds)\",\n                BACKGROUND_INTERVAL_SECS\n            );\n            info!(\"   Validating top {} pools by volume\", top_pools.len());\n\n            loop {\n                tokio::time::sleep(Duration::from_secs(BACKGROUND_INTERVAL_SECS)).await;\n\n                if let Err(e) = self.validate_pools_batch(&top_pools).await {\n                    warn!(\"?????? Background validation error: {:?}\", e);\n                } else {\n                    debug!(\n                        \"??? Background validation cycle complete ({} pools)\",\n                        top_pools.len()\n                    );\n                }\n            }\n        });\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_pool_registry_creation() {\n        let rpc_url = \"https://api.mainnet-beta.solana.com\".to_string();\n        let rpc_client = Arc::new(SolanaRpcClient::new(rpc_url));\n        let registry = PoolRegistry::new(rpc_client);\n\n        assert_eq!(registry.pool_count(), 0);\n    }\n\n    #[test]\n    fn test_pool_registration() {\n        let rpc_url = \"https://api.mainnet-beta.solana.com\".to_string();\n        let rpc_client = Arc::new(SolanaRpcClient::new(rpc_url));\n        let registry = PoolRegistry::new(rpc_client);\n\n        // Create a test pool\n        let pool_address: Pubkey = \"81vA2wJxKyUE8RHKXxT5VfEQnJGYvJ9FTBwJQhRZHvqX\"\n            .parse()\n            .unwrap();\n        let pool_info = PoolInfo {\n            full_address: pool_address,\n            dex_type: DexType::MeteoraDammV2,\n            token_a_mint: Pubkey::default(),\n            token_b_mint: Pubkey::default(),\n            reserve_a: Pubkey::default(),\n            reserve_b: Pubkey::default(),\n        };\n\n        // Register pool\n        registry\n            .register_pool(\"81vA2wJx\".to_string(), pool_info)\n            .unwrap();\n\n        // Verify registration\n        assert_eq!(registry.pool_count(), 1);\n        assert!(registry.has_pool(\"81vA2wJx\"));\n\n        // Verify lookup\n        let found = registry.get_pool(\"81vA2wJx\").unwrap();\n        assert_eq!(found.full_address, pool_address);\n\n        // Verify reverse lookup\n        let short_id = registry.get_short_id(&pool_address).unwrap();\n        assert_eq!(short_id, \"81vA2wJx\");\n    }\n}","nrTokens":0,"nrLines":254,"files":[{"filePath":"src/pool_registry.rs","startLine":436,"endLine":689},{"filePath":"clean_arb_bot/src/pool_registry.rs","startLine":385,"endLine":618}]}},{"DuplicationClone":{"cloneLines":"fn create_tip_transaction_legacy(\n        &self,\n        tip_lamports: u64,\n        tip_account: Pubkey,\n    ) -> Result<Transaction> {\n        let auth_keypair = self\n            .auth_keypair\n            .as_ref()\n            .ok_or_else(|| anyhow::anyhow!(\"Auth keypair required for tip transactions\"))?;\n\n        let tip_instruction =\n            system_instruction::transfer(&auth_keypair.pubkey(), &tip_account, tip_lamports)","nrTokens":0,"nrLines":12,"files":[{"filePath":"src/jito_bundle_client.rs","startLine":502,"endLine":513},{"filePath":"clean_arb_bot/src/jito_bundle_client.rs","startLine":468,"endLine":480}]}},{"DuplicationClone":{"cloneLines":"// Get pool info for token mints and reserves\n        let pool_info = self.pool_registry.get_pool(pool_short_id).ok_or_else(|| {\n            anyhow::anyhow!(\n                \"Pool {} resolved but info not cached. This shouldn't happen.\",\n                pool_short_id\n            )\n        })?;\n\n        // Step 2: Fetch pool state from blockchain\n        let pool_state = self\n            .fetch_pool_state(&pool_address)\n            .context(\"Failed to fetch pool state\")?;\n\n        debug!(\"??? Got pool state ({} bytes)\", pool_state.len());\n\n        // Step 3: Determine token accounts","nrTokens":0,"nrLines":16,"files":[{"filePath":"src/meteora.rs","startLine":183,"endLine":198},{"filePath":"src/orca.rs","startLine":120,"endLine":169}]}},{"DuplicationClone":{"cloneLines":")?;\n\n    // 4. SOL-USDC (High Liquidity #4)\n    pool_registry.register_pool(\n        \"HTvjzsf\".to_string(),\n        PoolInfo {\n            full_address: \"HTvjzsfX3yU6BUodCjZ5vZkUrAxMDTrBs3CJaq43ashR\".parse()?,\n            dex_type: DexType::MeteoraDammV2,\n            token_a_mint: \"So11111111111111111111111111111111111111112\".parse()?, // SOL\n            token_b_mint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".parse()?, // USDC\n            reserve_a: \"H7j5NPopj3tQvDg4N8CxwtYciTn3e8AEV6wSVrxpyDUc\".parse()?,\n            reserve_b: \"HbYjRzx7teCxqW3unpXBEcNHhfVZvW2vW9MQ99TkizWt\".parse()?,\n        },","nrTokens":0,"nrLines":13,"files":[{"filePath":"src/pool_population.rs","startLine":67,"endLine":79},{"filePath":"clean_arb_bot/src/pool_population.rs","startLine":67,"endLine":80}]}},{"DuplicationClone":{"cloneLines":");\n\n        // NEW: Event authority constant from Meteora\n        let event_authority: Pubkey = \"6XzaKuAwqP7Nn37vwRdUqpuzNXknkBqjWq3c3h8qQXhE\"\n            .parse()\n            .expect(\"Valid event authority pubkey\");\n\n        let accounts = vec![\n            solana_sdk::instruction::AccountMeta::new(*pool, false), // 0. lb_pair\n            // Note: bin_array_bitmap_extension is optional, using None (skipping)\n            solana_sdk::instruction::AccountMeta::new(*reserve_x, false), // 1. reserve_x\n            solana_sdk::instruction::AccountMeta::new(*reserve_y, false), // 2. reserve_y\n            solana_sdk::instruction::AccountMeta::new(*user_token_in, false), // 3. user_token_in\n            solana_sdk::instruction::AccountMeta::new(*user_token_out, false), // 4. user_token_out\n            solana_sdk::instruction::AccountMeta::new_readonly(*token_mint_a, false), // 5. token_x_mint\n            solana_sdk::instruction::AccountMeta::new_readonly(*token_mint_b, false), // 6. token_y_mint\n            solana_sdk::instruction::AccountMeta::new(oracle, false),                 // 7. oracle\n            // Note: host_fee_in is optional, using None (skipping)\n            solana_sdk::instruction::AccountMeta::new_readonly(*user, true), // 8. user (signer)\n            solana_sdk::instruction::AccountMeta::new_readonly(spl_token::id(), false), // 9. token_x_program\n            solana_sdk::instruction::AccountMeta::new_readonly(spl_token::id(), false), // 10. token_y_program\n            solana_sdk::instruction::AccountMeta::new_readonly(event_authority, false), // 11. event_authority (CRITICAL!)\n            solana_sdk::instruction::AccountMeta::new_readonly(self.program_id, false), // 12. program (CRITICAL!)\n        ];\n\n        // Instruction data format for Meteora DLMM swap\n        // [discriminator: 8 bytes][amount_in: 8 bytes][min_amount_out: 8 bytes]\n        let mut data = Vec::new();\n\n        // METEORA DLMM SWAP DISCRIMINATOR (FIXED 2025-10-11)\n        // Correct Anchor discriminator for \"global:swap\" = SHA256(\"global:swap\")[0..8]\n        // Verified calculation: echo -n \"global:swap\" | sha256sum = f8c69e91e17587c8...\n        let swap_discriminator: [u8; 8] = [0xf8, 0xc6, 0x9e, 0x91, 0xe1, 0x75, 0x87, 0xc8];\n        data.extend_from_slice(&swap_discriminator);\n\n        // Amount in (u64, 8 bytes, little-endian)\n        data.extend_from_slice(&swap_params.amount_in.to_le_bytes());\n\n        // Minimum amount out (u64, 8 bytes, little-endian)\n        data.extend_from_slice(&swap_params.minimum_amount_out.to_le_bytes());\n\n        let instruction = Instruction {\n            program_id: self.program_id,\n            accounts,\n            data,\n        };\n\n        debug!(\n            \"Built Meteora instruction with {} accounts\",\n            instruction.accounts.len()\n        );\n\n        Ok(instruction)\n    }\n\n    /// Estimate output amount for a swap (useful for slippage calculation)\n    ///\n    /// This queries the pool state and calculates expected output\n    pub fn estimate_swap_output(\n        &self,\n        pool_short_id: &str,\n        amount_in: u64,\n        _swap_a_to_b: bool,\n    ) -> Result<u64> {\n        debug!(\"Estimating swap output for pool: {}\", pool_short_id);\n\n        // Get pool info\n        let pool_info = self\n            .pool_registry\n            .get_pool(pool_short_id)\n            .ok_or_else(|| anyhow::anyhow!(\"Pool {} not found\", pool_short_id))?;\n\n        // Fetch pool state (reserved for future precise estimation)\n        let _pool_state = self.fetch_pool_state(&pool_info.full_address)?;\n\n        // Parse pool state to get current bin/tick information\n        // This would use lb_clmm SDK's state parsing functions\n\n        // For now, return a conservative estimate\n        // In production, this should use the actual DLMM curve calculation\n        let estimated_output = amount_in * 99 / 100; // Assume 1% slippage\n\n        warn!(\"?????? Using conservative estimate (1% slippage)\");\n        warn!(\"   Production should use lb_clmm SDK's quote calculation\");\n\n        Ok(estimated_output)\n    }\n\n    /// Calculate slippage percentage\n    pub fn calculate_slippage(expected: u64, minimum: u64) -> f64 {\n        if expected == 0 {\n            return 0.0;\n        }\n        let difference = expected.saturating_sub(minimum) as f64;\n        (difference / expected as f64) * 100.0\n    }\n\n    /// Validate swap parameters\n    pub fn validate_swap_params(&self, params: &SwapParams) -> Result<()> {\n        if params.amount_in == 0 {\n            return Err(anyhow::anyhow!(\"Amount in cannot be zero\"));\n        }\n\n        if params.minimum_amount_out == 0 {\n            return Err(anyhow::anyhow!(\"Minimum amount out cannot be zero\"));\n        }\n\n        if params.minimum_amount_out > params.amount_in * 10 {\n            return Err(anyhow::anyhow!(\n                \"Minimum amount out suspiciously high ({}x input). Check parameters.\",\n                params.minimum_amount_out / params.amount_in\n            ));\n        }\n\n        let slippage = Self::calculate_slippage(params.amount_in, params.minimum_amount_out);\n        if slippage > 50.0 {\n            warn!(\"?????? High slippage tolerance: {:.2}%\", slippage);\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_slippage_calculation() {\n        assert_eq!(MeteoraSwapBuilder::calculate_slippage(100, 95), 5.0);\n        assert_eq!(MeteoraSwapBuilder::calculate_slippage(1000, 950), 5.0);\n        assert_eq!(MeteoraSwapBuilder::calculate_slippage(100, 100), 0.0);\n    }\n\n    #[test]\n    fn test_swap_params_validation() {\n        let rpc_url = \"https://api.mainnet-beta.solana.com\".to_string();\n        let rpc_client = Arc::new(SolanaRpcClient::new(rpc_url));\n        let pool_registry = Arc::new(PoolRegistry::new(rpc_client.clone()));\n        let builder = MeteoraSwapBuilder::new(rpc_client, pool_registry).unwrap();\n\n        // Valid params\n        let valid = SwapParams {\n            amount_in: 100,\n            minimum_amount_out: 95,\n            expected_amount_out: Some(100),\n            swap_a_to_b: true,\n        };\n        assert!(builder.validate_swap_params(&valid).is_ok());\n\n        // Zero amount in\n        let zero_in = SwapParams {\n            amount_in: 0,\n            minimum_amount_out: 95,\n            expected_amount_out: Some(95),\n            swap_a_to_b: true,\n        };\n        assert!(builder.validate_swap_params(&zero_in).is_err());\n\n        // Zero minimum out\n        let zero_out = SwapParams {\n            amount_in: 100,\n            minimum_amount_out: 0,\n            expected_amount_out: Some(100),\n            swap_a_to_b: true,\n        };\n        assert!(builder.validate_swap_params(&zero_out).is_err());\n    }\n}","nrTokens":0,"nrLines":169,"files":[{"filePath":"src/meteora.rs","startLine":417,"endLine":585},{"filePath":"clean_arb_bot/src/meteora.rs","startLine":354,"endLine":531}]}},{"DuplicationClone":{"cloneLines":")?;\n\n    // 7. cbBTC-SOL\n    pool_registry.register_pool(\n        \"7wJK6JJQ\".to_string(),\n        PoolInfo {\n            full_address: \"7wJK6JJQERsyRoDNVnbkDtBKbXfoBV2dw8uP45WD5aC1\".parse()?,\n            dex_type: DexType::MeteoraDammV2,\n            token_a_mint: \"cbbtcf3aa214zXHbiAZQwf4122FBYbraNdFqgw4iMij\".parse()?, // cbBTC\n            token_b_mint: \"So11111111111111111111111111111111111111112\".parse()?, // SOL\n            reserve_a: \"82gYLm4jD9N6YXU86UJZQ5ziGbNBxpxNgmpe3TNP2Bgr\".parse()?,\n            reserve_b: \"8q5Cpus9iyPRp7KCxFFHJ3fcUcaMtadhzJ2S3YZA1VJ6\".parse()?,\n        },","nrTokens":0,"nrLines":13,"files":[{"filePath":"src/pool_population.rs","startLine":106,"endLine":118},{"filePath":"clean_arb_bot/src/pool_population.rs","startLine":106,"endLine":119}]}},{"DuplicationClone":{"cloneLines":"let create_ata_ix = spl_associated_token_account::instruction::create_associated_token_account(\n                user_pubkey,      // Payer\n                user_pubkey,      // Owner of new account\n                token_mint,       // Token mint\n                &spl_token::id(), // Token program ID\n            );\n\n            setup_instructions.push(create_ata_ix);\n            info!(\"??? ATA creation instruction added - account will be created in transaction\");\n        } else","nrTokens":0,"nrLines":10,"files":[{"filePath":"clean_arb_bot/src/meteora.rs","startLine":213,"endLine":222},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":225,"endLine":236}]}},{"DuplicationClone":{"cloneLines":");\n\n        Ok(HumidiFiPool {\n            pool_address: *pool_address,\n            token_a_mint: *token_a_mint,\n            token_b_mint: *token_b_mint,\n            token_a_vault,\n            token_b_vault,\n            pool_authority,\n            fee_rate: 5, // 0.05% estimated for dark pool\n        })\n    }\n\n    /// Get pool information (limited for dark pools)\n    pub async fn get_pool_info(\n        &self,\n        pool_address: &Pubkey,\n        token_a_mint: &Pubkey,\n        token_b_mint: &Pubkey,\n    ) -> Result<HumidiFiPoolInfo> {\n        // For dark pools, liquidity information is intentionally limited\n        // We can derive the basic structure but not actual liquidity amounts\n\n        let pool = self.derive_pool_accounts(pool_address, token_a_mint, token_b_mint)?;\n\n        warn!(\"?????? HumidiFi is a dark pool - liquidity information may be limited or unavailable\");\n\n        Ok(HumidiFiPoolInfo {\n            pool_address: pool.pool_address,\n            token_a: pool.token_a_mint,\n            token_b: pool.token_b_mint,\n            fee_rate: 0.0005, // 0.05% estimated (very low for dark pools)\n            liquidity_a: 0,   // Hidden in dark pool\n            liquidity_b: 0,   // Hidden in dark pool\n        })\n    }\n\n    /// Calculate expected output for a swap (approximate for dark pools)\n    pub fn calculate_swap_output(\n        &self,\n        amount_in: u64,\n        reserve_in: u64,\n        reserve_out: u64,\n        fee_rate: u16, // Basis points (e.g., 5 = 0.05%)\n    ) -> Result<u64> {\n        // Dark pools typically use more sophisticated pricing\n        // This is a simplified constant-product approximation\n\n        // Apply fee\n        let fee_multiplier = 10000 - fee_rate as u128;\n        let amount_in_with_fee = (amount_in as u128) * fee_multiplier / 10000;\n\n        // Constant product formula: x * y = k\n        let numerator = amount_in_with_fee * (reserve_out as u128);\n        let denominator = (reserve_in as u128) + amount_in_with_fee;\n\n        if denominator == 0 {\n            return Err(anyhow::anyhow!(\"Invalid reserves: division by zero\"));\n        }\n\n        let amount_out = numerator / denominator;\n\n        Ok(amount_out as u64)\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct HumidiFiPoolInfo {\n    pub pool_address: Pubkey,\n    pub token_a: Pubkey,\n    pub token_b: Pubkey,\n    pub fee_rate: f64,    // Typically very low (0.05% or less)\n    pub liquidity_a: u64, // May be hidden (dark pool)\n    pub liquidity_b: u64, // May be hidden (dark pool)\n}\n\n// Instruction discriminators (VERIFIED from on-chain transaction data)\n// HumidiFi has TWO different instruction types we've verified:\npub mod instruction {\n    // SWAP instruction discriminator (verified from blockchain)\n    // Transaction: 4N1LB4c5Jii7CoBryiX6gwAC6Edv9en2umFN7oz6jDtj6F97xKrdWqkdy2gnnVzyg3wf715XyNtffnQQmKgejhT\n    // Hex: 431b85114eef526f\n    // Usage: User swaps through HumidiFi pools (33,310 CUs, 9 accounts)\n    pub const SWAP: [u8; 8] = [67, 27, 133, 17, 78, 239, 82, 111];\n\n    // ORACLE UPDATE instruction discriminator (verified from blockchain)\n    // Transaction: 2Y5fRhw5PU6pSLoCagKz4RAzdbpdW9yLY7qRE6c4B5LS2qo993fpcRfMPTzPFcR4zgKcph1wsRtPKTGinzvjTh9F\n    // Hex: 25e40bc31ced57b9\n    // Usage: Authority updates price curves (140 CUs, 3 accounts)\n    pub const ORACLE_UPDATE: [u8; 8] = [37, 228, 11, 195, 28, 237, 87, 185];\n\n    // Add liquidity discriminator (not yet verified)\n    pub const ADD_LIQUIDITY: [u8; 8] = [181, 157, 89, 67, 143, 182, 52, 72];\n\n    // Remove liquidity discriminator (not yet verified)\n    pub const REMOVE_LIQUIDITY: [u8; 8] = [80, 85, 209, 72, 24, 206, 177, 108];\n}\n\n// Helper to check if a program ID matches HumidiFi\npub fn is_humidifi_program(program_id: &Pubkey) -> bool {\n    program_id.to_string() == HUMIDIFI_PROGRAM_ID\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_humidifi_builder_creation() {\n        let result = HumidiFiSwapBuilder::new();\n        // Should succeed now that we have a tentative program ID\n        assert!(result.is_ok());\n        let builder = result.unwrap();\n        assert_eq!(builder.program_id.to_string(), HUMIDIFI_PROGRAM_ID);\n    }\n}","nrTokens":0,"nrLines":116,"files":[{"filePath":"src/humidifi.rs","startLine":205,"endLine":320},{"filePath":"clean_arb_bot/src/humidifi.rs","startLine":185,"endLine":300}]}},{"DuplicationClone":{"cloneLines":"};\n\n            let create_ata_ix = spl_associated_token_account::instruction::create_associated_token_account(\n                user_pubkey,      // Payer\n                user_pubkey,      // Owner of new account\n                token_mint,       // Token mint\n                &spl_token::id(), // Token program ID\n            );\n\n            setup_instructions.push(create_ata_ix);\n            info!(\"??? ATA creation instruction added for output - account will be created in transaction\"","nrTokens":0,"nrLines":11,"files":[{"filePath":"clean_arb_bot/src/raydium.rs","startLine":243,"endLine":253},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":223,"endLine":233}]}},{"DuplicationClone":{"cloneLines":"// HumidiFi DEX implementation (dark pool/proprietary AMM)\n// One of the highest volume DEXs on Solana - critical for arbitrage\n\nuse anyhow::{Context, Result};\nuse solana_sdk::{\n    instruction::{AccountMeta, Instruction},\n    pubkey::Pubkey,\n    sysvar,\n};\nuse std::str::FromStr;\nuse tracing::{debug, info, warn};\n\n// HumidiFi is a proprietary AMM (dark pool) that launched June 2024\n// Achieves extremely low compute units (143 CUs vs typical 200k+)\n// Daily volume: $1-2B+ (one of Solana's largest DEXs)\n// Program ID verified from Solscan: https://solscan.io/account/9H6tua7jkLhdm3w8BvgpTn5LZNU7g4ZynDmCiNN3q6Rp\npub const HUMIDIFI_PROGRAM_ID: &str = \"9H6tua7jkLhdm3w8BvgpTn5LZNU7g4ZynDmCiNN3q6Rp\";\n\n// SPL Token program ID\nconst SPL_TOKEN_PROGRAM_ID: &str = \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\";\n\n// Associated Token Account program ID\nconst ASSOCIATED_TOKEN_PROGRAM_ID: &str = \"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\";\n\n// HumidiFi pool account structure\n#[derive(Debug, Clone)]\npub struct HumidiFiPool {\n    pub pool_address: Pubkey,\n    pub token_a_mint: Pubkey,\n    pub token_b_mint: Pubkey,\n    pub token_a_vault: Pubkey,\n    pub token_b_vault: Pubkey,\n    pub pool_authority: Pubkey,\n    pub fee_rate: u16, // Basis points (e.g., 5 = 0.05%)\n}\n\npub struct HumidiFiSwapBuilder {\n    program_id: Pubkey,\n    token_program_id: Pubkey,\n}\n\nimpl HumidiFiSwapBuilder {\n    pub fn new() -> Result<Self> {\n        let program_id =\n            Pubkey::from_str(HUMIDIFI_PROGRAM_ID).context(\"Invalid HumidiFi program ID\")?;\n\n        let token_program_id =\n            Pubkey::from_str(SPL_TOKEN_PROGRAM_ID).context(\"Invalid SPL Token program ID\")?;\n\n        info!(\"??? HumidiFi swap builder initialized with VERIFIED instruction format\");\n        info!(\"   Program ID: {} (verified from Solscan)\", program_id);\n        info!(\"   Swap discriminator: 431b85114eef526f (verified from tx 4N1LB4c5...)\");\n\n        Ok(Self {\n            program_id,\n            token_program_id,\n        })\n    }\n\n    /// Build swap instruction for HumidiFi dark pool\n    ///\n    /// HumidiFi is optimized for:\n    /// - Extremely low compute units (143 CUs)\n    /// - Minimal slippage (dark pool mechanics)\n    /// - High volume trades ($1-2B daily)\n    pub fn build_swap_instruction(\n        &self,\n        pool: &HumidiFiPool,\n        user_wallet: &Pubkey,\n        amount_in: u64,\n        minimum_amount_out: u64,\n        swap_a_to_b: bool, // true = TokenA -> TokenB, false = TokenB -> TokenA\n    ) -> Result<Instruction> {\n        debug!(\"???? Building HumidiFi swap instruction\");\n        debug!(\"   Pool: {}\", pool.pool_address);\n        debug!(\"   Amount in: {}\", amount_in);\n        debug!(\"   Min amount out: {}\", minimum_amount_out);\n        debug!(\n            \"   Direction: {}\",\n            if swap_a_to_b { \"A->B\" } else { \"B->A\" }\n        );\n\n        // Derive user's token accounts\n        let user_source_token = if swap_a_to_b {\n            spl_associated_token_account::get_associated_token_address(\n                user_wallet,\n                &pool.token_a_mint,","nrTokens":0,"nrLines":87,"files":[{"filePath":"src/humidifi.rs","startLine":1,"endLine":87},{"filePath":"clean_arb_bot/src/humidifi.rs","startLine":1,"endLine":82}]}},{"DuplicationClone":{"cloneLines":");\n\n        debug!(\"???? Derived PDAs:\");\n        debug!(\"   global_config: {}\", global_config);\n        debug!(\"   event_authority: {}\", event_authority);\n        debug!(\n            \"   vault_a ({}): {}\",\n            if swap_a_to_b { \"WSOL\" } else { \"token\" },\n            vault_a\n        );\n        debug!(\n            \"   vault_b ({}): {}\",\n            if swap_a_to_b { \"token\" } else { \"WSOL\" },\n            vault_b\n        );\n\n        // CORRECT 12-account structure from Grok analysis\n        // CRITICAL: Order must match exactly or simulation will fail!\n        let instruction = Instruction {\n            program_id: self.program_id,\n            accounts: vec![\n                // 0: user (signer, writable)\n                AccountMeta::new(*user_wallet, true),\n                // 1: user_token_account_a (writable) - input token account\n                AccountMeta::new(user_account_a, false),\n                // 2: user_token_account_b (writable) - output token account\n                AccountMeta::new(user_account_b, false),\n                // 3: vault_a (writable) - pool vault for token A (PDA)\n                AccountMeta::new(vault_a, false),\n                // 4: vault_b (writable) - pool vault for token B (PDA)\n                AccountMeta::new(vault_b, false),\n                // 5: mint_a (read-only) - input token mint\n                AccountMeta::new_readonly(mint_a, false),\n                // 6: mint_b (read-only) - output token mint\n                AccountMeta::new_readonly(mint_b, false),\n                // 7: pool (read-only) - AMM pool state account\n                AccountMeta::new_readonly(pool.pool_address, false),\n                // 8: global_config (read-only, PDA)\n                AccountMeta::new_readonly(global_config, false),\n                // 9: event_authority (read-only, PDA)\n                AccountMeta::new_readonly(event_authority, false),\n                // 10: token_program (read-only)\n                AccountMeta::new_readonly(Pubkey::from_str(SPL_TOKEN_PROGRAM_ID).unwrap(), false),\n                // 11: associated_token_program (read-only)\n                AccountMeta::new_readonly(\n                    Pubkey::from_str(ASSOCIATED_TOKEN_PROGRAM_ID).unwrap(),\n                    false,","nrTokens":0,"nrLines":47,"files":[{"filePath":"src/pumpswap.rs","startLine":166,"endLine":212},{"filePath":"clean_arb_bot/src/pumpswap.rs","startLine":154,"endLine":207}]}},{"DuplicationClone":{"cloneLines":") -> SharedCachedBlockhash {\n    let cached = Arc::new(RwLock::new(None));\n    let cached_clone = cached.clone();\n\n    tokio::spawn(async move {\n        info!(\"???? Starting blockhash refresh task (every 400ms)\");\n\n        let mut consecutive_failures = 0u32;\n\n        loop {\n            match rpc_client.get_latest_blockhash() {\n                Ok(hash) => {\n                    let mut cache = cached_clone.write().await;\n                    *cache = Some(CachedBlockhash {\n                        hash,\n                        fetched_at: Instant::now(),\n                    });\n\n                    if consecutive_failures > 0 {\n                        info!(\n                            \"??? Blockhash refresh recovered after {} failures\",\n                            consecutive_failures\n                        );\n                        consecutive_failures = 0;\n                    } else {\n                        debug!(\"???? Blockhash refreshed: {}\", hash);\n                    }\n                }\n                Err(e) => {\n                    consecutive_failures += 1;\n                    if consecutive_failures <= 3 {\n                        warn!(\n                            \"?????? Failed to refresh blockhash (attempt {}): {}\",\n                            consecutive_failures, e\n                        );\n                    } else if consecutive_failures == 10 {\n                        warn!(\"???? Blockhash refresh failing ({} consecutive failures) - using stale blockhash\", consecutive_failures);\n                    }\n                    // Keep using old blockhash if fetch fails\n                }\n            }\n\n            tokio::time::sleep(Duration::from_millis(400)).await;\n        }\n    });\n\n    info!(\"??? Blockhash refresh task started (saves 50-70ms per transaction)\");\n    cached\n}\n\n/// Get cached blockhash, falling back to RPC if not available\n///\n/// This function prefers the cached blockhash for speed, but will\n/// fetch directly from RPC if cache is empty (startup) or very stale (>5s).\npub async fn get_blockhash(\n    cached: &SharedCachedBlockhash,\n    rpc_client: &SolanaRpcClient,\n) -> Result<Hash> {\n    // Try cached first\n    let cache = cached.read().await;\n\n    if let Some(ref cached_bh) = *cache {\n        let age = cached_bh.fetched_at.elapsed();\n\n        // Use cached if < 5 seconds old\n        if age < Duration::from_secs(5) {\n            debug!(\"??? Using cached blockhash (age: {}ms)\", age.as_millis());\n            return Ok(cached_bh.hash);\n        } else {\n            warn!(\n                \"?????? Cached blockhash is stale (age: {}s) - fetching new one\",\n                age.as_secs()\n            );\n        }\n    }\n\n    // Cache miss or stale - fetch from RPC\n    drop(cache); // Release read lock before fetching\n\n    debug!(\"???? Cache miss - fetching blockhash from RPC\");\n    let hash = rpc_client.get_latest_blockhash()?;\n\n    // Update cache\n    let mut cache = cached.write().await;\n    *cache = Some(CachedBlockhash {\n        hash,\n        fetched_at: Instant::now(),\n    });\n\n    Ok(hash)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_cached_blockhash_struct() {\n        let hash = Hash::default();\n        let cached = CachedBlockhash {\n            hash,\n            fetched_at: Instant::now(),\n        };\n\n        assert_eq!(cached.hash, hash);\n        assert!(cached.fetched_at.elapsed() < Duration::from_millis(10));\n    }\n}","nrTokens":0,"nrLines":108,"files":[{"filePath":"src/cached_blockhash.rs","startLine":34,"endLine":141},{"filePath":"clean_arb_bot/src/cached_blockhash.rs","startLine":36,"endLine":134}]}},{"DuplicationClone":{"cloneLines":")?;\n\n    // 8. USDC-USDT (Stablecoin pair for arbitrage)\n    pool_registry.register_pool(\n        \"ARwi1S4D\".to_string(),\n        PoolInfo {\n            full_address: \"ARwi1S4DaiTG5DX7S4M4ZsrXqpMD1MrTmbu9ue2tpmEq\".parse()?,\n            dex_type: DexType::MeteoraDammV2,\n            token_a_mint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".parse()?, // USDC\n            token_b_mint: \"Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB\".parse()?, // USDT\n            reserve_a: \"4STreSrMtf8umxyei9DaZG4bX3HT9hE3TGw3Xz41XNHd\".parse()?,\n            reserve_b: \"GkTrsQsu8WvrbairmN12aUKk74qHivRNFxaT5YxCECKQ\".parse()?,\n        },","nrTokens":0,"nrLines":13,"files":[{"filePath":"src/pool_population.rs","startLine":119,"endLine":131},{"filePath":"clean_arb_bot/src/pool_population.rs","startLine":119,"endLine":132}]}},{"DuplicationClone":{"cloneLines":";\n\n/// Bundle submission request\n#[derive(Debug, Clone)]\npub struct BundleRequest {\n    pub transactions: Vec<Transaction>, // Transactions with tips ALREADY included\n    pub description: String,            // For logging (e.g., \"SOL???TokenA???SOL arbitrage\")\n    pub expected_profit_sol: f64,\n    pub attempt: u32,\n    pub queued_at: Instant, // Timestamp when bundle was queued\n}\n\n/// Queue-based JITO bundle submitter with optional gRPC + HTTP fallback\n///\n/// Ensures exactly 1 bundle per 1.1 seconds to avoid 429 errors\npub struct JitoSubmitter {\n    queue_tx: mpsc::Sender<BundleRequest>, // CRITICAL FIX: Bounded channel (was unbounded)\n    stats: Arc<Mutex<SubmitterStats>>,\n    grpc_client: Option<Arc<Mutex<JitoGrpcClient>>>, // Optional: gRPC (75ms latency)\n    http_client: Arc<JitoBundleClient>,              // Always available: HTTP (150ms latency)\n}\n\n#[derive(Debug, Default)]\npub struct SubmitterStats {\n    pub total_queued: u64,\n    pub total_submitted: u64,\n    pub total_failed: u64,\n    pub rate_limited_429: u64,\n    pub queue_depth: usize,\n    pub queue_full_drops: u64, // Track dropped bundles due to full queue\n}\n\nimpl JitoSubmitter {\n    /// Create new JITO submitter with optional gRPC + HTTP fallback\n    /// CRITICAL FIX: Uses bounded channel (capacity 100) to prevent memory leaks\n    pub fn new(\n        grpc_client: Option<Arc<Mutex<JitoGrpcClient>>>,\n        http_client: Arc<JitoBundleClient>,\n    ) -> Self {\n        let (queue_tx, mut queue_rx) = mpsc::channel::<BundleRequest>(100); // Bounded capacity\n        let stats = Arc::new(Mutex::new(SubmitterStats::default()));\n        let stats_clone = stats.clone();\n        let grpc_clone = grpc_client.clone();\n        let http_clone = http_client.clone();\n\n        // Spawn dedicated submission task\n        tokio::spawn(async move {\n            let mut last_submit = Instant::now();\n\n            info!(\"???? JITO submission queue started (WAIT-FOR-FRESH)\");\n            info!(\"   Rate: 1 bundle per 1.5 seconds\");\n            info!(\"   Strategy: DISCARD ALL stale, WAIT for fresh opportunities\");\n            info!(\"   User requirement: '0ms when we start the process'\");\n            info!(\"   Implementation: Drop everything, wait 100ms for NEW opportunity\");\n\n            loop {\n                // Check if rate limit requires waiting\n                let elapsed = last_submit.elapsed();\n                if elapsed < Duration::from_millis(1500) {\n                    let wait_time = Duration::from_millis(1500) - elapsed;\n                    debug!(\n                        \"?????? Rate limiting: waiting {:?} before next submission\",\n                        wait_time\n                    );\n\n                    // Sleep for most of the wait time\n                    time::sleep(wait_time).await;\n\n                    // NOW clear ALL stale bundles from queue\n                    let mut drained_count = 0;\n                    while let Ok(_) = queue_rx.try_recv() {\n                        drained_count += 1;\n                    }\n                    if drained_count > 0 {\n                        debug!(\n                            \"???? Discarded {} stale bundles - waiting for FRESH\",\n                            drained_count\n                        );\n                        let mut s = stats_clone.lock().await;\n                        s.total_failed += drained_count as u64;\n                    }\n                }\n\n                // Rate limit is now open. WAIT for a FRESH opportunity to arrive.\n                // User requirement: \"We want the coin we submit to be 0ms when we start\"\n                // Solution: Wait up to 100ms for a NEW bundle. If none arrives, skip this cycle.\n                debug!(\"???? Rate limit open - waiting up to 100ms for FRESH opportunity...\");\n\n                let request = match time::timeout(Duration::from_millis(100), queue_rx.recv()).await\n                {\n                    Ok(Some(req)) => {\n                        let age_ms = req.queued_at.elapsed().as_millis();\n                        debug!(\"??? Fresh opportunity arrived (age: {}ms)\", age_ms);\n                        req\n                    }\n                    Ok(None) => {\n                        warn!(\"?????? Queue closed, stopping submission task\");\n                        break;\n                    }\n                    Err(_) => {\n                        // No opportunity arrived in 100ms window - skip this cycle\n                        debug!(\"?????? No fresh opportunity in 100ms window - skipping cycle\");\n                        continue;\n                    }\n                };\n\n                // We have a fresh opportunity! Verify freshness one more time\n                let age_ms = request.queued_at.elapsed().as_millis();\n                if age_ms > 150 {\n                    // Should be impossible, but safety check\n                    warn!(\"??? Unexpected: bundle age {}ms > 150ms - dropping\", age_ms);\n                    let mut s = stats_clone.lock().await;\n                    s.total_failed += 1;\n                    continue;\n                }\n\n                // Update queue depth\n                {\n                    let mut s = stats_clone.lock().await;\n                    s.queue_depth = queue_rx.len();\n                }\n\n                // Try gRPC first (if available), otherwise use HTTP\n                let bundle_id = if let Some(ref grpc_mutex) = grpc_clone {\n                    // gRPC available - try it first (2x faster!)\n                    let mut grpc = grpc_mutex.lock().await;\n                    match tokio::time::timeout(\n                        Duration::from_secs(5),\n                        grpc.send_bundle(request.transactions.clone()),","nrTokens":0,"nrLines":129,"files":[{"filePath":"src/jito_submitter.rs","startLine":20,"endLine":148},{"filePath":"clean_arb_bot/src/jito_submitter.rs","startLine":20,"endLine":141}]}},{"DuplicationClone":{"cloneLines":")?;\n\n    // 5. SOL-USDC (High Liquidity #5)\n    pool_registry.register_pool(\n        \"5rCf1DM8\".to_string(),\n        PoolInfo {\n            full_address: \"5rCf1DM8LjKTw4YqhnoLcngyZYeNnQqztScTogYHAS6\".parse()?,\n            dex_type: DexType::MeteoraDammV2,\n            token_a_mint: \"So11111111111111111111111111111111111111112\".parse()?, // SOL\n            token_b_mint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".parse()?, // USDC\n            reserve_a: \"EYj9xKw6ZszwpyNibHY7JD5o3QgTVrSdcBp1fMJhrR9o\".parse()?,\n            reserve_b: \"CoaxzEh8p5YyGLcj36Eo3cUThVJxeKCs7qvLAGDYwBcz\".parse()?,\n        },","nrTokens":0,"nrLines":13,"files":[{"filePath":"src/pool_population.rs","startLine":80,"endLine":92},{"filePath":"clean_arb_bot/src/pool_population.rs","startLine":80,"endLine":93}]}},{"DuplicationClone":{"cloneLines":"};\n\n/// Lock-free position tracker using atomic operations\n///\n/// Thread-safe capital management for concurrent arbitrage opportunities\npub struct PositionTracker {\n    /// Total capital available for trading (in lamports) - DYNAMICALLY UPDATED\n    /// This tracks actual wallet balance minus fee reserve\n    total_capital_lamports: AtomicU64,\n\n    /// Capital currently committed to in-flight trades (atomic for thread-safety)\n    in_flight_lamports: AtomicU64,\n\n    /// Maximum allowed position size (in lamports)\n    max_position_lamports: u64,\n\n    /// Fee reserve (always protected, never tradeable) - DEFAULT: 0.1 SOL\n    fee_reserve_lamports: u64,\n}\n\nimpl PositionTracker {\n    /// Create new position tracker with DYNAMIC balance tracking\n    ///\n    /// # Arguments\n    /// * `capital_sol` - Initial trading capital in SOL (will update dynamically)\n    /// * `max_position_sol` - Maximum position size per trade in SOL\n    ///\n    /// # Fee Reserve\n    /// - 0.1 SOL is ALWAYS protected for transaction fees\n    /// - Tradeable balance = wallet_balance - 0.1 SOL\n    /// - This reserve is never used for trades\n    pub fn new(capital_sol: f64, max_position_sol: f64) -> Self {\n        const FEE_RESERVE_SOL: f64 = 0.1;\n        let fee_reserve_lamports = (FEE_RESERVE_SOL * 1_000_000_000.0) as u64;\n\n        // Initial capital (will be updated dynamically from wallet balance)\n        let total_capital_lamports = (capital_sol * 1_000_000_000.0) as u64;\n        let max_position_lamports = (max_position_sol * 1_000_000_000.0) as u64;\n\n        info!(\"??? Position tracker initialized (DYNAMIC SIZING):\");\n        info!(\n            \"   Initial capital: {:.4} SOL ({} lamports)\",\n            capital_sol, total_capital_lamports\n        );\n        info!(\n            \"   Max position: {:.4} SOL ({} lamports)\",\n            max_position_sol, max_position_lamports\n        );\n        info!(\n            \"   Fee reserve: {:.4} SOL ({} lamports) - PROTECTED\",\n            FEE_RESERVE_SOL, fee_reserve_lamports\n        );\n        info!(\"   Tradeable balance will update based on actual wallet balance\");\n\n        Self {\n            total_capital_lamports: AtomicU64::new(total_capital_lamports),\n            in_flight_lamports: AtomicU64::new(0),\n            max_position_lamports,\n            fee_reserve_lamports,\n        }\n    }\n\n    /// Check if we can open a new position of given size\n    ///\n    /// # Arguments\n    /// * `size_lamports` - Desired position size in lamports\n    ///\n    /// # Returns\n    /// true if capital is available, false otherwise\n    pub fn can_open_position(&self, size_lamports: u64) -> bool {\n        // Check against max position size limit\n        if size_lamports > self.max_position_lamports {\n            debug!(\n                \"Position size {} exceeds max {} lamports\",\n                size_lamports, self.max_position_lamports\n            );\n            return false;\n        }\n\n        // Check against available capital (using atomic load)\n        let current_in_flight = self.in_flight_lamports.load(Ordering::Relaxed);\n        let total_capital = self.total_capital_lamports.load(Ordering::Relaxed);\n        let available = total_capital.saturating_sub(current_in_flight);\n\n        size_lamports <= available\n    }\n\n    /// Update total capital based on actual wallet balance\n    ///\n    /// # Arguments\n    /// * `wallet_balance_lamports` - Current wallet balance from Solana RPC\n    ///\n    /// # Returns\n    /// Tradeable balance (wallet balance - fee reserve)\n    ///\n    /// # Example\n    /// ```\n    /// // Wallet has 2.5 SOL\n    /// let tradeable = tracker.update_from_wallet_balance(2_500_000_000);\n    /// // tradeable = 2.5 - 0.1 = 2.4 SOL (2,400,000,000 lamports)\n    /// ```\n    pub fn update_from_wallet_balance(&self, wallet_balance_lamports: u64) -> u64 {\n        // Calculate tradeable balance (wallet - fee reserve)\n        let tradeable = wallet_balance_lamports.saturating_sub(self.fee_reserve_lamports);\n\n        // Update total capital atomically\n        let old_capital = self\n            .total_capital_lamports\n            .swap(tradeable, Ordering::Release);\n\n        if tradeable != old_capital {\n            let old_sol = old_capital as f64 / 1_000_000_000.0;\n            let new_sol = tradeable as f64 / 1_000_000_000.0;\n            let wallet_sol = wallet_balance_lamports as f64 / 1_000_000_000.0;\n\n            info!(\"???? Capital updated from wallet balance:\");\n            info!(\"   Wallet balance: {:.6} SOL\", wallet_sol);\n            info!(\"   Fee reserve: 0.1 SOL (protected)\");\n            info!(\"   Tradeable: {:.6} SOL (was {:.6} SOL)\", new_sol, old_sol);\n        }\n\n        tradeable\n    }\n\n    /// Get dynamic position size based on current balance and opportunity size\n    ///\n    /// # Arguments\n    /// * `opportunity_size_lamports` - Size of the arbitrage opportunity\n    ///\n    /// # Returns\n    /// Actual position size to use: min(opportunity_size, tradeable_balance, max_position)\n    ///\n    /// # Logic\n    /// - Use up to 100% of tradeable balance if opportunity is large enough\n    /// - Cap at max_position_lamports for risk management\n    /// - Cap at opportunity size (don't trade more than needed)\n    pub fn get_dynamic_position_size(&self, opportunity_size_lamports: u64) -> u64 {\n        let total_capital = self.total_capital_lamports.load(Ordering::Relaxed);\n        let in_flight = self.in_flight_lamports.load(Ordering::Relaxed);\n        let available = total_capital.saturating_sub(in_flight);\n\n        // Use minimum of: opportunity size, available capital, max position\n        let position_size = opportunity_size_lamports\n            .min(available)\n            .min(self.max_position_lamports);\n\n        debug!(\"???? Dynamic position sizing:\");\n        debug!(\n            \"   Opportunity size: {:.6} SOL\",\n            opportunity_size_lamports as f64 / 1e9\n        );\n        debug!(\"   Available capital: {:.6} SOL\", available as f64 / 1e9);\n        debug!(\n            \"   Max position: {:.6} SOL\",\n            self.max_position_lamports as f64 / 1e9\n        );\n        debug!(\"   Position size: {:.6} SOL\", position_size as f64 / 1e9);\n\n        position_size\n    }\n\n    /// Reserve capital for a new position (atomic operation)\n    ///\n    /// # Arguments\n    /// * `amount_lamports` - Amount to reserve in lamports\n    ///\n    /// # Returns\n    /// Ok(()) if reservation successful, Err if insufficient capital\n    pub fn reserve_capital(&self, amount_lamports: u64) -> Result<()> {\n        // Validate against max position size\n        if amount_lamports > self.max_position_lamports {\n            return Err(anyhow!(\n                \"Position size {} lamports exceeds max {} lamports ({:.4} SOL > {:.4} SOL)\",\n                amount_lamports,\n                self.max_position_lamports,\n                amount_lamports as f64 / 1_000_000_000.0,\n                self.max_position_lamports as f64 / 1_000_000_000.0\n            ));\n        }\n\n        // Atomic compare-and-swap loop\n        // This ensures thread-safety without locks (lock-free programming)\n        loop {\n            let current = self.in_flight_lamports.load(Ordering::Acquire);\n            let new_total = current + amount_lamports;\n            let total_capital = self.total_capital_lamports.load(Ordering::Relaxed);\n\n            // Check if we have enough capital\n            if new_total > total_capital {\n                let available = total_capital - current;\n                return Err(anyhow!(\n                    \"Insufficient capital: {} lamports needed, {} lamports available ({:.4} SOL needed, {:.4} SOL available)\",\n                    amount_lamports,\n                    available,\n                    amount_lamports as f64 / 1_000_000_000.0,\n                    available as f64 / 1_000_000_000.0\n                ));\n            }\n\n            // Try to atomically update in_flight amount\n            match self.in_flight_lamports.compare_exchange(\n                current,\n                new_total,\n                Ordering::Release, // Success: ensure write is visible to other threads\n                Ordering::Relaxed, // Failure: retry with new value\n            ) {\n                Ok(_) => {\n                    debug!(\"??? Reserved {} lamports ({:.4} SOL). In-flight: {} lamports ({:.4} SOL / {:.4} SOL total)\",\n                        amount_lamports,\n                        amount_lamports as f64 / 1_000_000_000.0,\n                        new_total,\n                        new_total as f64 / 1_000_000_000.0,\n                        self.total_capital_lamports.load(Ordering::Relaxed) as f64 / 1_000_000_000.0\n                    );\n                    return Ok(());\n                }\n                Err(_) => {\n                    // Another thread modified in_flight_lamports, retry\n                    debug!(\"??? Capital reservation conflict, retrying...\");\n                    continue;\n                }\n            }\n        }\n    }\n\n    /// Release capital after position is closed\n    ///\n    /// # Arguments\n    /// * `amount_lamports` - Amount to release in lamports\n    ///\n    /// SAFETY: This uses fetch_sub which can underflow if called incorrectly.\n    /// Always ensure reserve_capital was called before release_capital.\n    pub fn release_capital(&self, amount_lamports: u64) {\n        let previous = self\n            .in_flight_lamports\n            .fetch_sub(amount_lamports, Ordering::Release);\n\n        debug!(\"??? Released {} lamports ({:.4} SOL). In-flight: {} lamports ({:.4} SOL / {:.4} SOL total)\",\n            amount_lamports,\n            amount_lamports as f64 / 1_000_000_000.0,\n            previous - amount_lamports,\n            (previous - amount_lamports) as f64 / 1_000_000_000.0,\n            self.total_capital_lamports.load(Ordering::Relaxed) as f64 / 1_000_000_000.0\n        );\n\n        // SAFETY CHECK: Detect potential underflow (should never happen if used correctly)\n        if previous < amount_lamports {\n            warn!(\"?????? CRITICAL: Position tracker underflow detected!\");\n            warn!(\n                \"   Attempted to release {} lamports, but only {} were in-flight\",\n                amount_lamports, previous\n            );\n            warn!(\"   This indicates a logic bug - investigate immediately!\");\n        }\n    }\n\n    /// Get current capital utilization statistics\n    pub fn get_stats(&self) -> PositionStats {\n        let in_flight = self.in_flight_lamports.load(Ordering::Relaxed);\n        let total_capital = self.total_capital_lamports.load(Ordering::Relaxed);\n        let available = total_capital.saturating_sub(in_flight);\n        let utilization_pct = (in_flight as f64 / total_capital as f64) * 100.0;\n\n        PositionStats {\n            total_capital_sol: total_capital as f64 / 1_000_000_000.0,\n            in_flight_sol: in_flight as f64 / 1_000_000_000.0,\n            available_sol: available as f64 / 1_000_000_000.0,\n            utilization_pct,\n            max_position_sol: self.max_position_lamports as f64 / 1_000_000_000.0,\n        }\n    }\n\n    /// Emergency: Force reset all in-flight capital\n    ///\n    /// DANGER: Only use this for emergency recovery when positions are stuck\n    /// This should NEVER be needed in normal operation\n    pub fn emergency_reset(&self) {\n        warn!(\"???? EMERGENCY: Force resetting all in-flight capital to zero\");\n        warn!(\n            \"   Previous in-flight: {} lamports\",\n            self.in_flight_lamports.load(Ordering::Relaxed)\n        );\n\n        self.in_flight_lamports.store(0, Ordering::Release);\n\n        let total_capital = self.total_capital_lamports.load(Ordering::Relaxed);\n        warn!(\n            \"   All capital now available: {} lamports ({:.4} SOL)\",\n            total_capital,\n            total_capital as f64 / 1_000_000_000.0\n        );\n    }\n}\n\n/// Position tracker statistics\n#[derive(Debug, Clone)]\npub struct PositionStats {\n    pub total_capital_sol: f64,\n    pub in_flight_sol: f64,\n    pub available_sol: f64,\n    pub utilization_pct: f64,\n    pub max_position_sol: f64,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_can_open_position() {\n        let tracker = PositionTracker::new(2.0, 0.5);\n\n        // Can open position within limits\n        assert!(tracker.can_open_position(500_000_000)); // 0.5 SOL\n        assert!(tracker.can_open_position(100_000_000)); // 0.1 SOL\n\n        // Cannot exceed max position\n        assert!(!tracker.can_open_position(600_000_000)); // 0.6 SOL > 0.5 max\n\n        // Cannot exceed total capital\n        assert!(!tracker.can_open_position(3_000_000_000)); // 3 SOL > 2 total\n    }\n\n    #[test]\n    fn test_reserve_and_release() {\n        let tracker = PositionTracker::new(2.0, 0.5);\n\n        // Reserve first position\n        assert!(tracker.reserve_capital(500_000_000).is_ok()); // 0.5 SOL\n\n        // Check available reduced\n        assert!(tracker.can_open_position(500_000_000)); // Still have 1.5 SOL\n        assert!(!tracker.can_open_position(2_000_000_000)); // But not 2 SOL\n\n        // Reserve second position\n        assert!(tracker.reserve_capital(500_000_000).is_ok()); // 0.5 SOL more\n\n        // Now only 1 SOL left\n        assert!(tracker.can_open_position(500_000_000));\n        assert!(!tracker.can_open_position(1_500_000_000));\n\n        // Release first position\n        tracker.release_capital(500_000_000);\n\n        // Should have 1.5 SOL available again\n        assert!(tracker.can_open_position(1_000_000_000)); // 1 SOL ok\n        assert!(!tracker.can_open_position(2_000_000_000)); // 2 SOL still too much\n    }\n\n    #[test]\n    fn test_exceeds_capital() {\n        let tracker = PositionTracker::new(1.0, 0.5);\n\n        // Reserve 0.5 SOL\n        assert!(tracker.reserve_capital(500_000_000).is_ok());\n\n        // Reserve another 0.5 SOL\n        assert!(tracker.reserve_capital(500_000_000).is_ok());\n\n        // Try to reserve more - should fail (only 1 SOL total)\n        let result = tracker.reserve_capital(100_000_000); // 0.1 SOL\n        assert!(result.is_err());\n        assert!(result\n            .unwrap_err()\n            .to_string()\n            .contains(\"Insufficient capital\"));\n    }\n\n    #[test]\n    fn test_exceeds_max_position() {\n        let tracker = PositionTracker::new(2.0, 0.5);\n\n        // Try to reserve 0.6 SOL (exceeds max 0.5)\n        let result = tracker.reserve_capital(600_000_000);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"exceeds max\"));\n    }\n\n    #[test]\n    fn test_stats() {\n        let tracker = PositionTracker::new(2.0, 0.5);\n\n        let stats = tracker.get_stats();\n        assert_eq!(stats.total_capital_sol, 2.0);\n        assert_eq!(stats.in_flight_sol, 0.0);\n        assert_eq!(stats.available_sol, 2.0);\n        assert_eq!(stats.utilization_pct, 0.0);\n\n        // Reserve some capital\n        tracker.reserve_capital(1_000_000_000).unwrap(); // 1 SOL\n\n        let stats = tracker.get_stats();\n        assert_eq!(stats.in_flight_sol, 1.0);\n        assert_eq!(stats.available_sol, 1.0);\n        assert_eq!(stats.utilization_pct, 50.0);\n    }\n\n    #[test]\n    fn test_concurrent_reservations() {\n        use std::sync::Arc;\n        use std::thread;\n\n        let tracker = Arc::new(PositionTracker::new(10.0, 1.0));\n        let mut handles = vec![];\n\n        // Spawn 20 threads, each trying to reserve 0.5 SOL\n        for i in 0..20 {\n            let tracker_clone = tracker.clone();\n            let handle = thread::spawn(move || {\n                tracker_clone.reserve_capital(500_000_000) // 0.5 SOL\n            });\n            handles.push(handle);\n        }\n\n        // Collect results\n        let mut successes = 0;\n        let mut failures = 0;\n        for handle in handles {\n            match handle.join().unwrap() {\n                Ok(_) => successes += 1,\n                Err(_) => failures += 1,\n            }\n        }\n\n        // Total capital is 10 SOL, each reservation is 0.5 SOL\n        // So exactly 20 should succeed (10 / 0.5 = 20)\n        // Actually, exactly 10 SOL / 0.5 SOL = 20 reservations should succeed\n        // Wait, 10 SOL total, 0.5 per reservation = max 20 reservations\n        // But we started 20 threads, so all should succeed\n        assert_eq!(successes, 20);\n        assert_eq!(failures, 0);\n\n        // Check final stats\n        let stats = tracker.get_stats();\n        assert_eq!(stats.in_flight_sol, 10.0); // All capital in use\n        assert_eq!(stats.available_sol, 0.0);\n        assert_eq!(stats.utilization_pct, 100.0);\n    }\n}","nrTokens":0,"nrLines":439,"files":[{"filePath":"src/position_tracker.rs","startLine":10,"endLine":448},{"filePath":"clean_arb_bot/src/position_tracker.rs","startLine":10,"endLine":418}]}},{"DuplicationClone":{"cloneLines":") -> Result<String> {\n        let start_time = Instant::now();\n\n        // RATE LIMITING: Acquire token before proceeding\n        // JITO limit: 1 request/second per IP per region\n        // IMPORTANT: This rate limit is SHARED across Arb Bot and MEV Bot\n        self.rate_limiter.acquire().await;\n        debug!(\n            \"??? Rate limiter token acquired (took {}ms)\",\n            start_time.elapsed().as_millis()\n        );\n\n        info!(\n            \"???? Submitting SECURE Jito bundle: {} transactions (tips INSIDE transactions)\",\n            transactions.len()\n        );\n\n        // Convert to base58 encoded strings\n        let encoded_transactions: Result<Vec<String>> = transactions\n            .iter()\n            .map(|tx| {\n                let serialized = bincode::serialize(tx)?;\n                Ok(bs58::encode(serialized).into_string())\n            })\n            .collect();\n\n        let encoded_transactions = encoded_transactions?;\n\n        // Create bundle (no separate tip - already in transactions)\n        let bundle = JitoBundle {\n            uuid: Uuid::new_v4().to_string(),\n            transactions: encoded_transactions.clone(),\n            tip_amount: 0,                  // Not used - tip already in tx\n            tip_account: Pubkey::default(), // Not used\n        };\n\n        // Submit with retries\n        let bundle_id = self.submit_with_retries(&bundle).await?;\n\n        // Update metrics\n        if let Ok(mut metrics) = self.metrics.lock() {\n            metrics.bundles_submitted += 1;\n        }\n\n        let submission_time = start_time.elapsed().as_millis();\n        info!(\n            \"??? SECURE bundle submitted in {}ms: {}\",\n            submission_time, bundle_id\n        );\n\n        Ok(bundle_id)\n    }\n\n    /// Submit bundle with automatic tip calculation and retry logic (LEGACY - INSECURE)\n    ///\n    /// **?????? DEPRECATED**: This method creates a SEPARATE tip transaction, which is DANGEROUS!\n    /// Use `submit_bundle_safe()` instead with transactions that already include tips.\n    ///\n    /// IMPORTANT: This implementation follows Jito's best practices:\n    /// 1. Tip instruction is included INSIDE the swap transaction (not separate)\n    /// 2. No auth keypair required (new Jito API)\n    /// 3. Rate limiting at 1 req/sec per IP per region\n    /// 4. Uncle block protection via pre/post account checks\n    #[deprecated(note = \"Use submit_bundle_safe() with transactions that already include tips\")]\n    pub async fn submit_bundle(\n        &self,\n        mut transactions: Vec<Transaction>,\n        tip_lamports: Option<u64>,\n    ) -> Result<String> {\n        let start_time = Instant::now();\n\n        // RATE LIMITING: Acquire token before proceeding\n        // JITO limit: 1 request/second per IP per region\n        self.rate_limiter.acquire().await;\n        debug!(\n            \"??? Rate limiter token acquired (took {}ms)\",\n            start_time.elapsed().as_millis()\n        );\n\n        // Calculate optimal tip if not provided (minimum 1000 lamports per Jito docs)\n        #[allow(deprecated)] // Using legacy method until refactored - see TODO below\n        let tip_amount = tip_lamports\n            .unwrap_or_else(|| self.calculate_optimal_tip())\n            .max(1000);\n\n        // Select random tip account for load balancing\n        use rand::Rng;\n        let tip_account =\n            self.tip_accounts[rand::thread_rng().gen_range(0..self.tip_accounts.len())];\n\n        // CRITICAL FIX: Include tip INSIDE the swap transaction (not as separate transaction)\n        // This prevents \"unbundling\" via uncle blocks where tip executes but swap fails\n        if !transactions.is_empty() {\n            // Add tip instruction to the FIRST transaction (the swap transaction)\n            let _swap_tx = &mut transactions[0];\n\n            warn!(\"?????? CRITICAL: Tip should be added INSIDE swap transaction, not as separate tx\");\n            warn!(\"?????? Current implementation adds tip as separate tx - SECURITY RISK!\");\n            warn!(\"?????? TODO: Refactor swap_executor to build swap instructions WITHOUT signing,\");\n            warn!(\"??????       then add tip instruction, THEN sign as single transaction\");\n\n            // For now, we still use the old method (separate transaction) but log the warning\n            // The proper fix requires refactoring swap_executor.rs to expose unsigned instructions\n        }\n\n        // Create tip transaction (TEMPORARY - should be integrated into swap tx)\n        #[allow(deprecated)] // Using legacy method until swap_executor refactored\n        let tip_tx = self.create_tip_transaction_legacy(tip_amount, tip_account)?;\n\n        // Combine transactions\n        transactions.push(tip_tx);\n\n        // Convert to base58 encoded strings\n        let encoded_transactions: Result<Vec<String>> = transactions\n            .iter()\n            .map(|tx| {\n                let serialized = bincode::serialize(tx)?;\n                Ok(bs58::encode(serialized).into_string())\n            })\n            .collect();\n\n        let encoded_transactions = encoded_transactions?;\n\n        // Create bundle\n        let bundle = JitoBundle {\n            uuid: Uuid::new_v4().to_string(),\n            transactions: encoded_transactions.clone(),\n            tip_amount,\n            tip_account,\n        };\n\n        info!(\n            \"???? Submitting Jito bundle: {} transactions, {} lamports tip\",\n            bundle.transactions.len(),\n            tip_amount\n        );\n\n        // Submit with retries\n        let bundle_id = self.submit_with_retries(&bundle).await?;\n\n        // Update metrics\n        if let Ok(mut metrics) = self.metrics.lock() {\n            metrics.bundles_submitted += 1;\n            metrics.tip_amounts_paid.push(tip_amount);\n        }\n\n        let submission_time = start_time.elapsed().as_millis();\n        debug!(\"Bundle submitted in {}ms: {}\", submission_time, bundle_id);\n\n        Ok(bundle_id)\n    }\n\n    /// Submit bundle with retry logic\n    async fn submit_with_retries(&self, bundle: &JitoBundle) -> Result<String> {\n        let mut last_error = None;\n\n        for attempt in 1..=self.max_retries {\n            match self.submit_bundle_once(bundle).await {\n                Ok(bundle_id) => {\n                    if attempt > 1 {\n                        info!(\"??? Bundle submitted successfully on attempt {}\", attempt);\n                    }\n                    return Ok(bundle_id);\n                }\n                Err(e) => {\n                    let error_msg = e.to_string();\n                    warn!(\n                        \"??? Bundle submission attempt {} failed: {}\",\n                        attempt, error_msg\n                    );\n\n                    // Rotate endpoint on 429 errors (Grok recommendation)\n                    if error_msg.contains(\"429\") {\n                        let mut index = self.current_endpoint_index.lock().unwrap();\n                        *index = (*index + 1) % self.endpoints.lock().unwrap().len();\n                        debug!(\"???? Rotating to endpoint #{} due to 429\", *index + 1);\n                    }\n\n                    last_error = Some(e);\n\n                    if attempt < self.max_retries {\n                        let delay = Duration::from_millis(100 * attempt as u64);\n                        tokio::time::sleep(delay).await;\n                    }\n                }\n            }\n        }\n\n        Err(last_error.unwrap_or_else(|| anyhow::anyhow!(\"All bundle submission attempts failed\")))\n    }\n\n    /// Single bundle submission attempt\n    async fn submit_bundle_once(&self, bundle: &JitoBundle) -> Result<String> {\n        use rand::Rng;\n\n        // Get current endpoint (round-robin)\n        let current_endpoint = {\n            let index = *self.current_endpoint_index.lock().unwrap();\n            let endpoints = self.endpoints.lock().unwrap();\n            endpoints[index].clone()\n        };\n\n        let request = BundleSubmissionRequest {\n            jsonrpc: \"2.0\".to_string(),\n            id: rand::thread_rng().gen::<u64>(),\n            method: \"sendBundle\".to_string(),\n            params: vec![bundle.transactions.clone()], // Double-wrap: [[txs]]\n        };\n\n        debug!(\"???? Submitting to: {}\", current_endpoint);\n\n        let response = timeout(\n            Duration::from_secs(30),\n            self.client\n                .post(&format!(\"{}/api/v1/bundles\", current_endpoint))\n                .header(\"Content-Type\", \"application/json\")\n                .json(&request)\n                .send(),\n        )\n        .await??;\n\n        if !response.status().is_success() {\n            return Err(anyhow::anyhow!(\n                \"HTTP error {}: {}\",\n                response.status(),\n                response.text().await?\n            ));\n        }\n\n        let bundle_response: BundleSubmissionResponse = response.json().await?;\n\n        if let Some(error) = bundle_response.error {\n            return Err(anyhow::anyhow!(\n                \"Jito error {}: {}\",\n                error.code,\n                error.message\n            ));\n        }\n\n        bundle_response\n            .result\n            .ok_or_else(|| anyhow::anyhow!(\"No bundle ID returned\"))\n    }\n\n    /// Create tip transaction to Jito validators (LEGACY - SECURITY RISK)\n    ///\n    /// ?????? WARNING: This method creates a SEPARATE tip transaction, which is DANGEROUS!\n    /// Per Jito docs: \"Always make sure your Jito tip transaction is in the same\n    /// transaction that is running the MEV strategy\"\n    ///\n    /// RISK: Uncle blocks can cause bundle \"unbundling\" where tip executes but swap fails,\n    /// resulting in losing the tip amount with no profit.\n    ///\n    /// TODO: Refactor to include tip instruction INSIDE swap transaction:\n    /// 1. Build swap instructions (unsigned)\n    /// 2. Add tip instruction to same instruction list\n    /// 3. Sign as single transaction\n    /// 4. Submit in bundle\n    #","nrTokens":0,"nrLines":259,"files":[{"filePath":"src/jito_bundle_client.rs","startLine":241,"endLine":499},{"filePath":"clean_arb_bot/src/jito_bundle_client.rs","startLine":233,"endLine":467}]}},{"DuplicationClone":{"cloneLines":");\n\n        Ok(estimated_output)\n    }\n\n    /// Calculate slippage percentage\n    pub fn calculate_slippage(expected: u64, minimum: u64) -> f64 {\n        if expected == 0 {\n            return 0.0;\n        }\n        let difference = expected.saturating_sub(minimum) as f64;\n        (difference / expected as f64) * 100.0\n    }\n\n    /// Validate swap parameters\n    pub fn validate_swap_params(&self, params: &SwapParams) -> Result<()> {\n        if params.amount_in == 0 {\n            return Err(anyhow::anyhow!(\"Amount in cannot be zero\"));\n        }\n\n        if params.minimum_amount_out == 0 {\n            return Err(anyhow::anyhow!(\"Minimum amount out cannot be zero\"));\n        }\n\n        if params.minimum_amount_out > params.amount_in * 10 {\n            return Err(anyhow::anyhow!(\n                \"Minimum amount out suspiciously high ({}x input). Check parameters.\",\n                params.minimum_amount_out / params.amount_in\n            ));\n        }\n\n        let slippage = Self::calculate_slippage(params.amount_in, params.minimum_amount_out);\n        if slippage > 50.0 {\n            warn!(\"?????? High slippage tolerance: {:.2}%\", slippage);\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_slippage_calculation() {\n        assert_eq!(OrcaSwapBuilder","nrTokens":0,"nrLines":47,"files":[{"filePath":"clean_arb_bot/src/orca.rs","startLine":495,"endLine":541},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":446,"endLine":492}]}},{"DuplicationClone":{"cloneLines":");\n\n    // Build instruction data\n    let swap_data = SwapInstructionData {\n        amount_in: position_size_lamports,\n        min_amount_out,\n    };\n\n    // Meteora swap discriminator (from IDL) - this is the instruction selector\n    // For swap instruction, discriminator is typically the first 8 bytes of SHA256(\"global:swap\")\n    let mut data = vec![0xf8, 0xc6, 0x9e, 0x91, 0xe1, 0x75, 0x87, 0xc8]; // swap discriminator\n    data.extend_from_slice(&swap_data.try_to_vec()?);\n\n    // Build accounts array for swap instruction (OFFICIAL lb_clmm SDK order)\n    // Reference: lb_clmm-0.1.1/src/instructions/swap.rs\n    let accounts = vec![\n        // Core accounts\n        AccountMeta::new(lb_pair, false), // 0. lb_pair\n        // Note: bin_array_bitmap_extension is optional, skip for now\n        AccountMeta::new(reserve_x, false), // 1. reserve_x\n        AccountMeta::new(reserve_y, false), // 2. reserve_y\n        // User token accounts (in/out depend on swap direction)\n        AccountMeta::new(\n            if swap_for_y {\n                user_token_x\n            } else {\n                user_token_y\n            },\n            false,","nrTokens":0,"nrLines":29,"files":[{"filePath":"src/meteora_swap.rs","startLine":111,"endLine":139},{"filePath":"clean_arb_bot/src/meteora_swap.rs","startLine":115,"endLine":138}]}},{"DuplicationClone":{"cloneLines":", attempt, delay_ms, e);\n                    std::thread::sleep(Duration::from_millis(delay_ms));\n                }\n            }\n        }\n\n        self.record_failure();  // CYCLE-5: Increment on final failure\n        Err(anyhow::anyhow!(\"Failed to fetch account data after retries\"","nrTokens":0,"nrLines":8,"files":[{"filePath":"clean_arb_bot/src/rpc_client.rs","startLine":244,"endLine":251},{"filePath":"clean_arb_bot/src/rpc_client.rs","startLine":117,"endLine":124}]}},{"DuplicationClone":{"cloneLines":"// Cached blockhash for fast transaction building\n//\n// Maintains a fresh blockhash in memory, updated every 400ms by background task.\n// This eliminates the 50-70ms RPC latency per transaction build.\n\nuse anyhow::Result;\nuse solana_sdk::hash::Hash;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse tokio::sync::RwLock;\nuse tracing::{debug, info, warn};\n\nuse crate::rpc_client::SolanaRpcClient;\n\n/// Cached blockhash with timestamp\n#[derive(Clone)]\npub struct CachedBlockhash {\n    pub hash: Hash,\n    pub fetched_at: Instant,\n}\n\n/// Shared cached blockhash wrapped in Arc<RwLock> for thread-safe access\npub type SharedCachedBlockhash = Arc<RwLock<Option<CachedBlockhash>>>;\n\n/// Spawn background task to refresh blockhash every 400ms\n///\n/// Solana blockhashes are valid for ~60 seconds, refreshing every 400ms\n/// ensures we always have a fresh one (<1 second old).\n///\n/// Benefits:\n/// - Save 50-70ms per transaction build (no RPC call)\n/// - Transactions can be built instantly\n/// - Background task handles failures gracefully\npub fn spawn_blockhash_refresher(rpc_client: Arc<SolanaRpcClient>)","nrTokens":0,"nrLines":34,"files":[{"filePath":"src/cached_blockhash.rs","startLine":1,"endLine":34},{"filePath":"clean_arb_bot/src/cached_blockhash.rs","startLine":1,"endLine":35}]}},{"DuplicationClone":{"cloneLines":") {\n            return Err(anyhow::anyhow!(\n                \"Invalid wallet private key: contains non-base58 characters\"\n            ));\n        }\n\n        Ok(())\n    }\n\n    /// Load configuration from environment variables\n    ///\n    /// # Returns\n    /// * `Ok(Config)` if all required variables are valid\n    /// * `Err` if any validation fails\n    ///\n    /// # Environment Variables\n    /// - `SHREDSTREAM_SERVICE_URL`: ShredStream price feed URL (default: http://localhost:8080)\n    /// - `SOLANA_RPC_URL`: Solana RPC endpoint (optional)\n    /// - `WALLET_PRIVATE_KEY`: Base58-encoded private key (optional)\n    /// - `CAPITAL_SOL`: Total trading capital (default: 2.0 SOL)\n    /// - `MAX_POSITION_SIZE_SOL`: Max position per trade (default: 0.5 SOL)\n    /// - `MIN_PROFIT_MARGIN_MULTIPLIER`: Profit margin multiplier (default: 2.0)\n    /// - `MIN_SPREAD_PERCENTAGE`: Minimum spread to consider (default: 0.3%)\n    /// - `MAX_DAILY_TRADES`: Daily trade limit (default: 200)\n    /// - `DAILY_LOSS_LIMIT_SOL`: Max daily loss (default: 0.5 SOL)\n    /// - `MAX_CONSECUTIVE_FAILURES`: Failure threshold (default: 100)\n    /// - `ENABLE_REAL_TRADING`: Enable live trading (default: false)\n    /// - `PAPER_TRADING`: Paper trading mode (default: true)\n    /// - `JUPITER_API_KEY`: Jupiter API key (optional)\n    ///\n    /// # Security\n    /// - All URLs are validated for proper format\n    /// - Private keys are validated for base58 format\n    /// - Injection attacks are prevented\n    pub fn from_env() -> Result<Self> {\n        // Load .env file\n        dotenvy::dotenv().ok();\n\n        // Load and validate ShredStream URL\n        let shredstream_url = env::var(\"SHREDSTREAM_SERVICE_URL\")\n            .unwrap_or_else(|_| \"http://localhost:8080\".to_string());\n        Self::validate_url(&shredstream_url, \"SHREDSTREAM_SERVICE_URL\")?;\n\n        // Load and validate Solana RPC URL if provided\n        let solana_rpc_url = if let Ok(url) = env::var(\"SOLANA_RPC_URL\") {\n            Self::validate_url(&url, \"SOLANA_RPC_URL\")?;\n            Some(url)\n        } else {\n            None\n        };\n\n        // Load and validate wallet private key if provided\n        let wallet_private_key = if let Ok(key) = env::var(\"WALLET_PRIVATE_KEY\") {\n            Self::validate_private_key(&key)?;\n            Some(key)\n        } else {\n            None\n        };\n\n        let config = Self {\n            shredstream_url,\n\n            solana_rpc_url,\n\n            capital_sol: env::var(\"CAPITAL_SOL\")\n                .unwrap_or_else(|_| \"2.0\".to_string())\n                .parse()\n                .context(\"Failed to parse CAPITAL_SOL: must be a valid number\")?,\n\n            max_position_size_sol: env::var(\"MAX_POSITION_SIZE_SOL\")\n                .unwrap_or_else(|_| \"0.5\".to_string())\n                .parse()\n                .context(\"Failed to parse MAX_POSITION_SIZE_SOL: must be a valid number\")?,\n\n            min_profit_margin_multiplier: env::var(\"MIN_PROFIT_MARGIN_MULTIPLIER\")\n                .unwrap_or_else(|_| \"2.0\".to_string()) // Default: 2x fees (100% margin)\n                .parse()\n                .context(\"Failed to parse MIN_PROFIT_MARGIN_MULTIPLIER: must be a valid number\")?,\n\n            min_spread_percentage: env::var(\"MIN_SPREAD_PERCENTAGE\")\n                .unwrap_or_else(|_| \"0.3\".to_string()) // HIGH FIX: 0.3% - realistic for cross-DEX arbitrage\n                .parse()\n                .context(\"Failed to parse MIN_SPREAD_PERCENTAGE: must be a valid number\")?,\n\n            max_daily_trades: env::var(\"MAX_DAILY_TRADES\")\n                .unwrap_or_else(|_| \"200\".to_string())\n                .parse()\n                .context(\"Failed to parse MAX_DAILY_TRADES: must be a valid integer\")?,\n\n            daily_loss_limit_sol: env::var(\"DAILY_LOSS_LIMIT_SOL\")\n                .unwrap_or_else(|_| \"0.5\".to_string())\n                .parse()\n                .context(\"Failed to parse DAILY_LOSS_LIMIT_SOL: must be a valid number\")?,\n\n            max_consecutive_failures: env::var(\"MAX_CONSECUTIVE_FAILURES\")\n                .unwrap_or_else(|_| \"100\".to_string()) // Increased for market chaos - keep running!\n                .parse()\n                .context(\"Failed to parse MAX_CONSECUTIVE_FAILURES: must be a valid integer\")?,\n\n            enable_real_trading: env::var(\"ENABLE_REAL_TRADING\")\n                .unwrap_or_else(|_| \"false\".to_string())\n                .to_lowercase()\n                == \"true\",\n\n            paper_trading: env::var(\"PAPER_TRADING\")\n                .unwrap_or_else(|_| \"true\".to_string())\n                .to_lowercase()\n                == \"true\",\n\n            wallet_private_key,\n\n            jupiter_api_key: env::var(\"JUPITER_API_KEY\").ok(),\n        };\n\n        // MEDIUM FIX: Validate config parameters\n        config.validate()?;\n\n        Ok(config)\n    }\n\n    /// Validate configuration parameters\n    /// MEDIUM FIX: Ensure all config values are sensible\n    fn validate(&self) -> Result<()> {\n        // Validate capital is positive\n        if self.capital_sol <= 0.0 {\n            return Err(anyhow::anyhow!(\n                \"Invalid capital_sol: {} (must be > 0)\",\n                self.capital_sol\n            ));\n        }\n\n        // Validate max position size doesn't exceed capital\n        if self.max_position_size_sol > self.capital_sol {\n            return Err(anyhow::anyhow!(\n                \"Invalid max_position_size_sol: {} exceeds capital_sol: {}\",\n                self.max_position_size_sol,\n                self.capital_sol\n            ));\n        }\n\n        // Validate profit margin multiplier is reasonable\n        if self.min_profit_margin_multiplier < 1.0 {\n            return Err(anyhow::anyhow!(\n                \"Invalid min_profit_margin_multiplier: {} (must be >= 1.0 for positive margin)\",\n                self.min_profit_margin_multiplier\n            ));\n        }\n        if self.min_profit_margin_multiplier > 10.0 {\n            return Err(anyhow::anyhow!(\n                \"Invalid min_profit_margin_multiplier: {} (> 10.0 is too conservative, bot won't find trades)\",\n                self.min_profit_margin_multiplier\n            ));\n        }\n\n        // Validate min spread (allow 0 for dynamic calculation)\n        // NOTE: min_spread_percentage is DEPRECATED - now calculated dynamically\n        // Keeping field for backward compatibility, but 0 is allowed\n        if self.min_spread_percentage < 0.0 {\n            return Err(anyhow::anyhow!(\n                \"Invalid min_spread_percentage: {} (must be >= 0, or 0 for dynamic)\",\n                self.min_spread_percentage\n            ));\n        }\n\n        // Validate max daily trades is reasonable\n        if self.max_daily_trades == 0 {\n            return Err(anyhow::anyhow!(\n                \"Invalid max_daily_trades: 0 (bot would do nothing)\"\n            ));\n        }\n\n        // Validate all float values are finite\n        if !self.capital_sol.is_finite() {\n            return Err(anyhow::anyhow!(\"capital_sol must be finite\"));\n        }\n        if !self.max_position_size_sol.is_finite() {\n            return Err(anyhow::anyhow!(\"max_position_size_sol must be finite\"));\n        }\n        if !self.min_profit_margin_multiplier.is_finite() {\n            return Err(anyhow::anyhow!(\n                \"min_profit_margin_multiplier must be finite\"\n            ));\n        }\n        if !self.min_spread_percentage.is_finite() {\n            return Err(anyhow::anyhow!(\"min_spread_percentage must be finite\"));\n        }\n        if !self.daily_loss_limit_sol.is_finite() {\n            return Err(anyhow::anyhow!(\"daily_loss_limit_sol must be finite\"));\n        }\n\n        Ok(())\n    }\n}","nrTokens":0,"nrLines":193,"files":[{"filePath":"src/config.rs","startLine":158,"endLine":350},{"filePath":"clean_arb_bot/src/config.rs","startLine":153,"endLine":341}]}},{"DuplicationClone":{"cloneLines":"let (user_token_in, user_token_out) = if swap_params.swap_a_to_b {\n            // Swapping token A to token B\n            (\n                self.get_associated_token_address(user_pubkey, &pool_info.token_a_mint),\n                self.get_associated_token_address(user_pubkey, &pool_info.token_b_mint),\n            )\n        } else {\n            // Swapping token B to token A\n            (\n                self.get_associated_token_address(user_pubkey, &pool_info.token_b_mint),\n                self.get_associated_token_address(user_pubkey, &pool_info.token_a_mint),\n            )\n        };\n\n        debug!(\"User token in: {}\", user_token_in);\n        debug!(\"User token out: {}\", user_token_out);\n\n        // FIX 2: Auto-create token accounts if they don't exist","nrTokens":0,"nrLines":18,"files":[{"filePath":"clean_arb_bot/src/meteora.rs","startLine":173,"endLine":190},{"filePath":"clean_arb_bot/src/orca.rs","startLine":171,"endLine":213}]}},{"DuplicationClone":{"cloneLines":"};\nuse solana_sdk::pubkey::Pubkey;\nuse std::collections::HashMap;\nuse std::sync::{Arc, RwLock};\nuse std::time::{Duration, Instant};\nuse tokio","nrTokens":0,"nrLines":6,"files":[{"filePath":"src/pool_registry.rs","startLine":16,"endLine":21},{"filePath":"clean_arb_bot/src/pool_registry.rs","startLine":14,"endLine":19}]}},{"DuplicationClone":{"cloneLines":"// Get pool info for token mints and reserves\n        let pool_info = self.pool_registry\n            .get_pool(pool_short_id)\n            .ok_or_else(|| anyhow::anyhow!(\n                \"Pool {} resolved but info not cached. This shouldn't happen.\",\n                pool_short_id\n            ))?;\n\n        // Step 2: Fetch pool state from blockchain\n        let pool_state = self.fetch_pool_state(&pool_address)\n            .context(\"Failed to fetch pool state\")?;\n\n        debug!(\"??? Got pool state ({} bytes)\", pool_state.len());\n\n        // Step 3: Determine token accounts","nrTokens":0,"nrLines":15,"files":[{"filePath":"clean_arb_bot/src/meteora.rs","startLine":158,"endLine":172},{"filePath":"clean_arb_bot/src/orca.rs","startLine":110,"endLine":154}]}},{"DuplicationClone":{"cloneLines":"// Raydium swap instruction builder (supports all Raydium variants)\n//\n// Raydium is one of Solana's leading DEXes with multiple pool types:\n// - AMM V4: Main constant product AMM (675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8)\n// - CLMM: Concentrated liquidity (CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK)\n// - CPMM: Constant product (CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C)\n// - Stable: Stable swap pools (5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h)\n//\n// All variants share similar instruction format\n\nuse anyhow::{Context, Result};\nuse solana_sdk::{\n    instruction::{AccountMeta, Instruction},\n    pubkey::Pubkey,\n    system_program,\n};\nuse std::sync::Arc;\nuse tracing::{debug, info, warn};\n\nuse crate::pool_registry","nrTokens":0,"nrLines":20,"files":[{"filePath":"src/raydium.rs","startLine":1,"endLine":20},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":1,"endLine":20}]}},{"DuplicationClone":{"cloneLines":"::calculate_slippage(100, 100), 0.0);\n    }\n\n    #[test]\n    fn test_swap_params_validation() {\n        let rpc_url = \"https://api.mainnet-beta.solana.com\".to_string();\n        let rpc_client = Arc::new(SolanaRpcClient::new(rpc_url));\n        let pool_registry = Arc::new(PoolRegistry::new(rpc_client.clone()));\n        let builder = OrcaSwapBuilder","nrTokens":0,"nrLines":9,"files":[{"filePath":"clean_arb_bot/src/orca.rs","startLine":543,"endLine":551},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":494,"endLine":502}]}},{"DuplicationClone":{"cloneLines":")?;\n\n    // 9. JupSOL-SOL\n    pool_registry.register_pool(\n        \"bNcdL9Hy\".to_string(),\n        PoolInfo {\n            full_address: \"bNcdL9Hy85c9qb4hRavAUFtJUiyRPh3u96jerFqZQq6\".parse()?,\n            dex_type: DexType::MeteoraDammV2,\n            token_a_mint: \"jupSoLaHXQiZZTSfEWMTRRgpnyFm8f6sZdosWBjx93v\".parse()?, // jupSOL\n            token_b_mint: \"So11111111111111111111111111111111111111112\".parse()?, // SOL\n            reserve_a: \"2eF8kcFF6musyQQMckCDriXpirZW6vocJeh6q1noXcNW\".parse()?,\n            reserve_b: \"HTeD5fFp1oCvnNioZFQgXAfuRDzHWpDQS5y7NvsopKXN\".parse()?,\n        },","nrTokens":0,"nrLines":13,"files":[{"filePath":"src/pool_population.rs","startLine":132,"endLine":144},{"filePath":"clean_arb_bot/src/pool_population.rs","startLine":132,"endLine":145}]}},{"DuplicationClone":{"cloneLines":"let current_endpoint = {\n            let index = *self.current_endpoint_index.lock().unwrap();\n            let endpoints = self.endpoints.lock().unwrap();\n            endpoints[index].clone()\n        };\n\n        let response","nrTokens":0,"nrLines":7,"files":[{"filePath":"clean_arb_bot/src/jito_bundle_client.rs","startLine":678,"endLine":684},{"filePath":"clean_arb_bot/src/jito_bundle_client.rs","startLine":409,"endLine":415}]}},{"DuplicationClone":{"cloneLines":")?;\n\n    // 11. PUMP-SOL\n    pool_registry.register_pool(\n        \"HbjYfcWZ\".to_string(),\n        PoolInfo {\n            full_address: \"HbjYfcWZBjCBYTJpZkLGxqArVmZVu3mQcRudb6Wg1sVh\".parse()?,\n            dex_type: DexType::MeteoraDammV2,\n            token_a_mint: \"pumpCmXqMfrsAkQ5r49WcJnRayYRqmXz6ae8H7H9Dfn\".parse()?, // PUMP\n            token_b_mint: \"So11111111111111111111111111111111111111112\".parse()?, // SOL\n            reserve_a: \"5uXsebqNi3jDBvHvLJUuLqouUEHyQNDZcREHpLSwCZpM\".parse()?,\n            reserve_b: \"CD1RxU49jNwxD7LvRvrdWDNLpx5ZrJ7khMEzTNudk94s\".parse()?,\n        },","nrTokens":0,"nrLines":13,"files":[{"filePath":"src/pool_population.rs","startLine":158,"endLine":170},{"filePath":"clean_arb_bot/src/pool_population.rs","startLine":158,"endLine":171}]}},{"DuplicationClone":{"cloneLines":")\n                    .await\n                    {\n                        Ok(Ok(uuid)) => {\n                            info!(\"???? JITO bundle submitted via HTTP: {}\", uuid);\n                            Ok(uuid)\n                        }\n                        Ok(Err(e)) => Err(e),\n                        Err(_) => Err(anyhow::anyhow!(\"HTTP timeout\")),\n                    }\n                };\n\n                match bundle_id {\n                    Ok(bundle_id) => {\n                        info!(\"   Trade: {}\", request.description);\n                        info!(\"   Expected profit: {:.6} SOL\", request.expected_profit_sol);\n                        info!(\"   ???? Tip included INSIDE transaction (prevents unbundling)\");\n\n                        // HIGH FIX: Wait for bundle confirmation with 10s timeout\n                        // Solana-optimized: Most bundles confirm within 5-10 seconds\n                        // Check if bundle actually landed on-chain\n                        match tokio::time::timeout(\n                            Duration::from_secs(10),\n                            check_bundle_status(&http_clone, &bundle_id),","nrTokens":0,"nrLines":24,"files":[{"filePath":"src/jito_submitter.rs","startLine":207,"endLine":230},{"filePath":"clean_arb_bot/src/jito_submitter.rs","startLine":187,"endLine":209}]}},{"DuplicationClone":{"cloneLines":"Err(e) => {\n                // Check if it's \"account not found\" error vs other errors\n                if e.to_string().contains(\"AccountNotFound\") || e.to_string().contains(\"not found\")\n                {\n                    Ok(false)\n                } else {\n                    Err(anyhow::anyhow!(\"Error checking account existence: {}\", e))\n                }\n            }\n        }\n    }\n\n    /// Get account owner (program that owns this account)\n    pub fn get_account_owner(&self, pubkey: &Pubkey) -> Result<Pubkey> {\n        let account = self\n            .client\n            .get_account(pubkey)\n            .context(format!(\"Failed to fetch account {}\", pubkey))?;\n\n        Ok(account.owner)\n    }\n\n    /// Get transaction confirmation status\n    /// Returns Ok(Some(true)) if confirmed successfully, Ok(Some(false)) if failed, Ok(None) if pending\n    pub fn get_transaction_status(&self, signature: &Signature) -> Result<Option<bool>> {\n        // Poll blockchain for transaction status\n        match self.client.get_signature_status(signature) {\n            Ok(Some(result)) => {\n                // Transaction found in blockchain\n                match result {\n                    Ok(_) => Ok(Some(true)),   // Confirmed successfully\n                    Err(_) => Ok(Some(false)), // Failed on-chain\n                }\n            }\n            Ok(None) => Ok(None), // Not yet confirmed\n            Err(e) => Err(anyhow::anyhow!(\"Error checking transaction status: {}\", e)),\n        }\n    }\n\n    /// Get balance of an account (in lamports)\n    pub fn get_balance(&self, pubkey: &Pubkey) -> Result<u64> {\n        let balance = self\n            .client\n            .get_balance(pubkey)\n            .context(format!(\"Failed to get balance for {}\", pubkey))?;\n\n        Ok(balance)\n    }\n\n    /// Health check - verify RPC connection is working\n    pub fn health_check(&self) -> Result<bool> {\n        match self.client.get_health() {\n            Ok(_) => {\n                debug!(\"??? RPC health check passed\");\n                Ok(true)\n            }\n            Err(e) => {\n                warn!(\"??? RPC health check failed: {}\", e);\n                Ok(false)\n            }\n        }\n    }\n\n    /// Get current slot\n    pub fn get_slot(&self) -> Result<u64> {\n        let slot = self\n            .client\n            .get_slot()\n            .context(\"Failed to get current slot\")?;\n\n        Ok(slot)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_rpc_client_creation() {\n        let rpc_url = \"https://api.mainnet-beta.solana.com\".to_string();\n        let client = SolanaRpcClient::new(rpc_url);\n\n        // Just test that it creates without panicking\n        assert!(client.commitment.is_confirmed());\n    }\n\n    // Note: Most tests require a live RPC connection and are better suited for integration tests\n}","nrTokens":0,"nrLines":89,"files":[{"filePath":"src/rpc_client.rs","startLine":323,"endLine":411},{"filePath":"clean_arb_bot/src/rpc_client.rs","startLine":286,"endLine":370}]}},{"DuplicationClone":{"cloneLines":")),\n        )\n    }\n\n    /// Submit bundle with transactions that ALREADY include tip instructions (SECURE)\n    ///\n    /// **USE THIS METHOD** for production trading! This is the SAFE method that expects\n    /// transactions to already have JITO tip instructions included.\n    ///\n    /// Per Jito docs: \"Always make sure your Jito tip transaction is in the same\n    /// transaction that is running the MEV strategy\"\n    ///\n    /// # Arguments\n    /// * `transactions` - Transactions with tip instructions ALREADY included\n    ///\n    /// # Returns\n    /// Bundle ID from Jito\n    ///\n    /// # Example\n    /// ```ignore\n    /// // Build transaction with tip INSIDE\n    /// let tx = swap_executor.build_triangle_with_tip(\n    ///     leg1, leg2, leg3, wallet, tip_lamports, &tip_account\n    /// ).await?;\n    ///\n    /// // Submit securely (tip already in transaction)\n    /// let bundle_id = jito_client.submit_bundle_safe(vec![tx]).await?;\n    /// ```\n    pub async fn submit_bundle_safe(&self, transactions: Vec<Transaction>)","nrTokens":0,"nrLines":29,"files":[{"filePath":"src/jito_bundle_client.rs","startLine":213,"endLine":241},{"filePath":"clean_arb_bot/src/jito_bundle_client.rs","startLine":202,"endLine":232}]}},{"DuplicationClone":{"cloneLines":";\n\n/// Raydium swap instruction builder (supports all variants)\npub struct RaydiumSwapBuilder {\n    /// RPC client for fetching pool state\n    rpc_client: Arc<SolanaRpcClient>,\n    /// Pool registry for address resolution\n    pool_registry: Arc<PoolRegistry>,\n    /// Raydium AMM V4 program ID (default)\n    program_id: Pubkey,\n}\n\nimpl RaydiumSwapBuilder {\n    /// Raydium AMM V4 program ID (main AMM)\n    pub const AMM_V4_PROGRAM_ID: &'static str = \"675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8\";\n\n    /// Raydium CLMM program ID (concentrated liquidity)\n    pub const CLMM_PROGRAM_ID: &'static str = \"CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK\";\n\n    /// Raydium CPMM program ID (constant product)\n    pub const CPMM_PROGRAM_ID: &'static str = \"CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C\";\n\n    /// Raydium Stable program ID (stable swap)\n    pub const STABLE_PROGRAM_ID: &'static str = \"5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h\";\n\n    /// Create new Raydium swap builder\n    pub fn new(rpc_client: Arc<SolanaRpcClient>, pool_registry: Arc<PoolRegistry>)","nrTokens":0,"nrLines":27,"files":[{"filePath":"src/raydium.rs","startLine":22,"endLine":48},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":22,"endLine":50}]}},{"DuplicationClone":{"cloneLines":")\n                    };\n\n                // Estimate profit (simplified)\n                let gross_profit = capital_sol * (spread_percentage / 100.0);\n                let fees = capital_sol * 0.006; // Assume 0.3% per side\n                let net_profit = gross_profit - fees;\n\n                if net_profit >= min_profit_sol {\n                    opportunities.push(JupiterArbitrageOpportunity {\n                        token_mint: mint.clone(),\n                        shredstream_dex: shredstream_price.dex.clone(),\n                        shredstream_price: shredstream_price.price_sol,\n                        jupiter_price,\n                        spread_percentage,\n                        estimated_profit_sol: net_profit,\n                        direction: direction.to_string(),\n                    });\n                }\n            }\n        }\n    }\n\n    // Sort by profit\n    opportunities.sort_by(|a, b| {\n        b.estimated_profit_sol\n            .partial_cmp(&a.estimated_profit_sol)\n            .unwrap()\n    });\n\n    if !opportunities.is_empty() {\n        debug!(\n            \"???? Found {} Jupiter arbitrage opportunities\",\n            opportunities.len()\n        );\n    }\n\n    Ok(opportunities)\n}","nrTokens":0,"nrLines":39,"files":[{"filePath":"src/jupiter_prices.rs","startLine":197,"endLine":235},{"filePath":"clean_arb_bot/src/jupiter_prices.rs","startLine":182,"endLine":217}]}},{"DuplicationClone":{"cloneLines":");\n        }\n        info!(\"   Pool: {}\", pool_address);\n        info!(\"   Amount in: {} lamports\", swap_params.amount_in);\n        info!(\"   Min amount out: {} lamports\", swap_params.minimum_amount_out);\n        info!(\"   Direction: {}\", if swap_params.swap_a_to_b { \"A???B\" } else { \"B???A\" });\n\n        // CRITICAL FIX: For now, we need to return a single instruction\n        // But we should log a warning if we're dropping ATA creation instructions\n        if all_instructions.len() > 1 {\n            warn!(\"?????? CRITICAL: Dropping {} ATA creation instructions!\", all_instructions.len() - 1);\n            warn!(\"   This will cause transaction failures if ATAs don't exist\");\n            warn!(\"   TODO: Update function signature to return Vec<Instruction>\");\n        }\n\n        // Return the LAST instruction (the swap), not the first (which would be ATA creation)\n        Ok(all_instructions.into_iter().last().unwrap())\n    }\n\n    /// Fetch pool state from blockchain\n    fn fetch_pool_state(&self, pool_address: &Pubkey) -> Result<Vec<u8>> {\n        self.rpc_client\n            .get_account_data(pool_address)\n            .context(\"Failed to fetch Meteora pool state\"","nrTokens":0,"nrLines":24,"files":[{"filePath":"clean_arb_bot/src/meteora.rs","startLine":280,"endLine":303},{"filePath":"clean_arb_bot/src/orca.rs","startLine":260,"endLine":298}]}},{"DuplicationClone":{"cloneLines":")?;\n\n    // 3. SOL-USDC (High Liquidity #3)\n    pool_registry.register_pool(\n        \"BVRbyLjj\".to_string(),\n        PoolInfo {\n            full_address: \"BVRbyLjjfSBcoyiYFuxbgKYnWuiFaF9CSXEa5vdSZ9Hh\".parse()?,\n            dex_type: DexType::MeteoraDammV2,\n            token_a_mint: \"So11111111111111111111111111111111111111112\".parse()?, // SOL\n            token_b_mint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\".parse()?, // USDC\n            reserve_a: \"FMzVsENjscefpAtUJYBUTeJAYaKNfFQBHjTZE1AQRFYY\".parse()?,\n            reserve_b: \"7du3jFJK4rhf9JnZSQmhr6qPkgdQyJ88528qyxpYPPtL\".parse()?,\n        },","nrTokens":0,"nrLines":13,"files":[{"filePath":"src/pool_population.rs","startLine":54,"endLine":66},{"filePath":"clean_arb_bot/src/pool_population.rs","startLine":54,"endLine":67}]}},{"DuplicationClone":{"cloneLines":");\n\n        // Add compute budget to ensure tip transaction processes quickly\n        let compute_budget_instruction = ComputeBudgetInstruction::set_compute_unit_price(50_000);\n\n        let recent_blockhash = solana_sdk::hash::Hash::default(); // Should be fetched from RPC\n\n        let transaction = Transaction::new_signed_with_payer(\n            &[compute_budget_instruction, tip_instruction],\n            Some(&auth_keypair.pubkey()),\n            &[auth_keypair.as_ref()],\n            recent_blockhash,\n        );\n\n        Ok(transaction)\n    }\n\n    /// Build tip instruction (for inclusion in swap transaction)\n    ///\n    /// This is the SAFE method - returns an instruction to be included\n    /// in the same transaction as the swap, preventing unbundling risk.\n    ///\n    /// Usage:\n    /// ```ignore\n    /// let tip_instruction = jito_client.build_tip_instruction(10_000, tip_account);\n    /// let swap_instructions = vec![/* swap instructions */];\n    /// let all_instructions = vec![swap_instructions, vec![tip_instruction]].concat();\n    /// let transaction = Transaction::new_signed_with_payer(\n    ///     &all_instructions,\n    ///     Some(&wallet.pubkey()),\n    ///     &[&wallet],\n    ///     recent_blockhash,\n    /// );\n    /// ```\n    pub fn build_tip_instruction(\n        &self,\n        tip_lamports: u64,\n        tip_account: Pubkey,\n        payer: &Pubkey,\n    ) -> solana_sdk::instruction::Instruction {\n        system_instruction::transfer(payer, &tip_account, tip_lamports)\n    }\n\n    /// Calculate optimal tip based on expected profit and network conditions\n    ///\n    /// **PROFIT-BASED TIP STRATEGY**:\n    /// - Minimum: 100,000 lamports (0.0001 SOL) - 95th percentile per Jito dashboard\n    /// - Base: 10% of expected profit\n    /// - Adjusted: Based on success rate and confirmation times\n    /// - Maximum: 20% of expected profit (prevents overtipping)\n    ///\n    /// # Arguments\n    /// * `expected_profit_lamports` - Expected profit from the arbitrage (optional)\n    ///\n    /// # Returns\n    /// Optimal tip amount in lamports\n    pub fn calculate_optimal_tip_with_profit(&self, expected_profit_lamports: Option<u64>) -> u64 {\n        // Minimum tip: 100,000 lamports (0.0001 SOL) - 95th percentile\n        const MIN_TIP_LAMPORTS: u64 = 100_000;\n\n        // Maximum tip as percentage of profit\n        const MAX_TIP_PERCENTAGE: f64 = 0.20; // 20% max\n\n        // Base tip as percentage of profit\n        const BASE_TIP_PERCENTAGE: f64 = 0.10; // 10% base\n\n        // Calculate base tip from expected profit\n        let base_tip = if let Some(profit) = expected_profit_lamports {\n            if profit > 0 {\n                // 10% of expected profit, but at least minimum\n                let profit_based_tip = (profit as f64 * BASE_TIP_PERCENTAGE) as u64;\n                profit_based_tip.max(MIN_TIP_LAMPORTS)\n            } else {\n                MIN_TIP_LAMPORTS\n            }\n        } else {\n            MIN_TIP_LAMPORTS\n        };\n\n        // Adjust based on recent success rate and confirmation times\n        let (success_rate_multiplier, latency_multiplier) = if let Ok(metrics) = self.metrics.lock()\n        {\n            let success_rate_mult = if metrics.bundle_success_rate < 0.5 {\n                1.5 // Increase tip 50% if success rate is low\n            } else if metrics.bundle_success_rate > 0.9 {\n                0.9 // Reduce tip 10% if success rate is high\n            } else {\n                1.0\n            };\n\n            let latency_mult = if metrics.average_confirmation_time_ms > 5000.0 {\n                1.2 // Increase tip 20% if confirmations are slow\n            } else if metrics.average_confirmation_time_ms < 2000.0 {\n                0.95 // Slightly reduce tip if confirmations are fast\n            } else {\n                1.0\n            };\n\n            (success_rate_mult, latency_mult)\n        } else {\n            (1.0, 1.0) // Default multipliers if mutex is poisoned\n        };\n\n        let adjusted_tip = (base_tip as f64 * success_rate_multiplier * latency_multiplier) as u64;\n\n        // Cap tip at maximum percentage of profit (if profit provided)\n        let capped_tip = if let Some(profit) = expected_profit_lamports {\n            if profit > 0 {\n                let max_tip = (profit as f64 * MAX_TIP_PERCENTAGE) as u64;\n                adjusted_tip.min(max_tip)\n            } else {\n                adjusted_tip\n            }\n        } else {\n            adjusted_tip\n        };\n\n        // Ensure minimum tip (95th percentile)\n        let final_tip = capped_tip.max(MIN_TIP_LAMPORTS);\n\n        debug!(\n            \"???? Calculated optimal tip: {} lamports (0.{:06} SOL)\",\n            final_tip,\n            final_tip / 1000\n        );\n\n        if let Some(profit) = expected_profit_lamports {\n            let tip_percentage = (final_tip as f64 / profit as f64) * 100.0;\n            debug!(\n                \"   Expected profit: {} lamports, Tip: {:.1}% of profit\",\n                profit, tip_percentage\n            );\n        }\n\n        final_tip\n    }\n\n    /// Calculate optimal tip based on current network conditions (LEGACY)\n    ///\n    /// **DEPRECATED**: Use `calculate_optimal_tip_with_profit()` instead for profit-based tipping\n    #[deprecated(note = \"Use calculate_optimal_tip_with_profit() for better tip strategy\")]\n    fn calculate_optimal_tip(&self) -> u64 {\n        // Minimum tip: 100,000 lamports (0.0001 SOL) - 95th percentile\n        self.calculate_optimal_tip_with_profit(None)\n    }\n\n    /// Monitor bundle status and update metrics\n    async fn monitor_bundle_status(&self, bundle_id: String) -> Result<()> {\n        let start_time = Instant::now();\n        let mut check_interval = tokio::time::interval(Duration::from_millis(500));\n\n        for _ in 0..120 {\n            // Monitor for up to 60 seconds\n            check_interval.tick().await;\n\n            match self.get_bundle_status(&bundle_id).await {\n                Ok(status) => {\n                    match status.status.as_str() {\n                        \"Landed\" => {\n                            let confirmation_time = start_time.elapsed().as_millis() as f64;\n                            info!(\"??? Bundle landed in {}ms: {}\", confirmation_time, bundle_id);\n\n                            // Update metrics (would need mutable access)\n                            // self.metrics.bundles_landed += 1;\n                            // self.update_average_confirmation_time(confirmation_time);\n                            return Ok(());\n                        }\n                        \"Failed\" | \"Rejected\" => {\n                            error!(\"??? Bundle failed: {}\", bundle_id);\n                            // self.metrics.bundles_failed += 1;\n                            return Err(anyhow::anyhow!(\"Bundle failed: {}\", status.status));\n                        }\n                        \"Pending\" | \"Processing\" => {\n                            debug!(\"??? Bundle pending: {}\", bundle_id);\n                            continue;\n                        }\n                        _ => {\n                            warn!(\"Unknown bundle status: {}\", status.status);\n                            continue;\n                        }\n                    }\n                }\n                Err(e) => {\n                    debug!(\"Error checking bundle status: {}\", e);\n                    continue;\n                }\n            }\n        }\n\n        warn!(\"??? Bundle monitoring timeout: {}\", bundle_id);\n        Ok(())\n    }\n\n    /// Get bundle status from Jito\n    async fn get_bundle_status(&self, bundle_id: &str) -> Result<BundleStatus> {\n        use rand::Rng;\n        let request = serde_json::json!({\n            \"jsonrpc\": \"2.0\",\n            \"id\": rand::thread_rng().gen::<u64>(),\n            \"method\": \"getBundleStatuses\",\n            \"params\": [vec![bundle_id]]\n        });\n\n        // Get current endpoint\n        let current_endpoint = {\n            let index = *self.current_endpoint_index.lock().unwrap();\n            let endpoints = self.endpoints.lock().unwrap();\n            endpoints[index].clone()\n        };\n\n        let response = timeout(\n            Duration::from_secs(10),\n            self.client\n                .post(&format!(\"{}/api/v1/bundles\", current_endpoint))\n                .header(\"Content-Type\", \"application/json\")\n                .json(&request)\n                .send(),\n        )\n        .await??;\n\n        let json: serde_json::Value = response.json().await?;\n\n        if let Some(error) = json.get(\"error\") {\n            return Err(anyhow::anyhow!(\"Jito API error: {}\", error));\n        }\n\n        let result = json\n            .get(\"result\")\n            .and_then(|r| r.get(\"value\"))\n            .and_then(|v| v.as_array())\n            .and_then(|a| a.first())\n            .ok_or_else(|| anyhow::anyhow!(\"Invalid bundle status response\"))?;\n\n        let status: BundleStatus = serde_json::from_value(result.clone())?;\n        Ok(status)\n    }\n\n    /// Get bundle performance metrics\n    pub fn get_metrics(&self) -> JitoMetrics {\n        self.metrics\n            .lock()\n            .unwrap_or_else(|poisoned_guard| {\n                warn!(\"Mutex poisoned for metrics, returning default\");\n                poisoned_guard.into_inner()\n            })\n            .clone()\n    }\n\n    /// Reset metrics\n    pub fn reset_metrics(&self) {\n        if let Ok(mut metrics) = self.metrics.lock() {\n            *metrics = JitoMetrics::default();\n        }\n    }\n\n    /// Check if Jito service is available\n    pub async fn health_check(&self) -> Result<bool> {\n        let request = serde_json::json!({\n            \"jsonrpc\": \"2.0\",\n            \"id\": 1,\n            \"method\": \"getInflightBundleStatuses\",\n            \"params\": []\n        });\n\n        // Get current endpoint\n        let current_endpoint = {\n            let index = *self.current_endpoint_index.lock().unwrap();\n            let endpoints = self.endpoints.lock().unwrap();\n            endpoints[index].clone()\n        };\n\n        let response = timeout(\n            Duration::from_secs(5),\n            self.client\n                .post(&format!(\"{}/api/v1/bundles\", current_endpoint))\n                .header(\"Content-Type\", \"application/json\")\n                .json(&request)\n                .send(),\n        )\n        .await;\n\n        match response {\n            Ok(Ok(resp)) => Ok(resp.status().is_success()),\n            _ => Ok(false),\n        }\n    }\n}\n\nimpl Default for JitoMetrics {\n    fn default() -> Self {\n        Self {\n            bundles_submitted: 0,\n            bundles_landed: 0,\n            bundles_failed: 0,\n            average_confirmation_time_ms: 0.0,\n            tip_amounts_paid: Vec::new(),\n            bundle_success_rate: 0.0,\n        }\n    }\n}\n\nimpl JitoMetrics {\n    /// Calculate success rate\n    pub fn calculate_success_rate(&mut self) {\n        let total = self.bundles_submitted;\n        if total > 0 {\n            self.bundle_success_rate = self.bundles_landed as f64 / total as f64;\n        }\n    }\n\n    /// Update average confirmation time\n    pub fn update_average_confirmation_time(&mut self, new_time_ms: f64) {\n        let count = self.bundles_landed as f64;\n        if count == 1.0 {\n            self.average_confirmation_time_ms = new_time_ms;\n        } else {\n            self.average_confirmation_time_ms =\n                (self.average_confirmation_time_ms * (count - 1.0) + new_time_ms) / count;\n        }\n    }\n\n    /// Get average tip amount\n    pub fn average_tip_amount(&self) -> f64 {\n        if self.tip_amounts_paid.is_empty() {\n            0.0\n        } else {\n            self.tip_amounts_paid.iter().sum::<u64>() as f64 / self.tip_amounts_paid.len() as f64\n        }\n    }\n}\n\n/// Helper function to create MEV bundle for front-running protection\npub fn create_mev_bundle(\n    user_transactions: Vec<Transaction>,\n    _tip_lamports: u64,\n) -> Vec<Transaction> {\n    // In a real MEV bundle, you would:\n    // 1. Add a tip transaction at the beginning\n    // 2. Add your MEV transactions\n    // 3. Add user transactions at the end\n    // 4. Ensure all transactions are atomic\n\n    user_transactions // Simplified for now\n}","nrTokens":0,"nrLines":344,"files":[{"filePath":"src/jito_bundle_client.rs","startLine":513,"endLine":856},{"filePath":"clean_arb_bot/src/jito_bundle_client.rs","startLine":481,"endLine":814}]}},{"DuplicationClone":{"cloneLines":"swap_params,\n        )?;\n\n        // Combine setup instructions (ATA creation) with swap instruction\n        let mut all_instructions = setup_instructions;\n        all_instructions.push(instruction);\n\n        if all_instructions.len() > 1 {\n            info!(\"??? Built {} instructions ({} setup + 1 swap)\", all_instructions.len(), all_instructions.len() - 1);\n        } else {\n            info!(\"??? Built Meteora swap instruction\"","nrTokens":0,"nrLines":11,"files":[{"filePath":"clean_arb_bot/src/meteora.rs","startLine":270,"endLine":280},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":265,"endLine":275}]}},{"DuplicationClone":{"cloneLines":")?;\n\n    info!(\"??? Registered {} Meteora DLMM pools\", 11);\n    info!(\"   Including: SOL-USDC, JitoSOL-SOL, JUP-SOL, cbBTC-SOL, USDC-USDT, and more\");\n    info!(\"   All pools have high liquidity and active trading\");\n\n    Ok(())\n}\n\n/// Attempt to resolve pool address from ShredStream service\n///\n/// This makes an HTTP request to the ShredStream service asking for the full address.\n/// Requires ShredStream service to be enhanced with this endpoint.\n#[allow(dead_code)]\npub async fn resolve_pool_from_shredstream(\n    shredstream_url: &str,\n    short_id: &str,\n) -> Result<Pubkey> {\n    let url = format!(\"{}/api/pool/{}\", shredstream_url, short_id);\n\n    info!(\"???? Querying ShredStream for pool: {}\", short_id);\n\n    let client = reqwest::Client::new();\n    let response = client\n        .get(&url)\n        .timeout(std::time::Duration::from_secs(5))\n        .send()\n        .await?;\n\n    if response.status().is_success() {\n        let full_address: String = response.json().await?;\n        info!(\"??? Resolved {} ??? {}\", short_id, full_address);\n        Ok(full_address.parse()?)\n    } else {\n        Err(anyhow::anyhow!(\n            \"ShredStream service returned error {} for pool {}\",\n            response.status(),\n            short_id\n        ))\n    }\n}\n\n/// Query Meteora API for all DLMM pools\n///\n/// This can be used to populate the registry dynamically.\n/// Run this once and cache the results.\n#[allow(dead_code)]\npub async fn fetch_meteora_pools() -> Result<Vec<(String, Pubkey)>> {\n    info!(\"???? Fetching all Meteora DLMM pools from API...\");\n\n    // Meteora API endpoint (example - verify actual endpoint)\n    let url = \"https://dlmm-api.meteora.ag/pair/all\";\n\n    let client = reqwest::Client::new();\n    let response = client\n        .get(url)\n        .timeout(std::time::Duration::from_secs(30))\n        .send()\n        .await?;\n\n    if !response.status().is_success() {\n        return Err(anyhow::anyhow!(\n            \"Meteora API returned error: {}\",\n            response.status()\n        ));\n    }\n\n    // Parse response and extract pool addresses\n    // Format depends on Meteora API response structure\n    warn!(\"?????? Meteora API parsing not yet implemented\");\n    warn!(\"   Check Meteora documentation for API format\");\n\n    Ok(Vec::new())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_populate_compiles() {\n        // Just verify the function compiles\n        // Can't actually test without real pool data\n    }\n}","nrTokens":0,"nrLines":85,"files":[{"filePath":"src/pool_population.rs","startLine":171,"endLine":255},{"filePath":"clean_arb_bot/src/pool_population.rs","startLine":171,"endLine":255}]}},{"DuplicationClone":{"cloneLines":";\n\n/// Type of DEX\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub enum DexType {\n    // Meteora variants\n    MeteoraDammV1, // Meteora DAMM V1 (older version)\n    MeteoraDammV2, // Meteora DAMM V2 (newer version)\n    MeteoraDlmm,   // Meteora Dynamic Liquidity Market Maker\n\n    // Orca variants\n    OrcaWhirlpools, // Orca Whirlpools (concentrated liquidity)\n    OrcaLegacy,     // Orca Legacy (older AMM)\n\n    // Raydium variants (all use same program family)\n    RaydiumAmmV4,  // Raydium AMM V4 (main AMM)\n    RaydiumClmm,   // Raydium Concentrated Liquidity\n    RaydiumCpmm,   // Raydium Constant Product Market Maker\n    RaydiumStable, // Raydium Stable Swap\n\n    // Other DEXes\n    PumpSwap, // Post-migration Pump.fun tokens\n    Jupiter,  // Jupiter Aggregator\n    Serum,    // Serum Order Book DEX\n    Aldrin,   // Aldrin AMM\n    Saros,    // Saros AMM\n    Crema,    // Crema Finance\n    Cropper,  // Cropper Finance\n    Lifinity, // Lifinity AMM\n    Fluxbeam, // Fluxbeam DEX\n    HumidiFi, // Dark pool/proprietary AMM - highest volume DEX on Solana\n}\n\n/// Pool information\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PoolInfo {\n    pub full_address: Pubkey,\n    pub dex_type: DexType,\n    pub token_a_mint: Pubkey,\n    pub token_b_mint: Pubkey,\n    pub reserve_a: Pubkey,\n    pub reserve_b: Pubkey,\n}\n\n/// Swap parameters\n#[derive(Debug, Clone)]\npub struct SwapParams {\n    pub amount_in: u64,\n    pub minimum_amount_out: u64,\n    pub expected_amount_out: Option<u64>, // Expected output for slippage validation\n    pub swap_a_to_b: bool,                // true = A???B, false = B???A\n}\n\nimpl DexType {\n    /// Parse from DEX string like \"Meteora_DAMM_V2_81vA2wJx\"\n    pub fn from_dex_string(dex_str: &str) -> anyhow::Result<Self> {\n        // Meteora variants\n        if dex_str.starts_with(\"Meteora_DAMM_V1\") {\n            Ok(DexType::MeteoraDammV1)\n        } else if dex_str.starts_with(\"Meteora_DAMM_V2\") || dex_str.starts_with(\"Meteora_Pools\") {\n            Ok(DexType::MeteoraDammV2)\n        } else if dex_str.starts_with(\"Meteora_DLMM\") {\n            Ok(DexType::MeteoraDlmm)\n\n        // Orca variants\n        } else if dex_str.starts_with(\"Orca_Whirlpools\") {\n            Ok(DexType::OrcaWhirlpools)\n        } else if dex_str.starts_with(\"Orca_Legacy\") {\n            Ok(DexType::OrcaLegacy)\n\n        // Raydium variants\n        } else if dex_str.starts_with(\"Raydium_AMM_V4\") || dex_str.starts_with(\"Raydium_AMM\") {\n            Ok(DexType::RaydiumAmmV4)\n        } else if dex_str.starts_with(\"Raydium_CLMM\") {\n            Ok(DexType::RaydiumClmm)\n        } else if dex_str.starts_with(\"Raydium_CPMM\") {\n            Ok(DexType::RaydiumCpmm)\n        } else if dex_str.starts_with(\"Raydium_Stable\") {\n            Ok(DexType::RaydiumStable)\n\n        // Other DEXes\n        } else if dex_str.starts_with(\"PumpSwap\") || dex_str.starts_with(\"Pump_Swap\") {\n            Ok(DexType::PumpSwap)\n        } else if dex_str.starts_with(\"Jupiter\") {\n            Ok(DexType::Jupiter)\n        } else if dex_str.starts_with(\"Serum\") {\n            Ok(DexType::Serum)\n        } else if dex_str.starts_with(\"Aldrin\") {\n            Ok(DexType::Aldrin)\n        } else if dex_str.starts_with(\"Saros\") {\n            Ok(DexType::Saros)\n        } else if dex_str.starts_with(\"Crema\") {\n            Ok(DexType::Crema)\n        } else if dex_str.starts_with(\"Cropper\") {\n            Ok(DexType::Cropper)\n        } else if dex_str.starts_with(\"Lifinity\") {\n            Ok(DexType::Lifinity)\n        } else if dex_str.starts_with(\"Fluxbeam\") {\n            Ok(DexType::Fluxbeam)\n        } else if dex_str.starts_with(\"HumidiFi\") || dex_str.starts_with(\"Humidifi\") {\n            Ok(DexType::HumidiFi)\n        } else {\n            Err(anyhow::anyhow!(\"Unknown DEX type: {}\", dex_str))\n        }\n    }\n}\n\n/// Extract short pool ID from DEX string\npub fn extract_pool_id(dex_str: &str) -> anyhow::Result<String> {\n    let parts: Vec<&str> = dex_str.split('_').collect();\n    parts\n        .last()\n        .map(|s| s.to_string())\n        .ok_or_else(|| anyhow::anyhow!(\"Invalid DEX string format: {}\", dex_str))\n}","nrTokens":0,"nrLines":115,"files":[{"filePath":"src/types.rs","startLine":4,"endLine":118},{"filePath":"clean_arb_bot/src/types.rs","startLine":4,"endLine":118}]}},{"DuplicationClone":{"cloneLines":")\n                        .await\n                        {\n                            Ok(Ok(true)) => {\n                                info!(\"??? Bundle landed successfully!\");\n                                let mut s = stats_clone.lock().await;\n                                s.total_submitted += 1;\n                            }\n                            Ok(Ok(false)) => {\n                                warn!(\"?????? Bundle submitted but NOT landed on-chain\");\n                                let mut s = stats_clone.lock().await;\n                                s.total_failed += 1;\n                            }\n                            Ok(Err(e)) => {\n                                warn!(\"?????? Failed to check bundle status: {}\", e);\n                                // Count as submitted since we don't know status\n                                let mut s = stats_clone.lock().await;\n                                s.total_submitted += 1;\n                            }\n                            Err(_) => {\n                                warn!(\"?????? Bundle status check timeout (10s)\");\n                                let mut s = stats_clone.lock().await;\n                                s.total_submitted += 1;\n                            }\n                        }\n\n                        last_submit = Instant::now();\n                    }\n                    Err(e) => {\n                        // NO RETRY - arbitrage opportunities are time-sensitive\n                        // If we miss the first submission, price has likely moved\n                        // Better to move on to next fresh opportunity\n                        if e.to_string().contains(\"429\") {\n                            warn!(\"?????? 429 Rate Limit - Dropping trade (opportunity stale)\");\n                            let mut s = stats_clone.lock().await;\n                            s.rate_limited_429 += 1;\n                            s.total_failed += 1;\n                        } else {\n                            error!(\"??? JITO bundle submission FAILED permanently\");\n                            error!(\"   Error: {}\", e);\n                            error!(\"   Trade: {}\", request.description);\n                            error!(\"   Attempt: {}\", request.attempt);\n\n                            let mut s = stats_clone.lock().await;\n                            s.total_failed += 1;\n                        }\n                    }\n                }\n            }\n\n            warn!(\"?????? JITO submission queue stopped (channel closed)\");\n        });\n\n        Self {\n            queue_tx,\n            stats,\n            grpc_client,\n            http_client,\n        }\n    }\n\n    /// Submit bundle to queue (non-blocking)\n    ///\n    /// **SECURITY**: Transactions must have JITO tip ALREADY included inside them!\n    /// Use `SwapExecutor::build_triangle_with_tip()` to build transactions properly.\n    ///\n    /// Returns immediately, bundle will be submitted at next available slot\n    pub async fn submit(\n        &self,\n        transactions: Vec<Transaction>, // Must have tips INSIDE\n        description: String,\n        expected_profit_sol: f64,\n    ) -> Result<()> {\n        let request = BundleRequest {\n            transactions,\n            description: description.clone(),\n            expected_profit_sol,\n            attempt: 0,\n            queued_at: Instant::now(), // Timestamp for stale detection\n        };\n\n        // Update stats\n        {\n            let mut stats = self.stats.lock().await;\n            stats.total_queued += 1;\n            // Note: UnboundedSender doesn't expose queue length\n            // Queue depth is tracked in the receiver task\n        }\n\n        // CRITICAL FIX: Use try_send for bounded channel (not async)\n        match self.queue_tx.try_send(request) {\n            Ok(_) => {\n                debug!(\"???? Bundle queued: {}\", description);\n                Ok(())\n            }\n            Err(mpsc::error::TrySendError::Full(_)) => {\n                warn!(\"?????? Queue FULL - bundle dropped. System overloaded!\");\n                let mut stats = self.stats.lock().await;\n                stats.queue_full_drops += 1;\n                Err(anyhow::anyhow!(\"JITO queue full - bundle dropped\"))\n            }\n            Err(mpsc::error::TrySendError::Closed(_)) => {\n                Err(anyhow::anyhow!(\"JITO submission queue closed\"))\n            }\n        }\n    }\n\n    /// Get submission statistics\n    pub async fn get_stats(&self) -> SubmitterStats {\n        let stats = self.stats.lock().await;\n        SubmitterStats {\n            total_queued: stats.total_queued,\n            total_submitted: stats.total_submitted,\n            total_failed: stats.total_failed,\n            rate_limited_429: stats.rate_limited_429,\n            queue_depth: stats.queue_depth,\n            queue_full_drops: stats.queue_full_drops,\n        }\n    }\n\n    /// Log statistics (call periodically)\n    pub async fn log_stats(&self) {\n        let stats = self.get_stats().await;\n\n        info!(\"?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????\");\n        info!(\"???? JITO Submission Queue Stats:\");\n        info!(\"  ??? Total queued: {}\", stats.total_queued);\n        info!(\"  ??? Successfully submitted: {}\", stats.total_submitted);\n        info!(\"  ??? Failed permanently: {}\", stats.total_failed);\n        info!(\"  ??? 429 rate limits: {}\", stats.rate_limited_429);\n        info!(\"  ??? Current queue depth: {}\", stats.queue_depth);\n\n        if stats.total_queued > 0 {\n            let success_rate = (stats.total_submitted as f64 / stats.total_queued as f64) * 100.0;\n            info!(\"  ??? Success rate: {:.1}%\", success_rate);\n        }\n\n        info!(\"?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????\");\n    }\n}\n\n/// Helper function to check if JITO bundle landed on-chain\n///\n/// IMPLEMENTATION NOTE: JITO bundle status checking is removed in favor of\n/// transaction confirmation checking. Instead of checking bundle status,\n/// we rely on swap_executor's transaction confirmation logic which is more reliable.\n///\n/// This function now returns Ok(false) to be conservative and not report\n/// false successes. The actual success/failure is determined by checking\n/// if the transaction signature confirms on-chain.\n///\n/// Future enhancement: Implement proper JITO bundle status API if needed:\n/// - Use JITO's get_bundle_statuses RPC method\n/// - Check bundle.landed status\n/// - This would provide earlier failure detection before full confirmation\nasync fn check_bundle_status(\n    _jito_client: &Arc<JitoBundleClient>,\n    bundle_id: &str,\n) -> Result<bool> {\n    // REMOVED: Fake OK(true) return that was causing false success reports\n    //\n    // Instead, we return Ok(false) to be conservative.\n    // Real success/failure is determined by transaction confirmation,\n    // not bundle status (which we don't have API for yet).\n\n    warn!(\"?????? JITO bundle status check not implemented - relying on transaction confirmation\");\n    warn!(\"   Bundle ID: {}\", bundle_id);\n    warn!(\"   This is expected - transaction confirmation provides actual success status\");\n\n    // Conservative: return false since we cannot verify bundle landing\n    // Transaction confirmation will provide the actual success/failure status\n    Ok(false)\n}","nrTokens":0,"nrLines":173,"files":[{"filePath":"src/jito_submitter.rs","startLine":231,"endLine":403},{"filePath":"clean_arb_bot/src/jito_submitter.rs","startLine":209,"endLine":379}]}},{"DuplicationClone":{"cloneLines":"///\n    /// # Arguments\n    /// * `pool_short_id` - 8-char short pool ID from ShredStream\n    /// * `swap_params` - Swap parameters (amount_in, minimum_amount_out, direction)\n    /// * `user_pubkey` - User's wallet public key\n    ///\n    /// # Returns\n    /// Solana instruction for the swap\n    pub async fn build_swap_instruction(\n        &self,\n        pool_short_id: &str,\n        swap_params: &SwapParams,\n        user_pubkey: &Pubkey,\n    ) -> Result<Instruction> {\n        debug!(\"Building Meteora swap instruction for pool: {}\"","nrTokens":0,"nrLines":15,"files":[{"filePath":"clean_arb_bot/src/meteora.rs","startLine":60,"endLine":74},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":70,"endLine":84}]}},{"DuplicationClone":{"cloneLines":");\n\n        Ok(estimated_output)\n    }\n\n    /// Calculate slippage percentage\n    pub fn calculate_slippage(expected: u64, minimum: u64) -> f64 {\n        if expected == 0 {\n            return 0.0;\n        }\n        let difference = expected.saturating_sub(minimum) as f64;\n        (difference / expected as f64) * 100.0\n    }\n\n    /// Validate swap parameters\n    pub fn validate_swap_params(&self, params: &SwapParams) -> Result<()> {\n        if params.amount_in == 0 {\n            return Err(anyhow::anyhow!(\"Amount in cannot be zero\"));\n        }\n\n        if params.minimum_amount_out == 0 {\n            return Err(anyhow::anyhow!(\"Minimum amount out cannot be zero\"));\n        }\n\n        if params.minimum_amount_out > params.amount_in * 10 {\n            return Err(anyhow::anyhow!(\n                \"Minimum amount out suspiciously high ({}x input). Check parameters.\",\n                params.minimum_amount_out / params.amount_in\n            ));\n        }\n\n        let slippage = Self::calculate_slippage(params.amount_in, params.minimum_amount_out);\n        if slippage > 50.0 {\n            warn!(\"?????? High slippage tolerance: {:.2}%\", slippage);\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_slippage_calculation() {\n        assert_eq!(MeteoraSwapBuilder","nrTokens":0,"nrLines":47,"files":[{"filePath":"clean_arb_bot/src/meteora.rs","startLine":433,"endLine":479},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":446,"endLine":492}]}},{"DuplicationClone":{"cloneLines":")?;\n\n        // Step 2: Fetch pool state from blockchain\n        let pool_state = self\n            .fetch_pool_state(&pool_address)\n            .context(\"Failed to fetch pool state\")?;\n\n        debug!(\"??? Got pool state ({} bytes)\", pool_state.len());\n\n        // Step 3: Determine token accounts\n        let (user_token_in, user_token_out) = if swap_params.swap_a_to_b {\n            // Swapping token A to token B\n            (\n                self.get_associated_token_address(user_pubkey, &pool_info.token_a_mint),\n                self.get_associated_token_address(user_pubkey, &pool_info.token_b_mint),\n            )\n        } else {\n            // Swapping token B to token A\n            (\n                self.get_associated_token_address(user_pubkey, &pool_info.token_b_mint),\n                self.get_associated_token_address(user_pubkey, &pool_info.token_a_mint),\n            )\n        };\n\n        debug!(\"User token in: {}\", user_token_in);\n        debug!(\"User token out: {}\", user_token_out);\n\n        // FIX 2: Auto-create token accounts if they don't exist\n        // This prevents transaction failures and enables trading any token\n        let mut setup_instructions = Vec::new();\n\n        // CRITICAL FIX: Skip ATA creation for native SOL (system program)\n        // Native SOL doesn't use token accounts - it uses the wallet directly\n        let is_native_sol_in = if swap_params.swap_a_to_b {\n            pool_info.token_a_mint == solana_sdk::system_program::ID\n        } else {\n            pool_info.token_b_mint == solana_sdk::system_program::ID\n        };\n\n        if !is_native_sol_in && !self.rpc_client.account_exists(&user_token_in)? {\n            info!(\n                \"???? Creating associated token account for input token: {}\",\n                user_token_in\n            );\n            info!(\n                \"   Token mint: {}\",\n                if swap_params.swap_a_to_b {\n                    &pool_info.token_a_mint\n                } else {\n                    &pool_info.token_b_mint\n                }\n            );\n\n            let token_mint = if swap_params.swap_a_to_b {\n                &pool_info.token_a_mint\n            } else {\n                &pool_info.token_b_mint\n            };\n\n            // Create ATA instruction\n            let create_ata_ix =\n                spl_associated_token_account::instruction::create_associated_token_account(\n                    user_pubkey,      // Payer\n                    user_pubkey,      // Owner of new account\n                    token_mint,       // Token mint\n                    &spl_token::id(), // Token program ID\n                );\n\n            setup_instructions.push(create_ata_ix);\n            info!(\"??? ATA creation instruction added - account will be created in transaction\");\n        } else if is_native_sol_in {\n            debug!(\"?????? Skipping ATA creation for native SOL input\");\n        }\n\n        // CRITICAL FIX: Skip ATA creation for native SOL output too\n        let is_native_sol_out = if swap_params.swap_a_to_b {\n            pool_info.token_b_mint == solana_sdk::system_program::ID\n        } else {\n            pool_info.token_a_mint == solana_sdk::system_program::ID\n        };\n\n        if !is_native_sol_out && !self.rpc_client.account_exists(&user_token_out)? {\n            info!(\n                \"???? Creating associated token account for output token: {}\",\n                user_token_out\n            );\n            info!(\n                \"   Token mint: {}\",\n                if swap_params.swap_a_to_b {\n                    &pool_info.token_b_mint\n                } else {\n                    &pool_info.token_a_mint\n                }\n            );\n\n            let token_mint = if swap_params.swap_a_to_b {\n                &pool_info.token_b_mint\n            } else {\n                &pool_info.token_a_mint\n            };\n\n            // Create ATA instruction\n            let create_ata_ix =\n                spl_associated_token_account::instruction::create_associated_token_account(\n                    user_pubkey,      // Payer\n                    user_pubkey,      // Owner of new account\n                    token_mint,       // Token mint\n                    &spl_token::id(), // Token program ID\n                );\n\n            setup_instructions.push(create_ata_ix);\n            info!(\"??? ATA creation instruction added for output - account will be created in transaction\");\n        } else if is_native_sol_out {\n            debug!(\"?????? Skipping ATA creation for native SOL output\");\n        }\n\n        // Step 4: Build swap instruction using lb_clmm SDK\n        // Note: The actual lb_clmm SDK API will be used here once we verify the exact interface\n        // For now, creating a placeholder structure that matches typical Solana swap patterns\n\n        let instruction = self.build_meteora_swap_ix(\n            &pool_address,\n            user_pubkey,\n            &user_token_in,\n            &user_token_out,\n            &pool_info.reserve_a,\n            &pool_info.reserve_b,\n            &pool_info.token_a_mint, // NEW: token_x_mint\n            &pool_info.token_b_mint, // NEW: token_y_mint\n            swap_params,\n        )?;\n\n        // Combine setup instructions (ATA creation) with swap instruction\n        let mut all_instructions = setup_instructions;\n        all_instructions.push(instruction);\n\n        if all_instructions.len() > 1 {\n            info!(\n                \"??? Built {} instructions ({} setup + 1 swap)\",\n                all_instructions.len(),\n                all_instructions.len() - 1\n            );\n        } else {\n            info!(\"??? Built Meteora swap instruction\");\n        }\n        info!(\"   Pool: {}\", pool_address);\n        info!(\"   Amount in: {} lamports\", swap_params.amount_in);\n        info!(\n            \"   Min amount out: {} lamports\",\n            swap_params.minimum_amount_out\n        );\n        info!(\n            \"   Direction: {}\",\n            if swap_params.swap_a_to_b {\n                \"A???B\"\n            } else {\n                \"B???A\"\n            }\n        );\n\n        // CRITICAL FIX: For now, we need to return a single instruction\n        // But we should log a warning if we're dropping ATA creation instructions\n        if all_instructions.len() > 1 {\n            warn!(\n                \"?????? CRITICAL: Dropping {} ATA creation instructions!\",\n                all_instructions.len() - 1\n            );\n            warn!(\"   This will cause transaction failures if ATAs don't exist\");\n            warn!(\"   TODO: Update function signature to return Vec<Instruction>\");\n        }\n\n        // Return the LAST instruction (the swap), not the first (which would be ATA creation)\n        Ok(all_instructions.into_iter().last().unwrap())\n    }\n\n    /// Fetch pool state from blockchain\n    fn fetch_pool_state(&self, pool_address: &Pubkey) -> Result<Vec<u8>> {\n        self.rpc_client\n            .get_account_data(pool_address)\n            .context(\"Failed to fetch Meteora pool state\")\n    }\n\n    /// Get associated token account address for user\n    fn get_associated_token_address(&self, wallet: &Pubkey, mint: &Pubkey) -> Pubkey {\n        spl_associated_token_account::get_associated_token_address(wallet, mint)\n    }\n\n    /// Build the actual Meteora swap instruction\n    ///\n    /// This uses the Meteora DLMM program's swap instruction format\n    fn build_meteora_swap_ix(\n        &self,\n        pool: &Pubkey,\n        user: &Pubkey,\n        user_token_in: &Pubkey,\n        user_token_out: &Pubkey,\n        reserve_in: &Pubkey,\n        reserve_out: &Pubkey,\n        token_mint_a: &Pubkey, // NEW: Token X mint\n        token_mint_b: &Pubkey, // NEW: Token Y mint\n        swap_params: &SwapParams,\n    ) -> Result<Instruction> {\n        // Meteora DLMM swap instruction structure\n        // Reference: https://docs.meteora.ag/integration/dlmm-integration\n\n        // OFFICIAL Account list from lb_clmm-0.1.1/src/instructions/swap.rs:\n        // 0. [writable] lb_pair\n        // 1. [writable] reserve_x (reserve_in for A???B, reserve_out for B???A)\n        // 2. [writable] reserve_y (reserve_out for A???B, reserve_in for B???A)\n        // 3. [writable] user_token_in\n        // 4. [writable] user_token_out\n        // 5. [] token_x_mint\n        // 6. [] token_y_mint\n        // 7. [writable] oracle\n        // 8. [signer] user\n        // 9. [] token_x_program\n        // 10. [] token_y_program\n        // Note: bin_array_bitmap_extension and host_fee_in are optional, skipping\n\n        // Determine which reserve is X and which is Y based on swap direction\n        let (reserve_x, reserve_y) = if swap_params.swap_a_to_b {\n            (reserve_in, reserve_out)\n        } else {\n            (reserve_out, reserve_in)\n        };\n\n        // Derive oracle PDA (standard derivation for Meteora)\n        let (oracle, _) =\n            Pubkey::find_program_address(&[b\"oracle\", pool.as_ref()], &self.program_id)","nrTokens":0,"nrLines":229,"files":[{"filePath":"src/meteora.rs","startLine":189,"endLine":417},{"filePath":"clean_arb_bot/src/meteora.rs","startLine":164,"endLine":353}]}},{"DuplicationClone":{"cloneLines":"if self.pool_registry.is_pool_valid_cached(pool_short_id).await != Some(true) {\n                // Rare case: validate on-demand if not cached\n                warn!(\"?????? Pool {} not in cache, validating on-demand\", pool_short_id);\n                self.pool_registry.validate_pools_batch(&[pool_short_id.to_string()]).await?;\n\n                // Double-check after validation\n                if self.pool_registry.is_pool_valid_cached(pool_short_id).await != Some(true) {\n                    return Err(anyhow::anyhow!(\n                        \"?????? Ghost pool detected: {} (failed validation)\",\n                        pool_short_id\n                    ));\n                }\n            }\n        }","nrTokens":0,"nrLines":14,"files":[{"filePath":"clean_arb_bot/src/orca.rs","startLine":93,"endLine":106},{"filePath":"clean_arb_bot/src/raydium.rs","startLine":124,"endLine":138}]}},{"FileMetrics":{"filename":"clean_arb_bot/RECOMMENDED_CONFIG.env","complexity":null,"loc":89,"cloc":null,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":".github/workflows/codacy-analysis.yml","complexity":null,"loc":72,"cloc":6,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":".github/workflows/codacy-autofix.yml","complexity":null,"loc":101,"cloc":10,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"claw.md","complexity":null,"loc":232,"cloc":0,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/docs/current/MONITORING_GUIDE.md","complexity":null,"loc":366,"cloc":0,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/docs/current/GRPC_SUCCESS.md","complexity":null,"loc":191,"cloc":0,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/LOGGING_STANDARDS.md","complexity":null,"loc":206,"cloc":0,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/TEST_REPORT.md","complexity":null,"loc":311,"cloc":0,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"CLAUDE.md","complexity":null,"loc":91,"cloc":0,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/docs/current/DEX_IMPLEMENTATION_PLAN.md","complexity":null,"loc":215,"cloc":0,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/TODO.md","complexity":null,"loc":86,"cloc":0,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"README.md","complexity":null,"loc":51,"cloc":0,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/docs/current/HUMIDIFI_ENABLED.md","complexity":null,"loc":178,"cloc":0,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/docs/current/DEPLOYMENT_PLAN.md","complexity":null,"loc":174,"cloc":0,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/docs/current/VOLUME_FILTER_FINDINGS.md","complexity":null,"loc":213,"cloc":0,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/docs/current/AUTONOMOUS_TRADING_ACTIVE.md","complexity":null,"loc":232,"cloc":0,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/docs/current/JITO_GRPC_FINDINGS.md","complexity":null,"loc":218,"cloc":0,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/docs/current/REALISTIC_FILTERS_COMPLETE.md","complexity":null,"loc":199,"cloc":0,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/docs/current/LIVE_TRADING_GUIDE.md","complexity":null,"loc":191,"cloc":0,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/docs/current/CURRENT_STATUS_2025_10_07.md","complexity":null,"loc":352,"cloc":0,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/docs/current/PUMPSWAP_FIXED_2025_10_14.md","complexity":null,"loc":150,"cloc":0,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"src/jito_grpc_client.rs","complexity":23,"loc":204,"cloc":35,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":216,"value":2},{"line":204,"value":1},{"line":88,"value":2},{"line":107,"value":4},{"line":227,"value":6},{"line":74,"value":4},{"line":277,"value":2},{"line":44,"value":2}]}},{"FileMetrics":{"filename":"src/swap_executor.rs","complexity":75,"loc":570,"cloc":188,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":494,"value":10},{"line":824,"value":1},{"line":120,"value":1},{"line":57,"value":8},{"line":851,"value":1},{"line":250,"value":12},{"line":696,"value":2},{"line":690,"value":1},{"line":763,"value":1},{"line":634,"value":2},{"line":454,"value":2},{"line":771,"value":3},{"line":370,"value":6},{"line":792,"value":5},{"line":323,"value":6},{"line":137,"value":13},{"line":684,"value":1}]}},{"FileMetrics":{"filename":"src/orca.rs","complexity":46,"loc":396,"cloc":144,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":514,"value":4},{"line":384,"value":1},{"line":62,"value":24},{"line":348,"value":1},{"line":406,"value":3},{"line":322,"value":1},{"line":583,"value":1},{"line":590,"value":1},{"line":37,"value":2},{"line":544,"value":2},{"line":329,"value":1},{"line":553,"value":5}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/types.rs","complexity":26,"loc":91,"cloc":14,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":59,"value":24},{"line":113,"value":2}]}},{"FileMetrics":{"filename":"src/simple_triangle_detector.rs","complexity":19,"loc":139,"cloc":31,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":31,"value":1},{"line":39,"value":12},{"line":130,"value":6}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/pool_registry.rs","complexity":67,"loc":399,"cloc":118,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":487,"value":10},{"line":401,"value":2},{"line":80,"value":1},{"line":578,"value":1},{"line":324,"value":6},{"line":168,"value":9},{"line":456,"value":1},{"line":150,"value":2},{"line":446,"value":1},{"line":421,"value":1},{"line":132,"value":1},{"line":144,"value":1},{"line":472,"value":3},{"line":138,"value":1},{"line":555,"value":2},{"line":355,"value":21},{"line":587,"value":1},{"line":126,"value":1},{"line":101,"value":2}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/arbitrage_engine.rs","complexity":121,"loc":1037,"cloc":289,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":291,"value":24},{"line":1021,"value":32},{"line":106,"value":18},{"line":1016,"value":1},{"line":1011,"value":1},{"line":68,"value":2},{"line":608,"value":17},{"line":974,"value":4},{"line":997,"value":1},{"line":780,"value":21}]}},{"FileMetrics":{"filename":"src/jupiter_prices.rs","complexity":25,"loc":179,"cloc":24,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":114,"value":12},{"line":96,"value":1},{"line":86,"value":3},{"line":30,"value":2},{"line":47,"value":7}]}},{"FileMetrics":{"filename":"src/types.rs","complexity":26,"loc":92,"cloc":14,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":59,"value":24},{"line":112,"value":2}]}},{"FileMetrics":{"filename":"src/jito_bundle_client.rs","complexity":76,"loc":596,"cloc":151,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":707,"value":8},{"line":547,"value":1},{"line":305,"value":8},{"line":769,"value":2},{"line":433,"value":8},{"line":127,"value":2},{"line":33,"value":2},{"line":241,"value":5},{"line":654,"value":1},{"line":802,"value":1},{"line":751,"value":1},{"line":816,"value":2},{"line":824,"value":2},{"line":502,"value":3},{"line":197,"value":1},{"line":835,"value":2},{"line":660,"value":4},{"line":569,"value":11},{"line":845,"value":1},{"line":24,"value":1},{"line":762,"value":2},{"line":204,"value":2},{"line":394,"value":7}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/slippage.rs","complexity":11,"loc":84,"cloc":61,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":147,"value":1},{"line":26,"value":2},{"line":135,"value":1},{"line":55,"value":1},{"line":158,"value":1},{"line":111,"value":3},{"line":90,"value":2}]}},{"FileMetrics":{"filename":"src/meteora.rs","complexity":54,"loc":410,"cloc":98,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":475,"value":4},{"line":62,"value":37},{"line":379,"value":2},{"line":515,"value":5},{"line":365,"value":1},{"line":552,"value":1},{"line":372,"value":1},{"line":545,"value":1},{"line":506,"value":2}]}},{"FileMetrics":{"filename":"src/humidifi.rs","complexity":19,"loc":215,"cloc":58,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":190,"value":1},{"line":219,"value":2},{"line":43,"value":3},{"line":66,"value":5},{"line":313,"value":1},{"line":156,"value":4},{"line":243,"value":2},{"line":304,"value":1}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/triangle_arbitrage.rs","complexity":18,"loc":235,"cloc":68,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":25,"value":1},{"line":113,"value":11},{"line":213,"value":6}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/meteora_swap.rs","complexity":23,"loc":165,"cloc":38,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":35,"value":5},{"line":63,"value":9},{"line":169,"value":8},{"line":238,"value":1}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/jupiter_triangle.rs","complexity":20,"loc":186,"cloc":26,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":73,"value":1},{"line":82,"value":3},{"line":148,"value":8},{"line":114,"value":1},{"line":128,"value":3},{"line":240,"value":4}]}},{"FileMetrics":{"filename":"src/pumpswap.rs","complexity":17,"loc":184,"cloc":72,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":67,"value":2},{"line":84,"value":6},{"line":235,"value":7},{"line":277,"value":2}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/meteora.rs","complexity":54,"loc":343,"cloc":98,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":314,"value":2},{"line":448,"value":5},{"line":68,"value":37},{"line":409,"value":4},{"line":307,"value":1},{"line":485,"value":1},{"line":439,"value":2},{"line":478,"value":1},{"line":300,"value":1}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/config.rs","complexity":44,"loc":196,"cloc":108,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":109,"value":8},{"line":87,"value":1},{"line":273,"value":12},{"line":53,"value":1},{"line":36,"value":3},{"line":187,"value":14},{"line":63,"value":1},{"line":141,"value":4}]}},{"FileMetrics":{"filename":"src/triangle_arbitrage.rs","complexity":18,"loc":251,"cloc":68,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":25,"value":1},{"line":116,"value":11},{"line":223,"value":6}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/simple_triangle_detector.rs","complexity":19,"loc":135,"cloc":31,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":31,"value":1},{"line":39,"value":12},{"line":126,"value":6}]}},{"FileMetrics":{"filename":"src/arbitrage_engine.rs","complexity":125,"loc":1427,"cloc":291,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":1182,"value":4},{"line":1211,"value":1},{"line":1247,"value":36},{"line":696,"value":17},{"line":106,"value":18},{"line":68,"value":2},{"line":919,"value":21},{"line":1237,"value":1},{"line":312,"value":24},{"line":1242,"value":1}]}},{"FileMetrics":{"filename":"src/dex_registry.rs","complexity":8,"loc":128,"cloc":11,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":20,"value":3},{"line":129,"value":1},{"line":133,"value":1},{"line":138,"value":3}]}},{"FileMetrics":{"filename":"src/rpc_client.rs","complexity":64,"loc":306,"cloc":51,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":144,"value":18},{"line":402,"value":1},{"line":100,"value":7},{"line":81,"value":3},{"line":387,"value":2},{"line":34,"value":1},{"line":237,"value":9},{"line":49,"value":2},{"line":312,"value":6},{"line":373,"value":2},{"line":70,"value":2},{"line":222,"value":2},{"line":363,"value":2},{"line":291,"value":2},{"line":347,"value":3},{"line":336,"value":2}]}},{"FileMetrics":{"filename":"src/cached_blockhash.rs","complexity":10,"loc":96,"cloc":24,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":34,"value":5},{"line":88,"value":4},{"line":131,"value":1}]}},{"FileMetrics":{"filename":"clean_arb_bot/build.rs","complexity":2,"loc":15,"cloc":4,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":5,"value":2}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/jito_bundle_client.rs","complexity":76,"loc":555,"cloc":150,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":668,"value":8},{"line":468,"value":3},{"line":793,"value":2},{"line":27,"value":1},{"line":230,"value":5},{"line":720,"value":2},{"line":289,"value":8},{"line":369,"value":7},{"line":622,"value":4},{"line":712,"value":1},{"line":760,"value":1},{"line":130,"value":2},{"line":184,"value":1},{"line":537,"value":11},{"line":616,"value":1},{"line":803,"value":1},{"line":774,"value":2},{"line":515,"value":1},{"line":727,"value":2},{"line":191,"value":2},{"line":782,"value":2},{"line":405,"value":8},{"line":36,"value":2}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/orca.rs","complexity":46,"loc":353,"cloc":144,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":547,"value":1},{"line":367,"value":3},{"line":68,"value":24},{"line":287,"value":1},{"line":306,"value":1},{"line":540,"value":1},{"line":280,"value":1},{"line":40,"value":2},{"line":472,"value":4},{"line":510,"value":5},{"line":345,"value":1},{"line":501,"value":2}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/pool_population.rs","complexity":76,"loc":185,"cloc":41,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":24,"value":67},{"line":185,"value":5},{"line":218,"value":3},{"line":251,"value":1}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/jito_grpc_client.rs","complexity":23,"loc":199,"cloc":35,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":203,"value":1},{"line":86,"value":2},{"line":226,"value":6},{"line":215,"value":2},{"line":105,"value":4},{"line":272,"value":2},{"line":72,"value":4},{"line":44,"value":2}]}},{"FileMetrics":{"filename":"src/pool_registry.rs","complexity":67,"loc":470,"cloc":118,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":344,"value":6},{"line":104,"value":2},{"line":452,"value":2},{"line":80,"value":1},{"line":150,"value":1},{"line":497,"value":1},{"line":175,"value":9},{"line":645,"value":1},{"line":654,"value":1},{"line":472,"value":1},{"line":538,"value":10},{"line":616,"value":2},{"line":507,"value":1},{"line":132,"value":1},{"line":144,"value":1},{"line":138,"value":1},{"line":156,"value":2},{"line":381,"value":21},{"line":523,"value":3}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/shredstream_client.rs","complexity":19,"loc":163,"cloc":48,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":88,"value":2},{"line":99,"value":9},{"line":203,"value":1},{"line":209,"value":3},{"line":62,"value":1},{"line":221,"value":3}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/cached_blockhash.rs","complexity":10,"loc":89,"cloc":24,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":34,"value":5},{"line":84,"value":4},{"line":124,"value":1}]}},{"FileMetrics":{"filename":"src/shredstream_client.rs","complexity":19,"loc":187,"cloc":48,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":245,"value":3},{"line":92,"value":2},{"line":66,"value":1},{"line":225,"value":1},{"line":233,"value":3},{"line":103,"value":9}]}},{"FileMetrics":{"filename":"src/raydium.rs","complexity":43,"loc":364,"cloc":140,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":542,"value":1},{"line":535,"value":1},{"line":496,"value":2},{"line":48,"value":2},{"line":505,"value":5},{"line":468,"value":4},{"line":75,"value":25},{"line":342,"value":1},{"line":361,"value":1},{"line":335,"value":1}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/jito_submitter.rs","complexity":20,"loc":272,"cloc":72,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":328,"value":2},{"line":315,"value":1},{"line":274,"value":2},{"line":55,"value":14},{"line":362,"value":1}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/raydium.rs","complexity":43,"loc":320,"cloc":140,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":425,"value":4},{"line":452,"value":2},{"line":461,"value":5},{"line":48,"value":2},{"line":321,"value":1},{"line":498,"value":1},{"line":78,"value":25},{"line":295,"value":1},{"line":302,"value":1},{"line":491,"value":1}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/cost_calculator.rs","complexity":32,"loc":260,"cloc":232,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":548,"value":1},{"line":303,"value":1},{"line":533,"value":1},{"line":78,"value":12},{"line":435,"value":1},{"line":415,"value":1},{"line":334,"value":2},{"line":398,"value":1},{"line":298,"value":1},{"line":308,"value":3},{"line":511,"value":1},{"line":465,"value":1},{"line":369,"value":2},{"line":493,"value":1},{"line":275,"value":2}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/humidifi.rs","complexity":19,"loc":195,"cloc":58,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":284,"value":1},{"line":199,"value":2},{"line":43,"value":3},{"line":169,"value":1},{"line":66,"value":5},{"line":223,"value":2},{"line":141,"value":4},{"line":293,"value":1}]}},{"FileMetrics":{"filename":"src/jito_submitter.rs","complexity":20,"loc":295,"cloc":73,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":352,"value":2},{"line":386,"value":1},{"line":339,"value":1},{"line":55,"value":14},{"line":298,"value":2}]}},{"FileMetrics":{"filename":"src/cost_calculator.rs","complexity":32,"loc":263,"cloc":233,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":337,"value":2},{"line":311,"value":3},{"line":402,"value":1},{"line":497,"value":1},{"line":469,"value":1},{"line":78,"value":12},{"line":306,"value":1},{"line":301,"value":1},{"line":281,"value":2},{"line":515,"value":1},{"line":373,"value":2},{"line":439,"value":1},{"line":552,"value":1},{"line":419,"value":1},{"line":537,"value":1}]}},{"FileMetrics":{"filename":"src/config.rs","complexity":44,"loc":205,"cloc":108,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":192,"value":14},{"line":280,"value":12},{"line":109,"value":8},{"line":87,"value":1},{"line":53,"value":1},{"line":36,"value":3},{"line":146,"value":4},{"line":63,"value":1}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/jito_tip_monitor.rs","complexity":26,"loc":198,"cloc":39,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":93,"value":1},{"line":60,"value":1},{"line":236,"value":1},{"line":270,"value":2},{"line":40,"value":1},{"line":66,"value":2},{"line":56,"value":1},{"line":256,"value":1},{"line":151,"value":6},{"line":243,"value":1},{"line":220,"value":1},{"line":79,"value":2},{"line":114,"value":6}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/swap_executor.rs","complexity":75,"loc":534,"cloc":188,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":487,"value":10},{"line":659,"value":2},{"line":647,"value":1},{"line":62,"value":8},{"line":812,"value":1},{"line":753,"value":5},{"line":653,"value":1},{"line":721,"value":1},{"line":451,"value":2},{"line":327,"value":6},{"line":785,"value":1},{"line":732,"value":3},{"line":121,"value":1},{"line":256,"value":12},{"line":600,"value":2},{"line":372,"value":6},{"line":138,"value":13}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/dex_registry.rs","complexity":8,"loc":59,"cloc":11,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":20,"value":3},{"line":66,"value":1},{"line":70,"value":1},{"line":75,"value":3}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/jupiter_prices.rs","complexity":25,"loc":161,"cloc":24,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":114,"value":12},{"line":96,"value":1},{"line":86,"value":3},{"line":30,"value":2},{"line":47,"value":7}]}},{"FileMetrics":{"filename":"src/main.rs","complexity":11,"loc":146,"cloc":14,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":49,"value":11}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/pumpswap.rs","complexity":17,"loc":162,"cloc":72,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":67,"value":2},{"line":84,"value":6},{"line":226,"value":7},{"line":266,"value":2}]}},{"FileMetrics":{"filename":"src/slippage.rs","complexity":11,"loc":80,"cloc":61,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":89,"value":2},{"line":26,"value":2},{"line":154,"value":1},{"line":54,"value":1},{"line":110,"value":3},{"line":143,"value":1},{"line":131,"value":1}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/position_tracker.rs","complexity":24,"loc":244,"cloc":112,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":349,"value":1},{"line":100,"value":2},{"line":333,"value":1},{"line":133,"value":1},{"line":292,"value":1},{"line":307,"value":1},{"line":223,"value":2},{"line":70,"value":2},{"line":41,"value":1},{"line":159,"value":4},{"line":263,"value":1},{"line":359,"value":1},{"line":244,"value":1},{"line":378,"value":5}]}},{"FileMetrics":{"filename":"src/pool_population.rs","complexity":76,"loc":185,"cloc":41,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":24,"value":67},{"line":185,"value":5},{"line":218,"value":3},{"line":251,"value":1}]}},{"FileMetrics":{"filename":"src/jito_tip_monitor.rs","complexity":26,"loc":220,"cloc":39,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":60,"value":1},{"line":292,"value":2},{"line":258,"value":1},{"line":40,"value":1},{"line":66,"value":2},{"line":82,"value":2},{"line":56,"value":1},{"line":157,"value":6},{"line":278,"value":1},{"line":120,"value":6},{"line":99,"value":1},{"line":265,"value":1},{"line":242,"value":1}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/rpc_client.rs","complexity":64,"loc":265,"cloc":51,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":255,"value":2},{"line":52,"value":2},{"line":128,"value":18},{"line":324,"value":2},{"line":333,"value":2},{"line":197,"value":2},{"line":347,"value":2},{"line":361,"value":1},{"line":308,"value":3},{"line":37,"value":1},{"line":298,"value":2},{"line":70,"value":2},{"line":93,"value":7},{"line":78,"value":3},{"line":275,"value":6},{"line":211,"value":9}]}},{"FileMetrics":{"filename":"src/position_tracker.rs","complexity":24,"loc":274,"cloc":112,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":178,"value":4},{"line":334,"value":1},{"line":319,"value":1},{"line":146,"value":1},{"line":408,"value":5},{"line":389,"value":1},{"line":360,"value":1},{"line":79,"value":2},{"line":242,"value":2},{"line":41,"value":1},{"line":111,"value":2},{"line":286,"value":1},{"line":379,"value":1},{"line":267,"value":1}]}},{"FileMetrics":{"filename":"src/jupiter_triangle.rs","complexity":20,"loc":192,"cloc":26,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":130,"value":3},{"line":73,"value":1},{"line":116,"value":1},{"line":82,"value":3},{"line":150,"value":8},{"line":246,"value":4}]}},{"FileMetrics":{"filename":"clean_arb_bot/src/main.rs","complexity":11,"loc":126,"cloc":14,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":49,"value":11}]}},{"FileMetrics":{"filename":"src/meteora_swap.rs","complexity":23,"loc":175,"cloc":38,"nrMethods":null,"nrClasses":null,"lineComplexities":[{"line":35,"value":5},{"line":64,"value":9},{"line":174,"value":8},{"line":243,"value":1}]}},{"FileMetrics":{"filename":"clean_arb_bot/scripts/go_live.sh","complexity":null,"loc":121,"cloc":8,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/scripts/filter_impact.sh","complexity":null,"loc":35,"cloc":4,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/production/arb_bot_manager.sh","complexity":null,"loc":158,"cloc":35,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/scripts/start_live_trading.sh","complexity":null,"loc":46,"cloc":8,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/scripts/monitor_status.sh","complexity":null,"loc":38,"cloc":6,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/production/bot_control.sh","complexity":null,"loc":110,"cloc":2,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/production/autonomous_monitor.sh","complexity":null,"loc":220,"cloc":41,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/scripts/monitor_live_trades.sh","complexity":null,"loc":16,"cloc":3,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/scripts/trading_summary.sh","complexity":null,"loc":35,"cloc":4,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/production/stop_arb_bot.sh","complexity":null,"loc":36,"cloc":7,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/production/watchdog.sh","complexity":null,"loc":91,"cloc":25,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/scripts/start_live_monitoring.sh","complexity":null,"loc":27,"cloc":6,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/scripts/quick_status.sh","complexity":null,"loc":28,"cloc":8,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/scripts/run_with_jupiter.sh","complexity":null,"loc":12,"cloc":1,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/scripts/benchmark_cycle6.sh","complexity":null,"loc":42,"cloc":9,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/scripts/MONITOR_BOT.sh","complexity":null,"loc":56,"cloc":6,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/scripts/monitor_dashboard.sh","complexity":null,"loc":118,"cloc":23,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/production/start_arb_bot.sh","complexity":null,"loc":42,"cloc":8,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/scripts/monitor_dashboard_detailed.sh","complexity":null,"loc":153,"cloc":39,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/production/status_arb_bot.sh","complexity":null,"loc":75,"cloc":15,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/scripts/check_trading_status.sh","complexity":null,"loc":43,"cloc":6,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/production/health_check_old.sh","complexity":null,"loc":116,"cloc":11,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}},{"FileMetrics":{"filename":"clean_arb_bot/production/health_check.sh","complexity":null,"loc":119,"cloc":13,"nrMethods":null,"nrClasses":null,"lineComplexities":[]}}]
